/* parser generated by jison 0.4.17-130 */
/*
 * Returns a Parser object of the following structure:
 *
 *  Parser: {
 *    yy: {}
 *  }
 *
 *  Parser.prototype: {
 *    yy: {},
 *    EOF: 1,
 *    TERROR: 2,
 *
 *    trace: function(errorMessage, errorHash),
 *
 *    JisonParserError: function(msg, hash),
 *
 *    quoteName: function(name),
 *               Helper function which can be overridden by user code later on: put suitable
 *               quotes around literal IDs in a description string.
 *
 *    describeSymbol: function(symbol),
 *               Return a more-or-less human-readable description of the given symbol, when
 *               available, or the symbol itself, serving as its own 'description' for lack
 *               of something better to serve up.
 *
 *               Return NULL when the symbol is unknown to the parser.
 *
 *    symbols_: {associative list: name ==> number},
 *    terminals_: {associative list: number ==> name},
 *    nonterminals: {associative list: rule-name ==> {associative list: number ==> rule-alt}},
 *    terminal_descriptions_: (if there are any) {associative list: number ==> description},
 *    productions_: [...],
 *
 *    performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$, yystack, ...),
 *               where `...` denotes the (optional) additional arguments the user passed to
 *               `parser.parse(str, ...)`
 *
 *    table: [...],
 *               State transition table
 *               ----------------------
 *
 *               index levels are:
 *               - `state`  --> hash table
 *               - `symbol` --> action (number or array)
 *
 *                 If the `action` is an array, these are the elements' meaning:
 *                 - index [0]: 1 = shift, 2 = reduce, 3 = accept
 *                 - index [1]: GOTO `state`
 *
 *                 If the `action` is a number, it is the GOTO `state`
 *
 *    defaultActions: {...},
 *
 *    parseError: function(str, hash),
 *    yyErrOk: function(),
 *    yyClearIn: function(),
 *
 *    options: { ... parser %options ... },
 *
 *    parse: function(input),
 *
 *    lexer: {
 *        EOF: 1,
 *        ERROR: 2,
 *        JisonLexerError: function(msg, hash),
 *        parseError: function(str, hash),
 *        setInput: function(input),
 *        input: function(),
 *        unput: function(str),
 *        more: function(),
 *        reject: function(),
 *        less: function(n),
 *        pastInput: function(),
 *        upcomingInput: function(),
 *        showPosition: function(),
 *        test_match: function(regex_match_array, rule_index),
 *        next: function(),
 *        lex: function(),
 *        begin: function(condition),
 *        popState: function(),
 *        _currentRules: function(),
 *        topState: function(),
 *        pushState: function(condition),
 *        stateStackSize: function(),
 *
 *        options: { ... lexer %options ... },
 *
 *        performAction: function(yy, yy_, $avoiding_name_collisions, YY_START),
 *        rules: [...],
 *        conditions: {associative list: name ==> set},
 *    }
 *  }
 *
 *
 *  token location info (@$, _$, etc.): {
 *    first_line: n,
 *    last_line: n,
 *    first_column: n,
 *    last_column: n,
 *    range: [start_number, end_number]
 *               (where the numbers are indexes into the input string, zero-based)
 *  }
 *
 * ---
 *
 * The parseError function receives a 'hash' object with these members for lexer and
 * parser errors:
 *
 *  {
 *    text:        (matched text)
 *    token:       (the produced terminal token, if any)
 *    token_id:    (the produced terminal token numeric ID, if any)
 *    line:        (yylineno)
 *    loc:         (yylloc)
 *  }
 *
 * parser (grammar) errors will also provide these additional members:
 *
 *  {
 *    expected:    (array describing the set of expected tokens;
 *                  may be empty when we cannot easily produce such a set)
 *    recoverable: (boolean: TRUE when the parser MAY have an error recovery rule
 *                  available for this particular error)
 *    state_stack: (array: the current parser LALR/LR internal state stack; this can be used,
 *                  for instance, for advanced error analysis and reporting)
 *    value_stack: (array: the current parser LALR/LR internal `$$` value stack; this can be used,
 *                  for instance, for advanced error analysis and reporting)
 *    location_stack: (array: the current parser LALR/LR internal location stack; this can be used,
 *                  for instance, for advanced error analysis and reporting)
 *    lexer:       (reference to the current lexer instance used by the parser)
 *  }
 *
 * while `this` will reference the current parser instance.
 *
 *  When `parseError` is invoked by the lexer, `this` will still reference the related *parser*
 *  instance, while these additional `hash` fields will also be provided:
 *
 *  {
 *    lexer:       (reference to the current lexer instance which reported the error)
 *  }
 *
 *  When `parseError` is invoked by the parser due to a **JavaScript exception** being fired
 *  from either the parser or lexer, `this` will still reference the related *parser*
 *  instance, while these additional `hash` fields will also be provided:
 *
 *  {
 *    exception:   (reference to the exception thrown)
 *  }
 *
 *  Please do note that in the latter situation, the `expected` field will be omitted as
 *  type of failure is assumed not to be due to *parse errors* but rather due to user
 *  action code in either parser or lexer failing unexpectedly.
 *
 * ---
 *
 * You can specify parser options by setting / modifying the `.yy` object of your Parser instance.
 * These options are available:
 *
 * ### options which are global for all parser instances
 *
 *  Parser.pre_parse: function(yy [, optional parse() args])
 *                 optional: you can specify a pre_parse() function in the chunk following
 *                 the grammar, i.e. after the last `%%`.
 *  Parser.post_parse: function(yy, retval [, optional parse() args]) { return retval; }
 *                 optional: you can specify a post_parse() function in the chunk following
 *                 the grammar, i.e. after the last `%%`. When it does not return any value,
 *                 the parser will return the original `retval`.
 *
 * ### options which can be set up per parser instance
 *  
 *  yy: {
 *      pre_parse:  function(yy [, optional parse() args])
 *                 optional: is invoked before the parse cycle starts (and before the first
 *                 invocation of `lex()`) but immediately after the invocation of
 *                 `parser.pre_parse()`).
 *      post_parse: function(yy, retval [, optional parse() args]) { return retval; }
 *                 optional: is invoked when the parse terminates due to success ('accept')
 *                 or failure (even when exceptions are thrown).
 *                 `retval` contains the return value to be produced by `Parser.parse()`;
 *                 this function can override the return value by returning another. 
 *                 When it does not return any value, the parser will return the original
 *                 `retval`. 
 *                 This function is invoked immediately before `Parser.post_parse()`.
 *
 *      parseError: function(str, hash)
 *                 optional: overrides the default `parseError` function.
 *      quoteName: function(name),
 *                 optional: overrides the default `quoteName` function.
 *  }
 *
 *  parser.lexer.options: {
 *      pre_lex:  function()
 *                 optional: is invoked before the lexer is invoked to produce another token.
 *                 `this` refers to the Lexer object.
 *      post_lex: function(token) { return token; }
 *                 optional: is invoked when the lexer has produced a token `token`;
 *                 this function can override the returned token value by returning another.
 *                 When it does not return any (truthy) value, the lexer will return
 *                 the original `token`.
 *                 `this` refers to the Lexer object.
 *
 *      ranges: boolean
 *                 optional: `true` ==> token location info will include a .range[] member.
 *      flex: boolean
 *                 optional: `true` ==> flex-like lexing behaviour where the rules are tested
 *                 exhaustively to find the longest match.
 *      backtrack_lexer: boolean
 *                 optional: `true` ==> lexer regexes are tested in order and for invoked;
 *                 the lexer terminates the scan when a token is returned by the action code.
 *      xregexp: boolean
 *                 optional: `true` ==> lexer rule regexes are "extended regex format" requiring the
 *                 `XRegExp` library. When this %option has not been specified at compile time, all lexer
 *                 rule regexes have been written as standard JavaScript RegExp expressions.
 *  }
 */
var formulaV3 = (function () {

// See also:
// http://stackoverflow.com/questions/1382107/whats-a-good-way-to-extend-error-in-javascript/#35881508
// but we keep the prototype.constructor and prototype.name assignment lines too for compatibility
// with userland code which might access the derived class in a 'classic' way.
function JisonParserError(msg, hash) {
    Object.defineProperty(this, 'name', {
        enumerable: false,
        writable: false,
        value: 'JisonParserError'
    });

    if (msg == null) msg = '???';

    Object.defineProperty(this, 'message', {
        enumerable: false,
        writable: true,
        value: msg
    });

    this.hash = hash;

    var stacktrace;
    if (hash && hash.exception instanceof Error) {
        var ex2 = hash.exception;
        this.message = ex2.message || msg;
        stacktrace = ex2.stack;
    }
    if (!stacktrace) {
        if (Error.hasOwnProperty('captureStackTrace')) { // V8
            Error.captureStackTrace(this, this.constructor);
        } else {
            stacktrace = (new Error(msg)).stack;
        }
    }
    if (stacktrace) {
        Object.defineProperty(this, 'stack', {
            enumerable: false,
            writable: false,
            value: stacktrace
        });
    }
}

if (typeof Object.setPrototypeOf === 'function') {
    Object.setPrototypeOf(JisonParserError.prototype, Error.prototype);
} else {
    JisonParserError.prototype = Object.create(Error.prototype);
}
JisonParserError.prototype.constructor = JisonParserError;
JisonParserError.prototype.name = 'JisonParserError';



// helper: reconstruct the productions[] table
function bp(s) {
    var rv = [];
    var p = s.pop;
    var r = s.rule;
    for (var i = 0, l = p.length; i < l; i++) {
        rv.push([
            p[i],
            r[i]
        ]);
    }
    return rv;
}

// helper: reconstruct the defaultActions[] table
function bda(s) {
    var rv = {};
    var d = s.idx;
    var p = s.pop;
    var r = s.rule;
    for (var i = 0, l = d.length; i < l; i++) {
        var j = d[i];
        rv[j] = [
            p[i],
            r[i]
        ];
    }
    return rv;
}

// helper: reconstruct the 'goto' table
function bt(s) {
    var rv = [];
    var d = s.len;
    var y = s.symbol;
    var t = s.type;
    var a = s.state;
    var m = s.mode;
    var g = s.goto;
    for (var i = 0, l = d.length; i < l; i++) {
        var n = d[i];
        var q = {};
        for (var j = 0; j < n; j++) {
            var z = y.shift();
            switch (t.shift()) {
            case 2:
                q[z] = [
                    m.shift(),
                    g.shift()
                ];
                break;

            case 0:
                q[z] = a.shift();
                break;

            default:
                // type === 1: accept
                q[z] = [
                    3
                ];
            }
        }
        rv.push(q);
    }
    return rv;
}

// helper: runlength encoding with increment step: code, length: step (default step = 0)
// `this` references an array
function s(c, l, a) {
    a = a || 0;
    for (var i = 0; i < l; i++) {
        this.push(c);
        c += a;
    }
}

// helper: duplicate sequence from *relative* offset and length.
// `this` references an array
function c(i, l) {
    i = this.length - i;
    for (l += i; i < l; i++) {
        this.push(this[i]);
    }
}

// helper: unpack an array using helpers and data, all passed in an array argument 'a'.
function u(a) {
    var rv = [];
    for (var i = 0, l = a.length; i < l; i++) {
        var e = a[i];
        // Is this entry a helper function?
        if (typeof e === 'function') {
            i++;
            e.apply(rv, a[i]);
        } else {
            rv.push(e);
        }
    }
    return rv;
}

var parser = {
EOF: 1,
TERROR: 2,
trace: function no_op_trace() { },
JisonParserError: JisonParserError,
yy: {},
options: {
  type: "lalr"
},
symbols_: {
  "!": 33,
  "$": 36,
  "$accept": 0,
  "$end": 1,
  "(": 40,
  ")": 41,
  "*": 42,
  "+": 43,
  ",": 44,
  "-": 45,
  ".": 46,
  "/": 47,
  ":": 58,
  "<": 60,
  "=": 61,
  ">": 62,
  "?": 63,
  "@": 64,
  "ALMOST_EQUAL": 152,
  "ARRAY_CONCATENATION_OPERATOR": 183,
  "BOOLEAN_AND_OPERATOR": 146,
  "BOOLEAN_OR_OPERATOR": 147,
  "CELLREF": 182,
  "CELLREF_PARSE_MODE": 131,
  "CONSTANT": 197,
  "CUBE_OPERATOR": 165,
  "CURRENCY": 193,
  "DEGREES_OPERATOR": 192,
  "EOF": 1,
  "EXCEL_FORCED_STRING": 144,
  "FALSE": 199,
  "FUNCTION": 171,
  "GREATER_OR_EQUAL": 155,
  "INTEGER_NUMBER": 196,
  "IS_EQUAL": 157,
  "IS_IDENTICAL": 153,
  "Ill_be_boogered": 201,
  "JSON_FIELD_NAME": 174,
  "JSON_FILTER_FUNCTION": 175,
  "LESS_OR_EQUAL": 156,
  "MODULO_OPERATOR": 160,
  "NOT_EQUAL": 149,
  "NOT_IDENTICAL": 150,
  "NUMBER": 195,
  "PATH": 181,
  "PERCENTAGE_OPERATOR": 190,
  "PROMILAGE_OPERATOR": 191,
  "RANGEREF": 188,
  "RANGEREF_PARSE_MODE": 133,
  "SQRT_OPERATOR": 163,
  "SQUARE_OPERATOR": 164,
  "STRING": 200,
  "STRING_CONCATENATION_OPERATOR": 158,
  "TRUE": 198,
  "URI": 179,
  "VALUE_PARSE_MODE": 135,
  "[": 91,
  "]": 93,
  "^": 94,
  "accept_direct_value": 130,
  "ambiguous_any_range_reference": 186,
  "any_range_reference": 134,
  "arglist": 172,
  "atomic_expression": 162,
  "boolean": 141,
  "boolean_expression": 145,
  "cell_reference": 132,
  "compare_expression": 148,
  "constant": 137,
  "curlybraced_range_reference": 185,
  "data_source": 167,
  "do_the_work": 128,
  "error": 2,
  "exponential_expression": 161,
  "fundamental_cell_reference": 176,
  "json_filter_expression": 170,
  "math_expression": 129,
  "multiply_expression": 159,
  "multivalued_data_source": 169,
  "number": 194,
  "numeric_expression": 151,
  "one_argument": 189,
  "one_json_filter_level": 173,
  "optional_remote_address_marker": 180,
  "percentage": 138,
  "percentage_alternative_for_data_entry": 143,
  "price": 139,
  "radians": 140,
  "range_reference": 187,
  "remote_address": 177,
  "remote_address_marker": 178,
  "single_range_reference_fragment": 184,
  "start_parsing": 127,
  "string": 142,
  "string_concatenation_expression": 154,
  "unary_expression": 166,
  "unary_expression_rvalue": 168,
  "value": 136,
  "{": 123,
  "}": 125
},
terminals_: {
  1: "EOF",
  2: "error",
  33: "!",
  36: "$",
  40: "(",
  41: ")",
  42: "*",
  43: "+",
  44: ",",
  45: "-",
  46: ".",
  47: "/",
  58: ":",
  60: "<",
  61: "=",
  62: ">",
  63: "?",
  64: "@",
  91: "[",
  93: "]",
  94: "^",
  123: "{",
  125: "}",
  131: "CELLREF_PARSE_MODE",
  133: "RANGEREF_PARSE_MODE",
  135: "VALUE_PARSE_MODE",
  144: "EXCEL_FORCED_STRING",
  146: "BOOLEAN_AND_OPERATOR",
  147: "BOOLEAN_OR_OPERATOR",
  149: "NOT_EQUAL",
  150: "NOT_IDENTICAL",
  152: "ALMOST_EQUAL",
  153: "IS_IDENTICAL",
  155: "GREATER_OR_EQUAL",
  156: "LESS_OR_EQUAL",
  157: "IS_EQUAL",
  158: "STRING_CONCATENATION_OPERATOR",
  160: "MODULO_OPERATOR",
  163: "SQRT_OPERATOR",
  164: "SQUARE_OPERATOR",
  165: "CUBE_OPERATOR",
  171: "FUNCTION",
  174: "JSON_FIELD_NAME",
  175: "JSON_FILTER_FUNCTION",
  179: "URI",
  181: "PATH",
  182: "CELLREF",
  183: "ARRAY_CONCATENATION_OPERATOR",
  188: "RANGEREF",
  190: "PERCENTAGE_OPERATOR",
  191: "PROMILAGE_OPERATOR",
  192: "DEGREES_OPERATOR",
  193: "CURRENCY",
  195: "NUMBER",
  196: "INTEGER_NUMBER",
  197: "CONSTANT",
  198: "TRUE",
  199: "FALSE",
  200: "STRING"
},
productions_: bp({
  pop: u([
  127,
  127,
  s,
  [128, 7],
  s,
  [130, 10],
  129,
  s,
  [145, 3],
  s,
  [148, 11],
  154,
  154,
  s,
  [151, 3],
  s,
  [159, 4],
  s,
  [161, 6],
  s,
  [162, 10],
  s,
  [166, 3],
  168,
  168,
  167,
  167,
  s,
  [169, 3],
  170,
  170,
  s,
  [173, 4],
  132,
  132,
  s,
  [177, 7],
  180,
  180,
  178,
  176,
  s,
  [134, 3],
  185,
  s,
  [186, 4],
  184,
  184,
  187,
  s,
  [189, 3],
  172,
  172,
  s,
  [143, 3],
  138,
  138,
  140,
  139,
  139,
  s,
  [136, 3],
  194,
  194,
  s,
  [137, 3],
  141,
  141,
  142,
  201
]),
  rule: u([
  s,
  [2, 3],
  1,
  s,
  [2, 5],
  s,
  [1, 11],
  3,
  3,
  c,
  [3, 3],
  s,
  [3, 8],
  1,
  c,
  [13, 4],
  c,
  [16, 4],
  1,
  3,
  c,
  [39, 15],
  c,
  [14, 6],
  3,
  4,
  3,
  c,
  [5, 3],
  1,
  4,
  4,
  c,
  [17, 5],
  2,
  s,
  [4, 4],
  0,
  c,
  [68, 8],
  s,
  [1, 8],
  0,
  c,
  [60, 6],
  s,
  [2, 6],
  c,
  [59, 6],
  s,
  [1, 3],
  25
])
}),
performAction: function anonymous(yytext, yy, yystate /* action[1] */, $$ /* vstack */, _$ /* lstack */, cfg, one, two) {
/* this == yyval */

    /*
     * This chunk is included at the top of the actionHandler itself.
     */
    var rv, range;

    //console.log("parser exec rule: ", yystate, this, yy.lexer.options, arguments);

    var patch_tokenstream = yy.lexer.options.patch_tokenstream;
    assert(patch_tokenstream);
    var patch_resulttype = yy.lexer.options.patch_resulttype;
    assert(patch_resulttype);

var $0 = $$.length - 1;
switch (yystate) {
case 1 : 
/*! Production::     start_parsing : do_the_work EOF */
 // Note: we MAY return values such as 'undefined' or 'null', which would otherwise be picked up
            // by the JISON parser rig itself and be converted to a *boolean* `TRUE` value (action code 3 inside
            // the jison LALR parser stack engine).
            //
            // To thwart this 'default return value' behaviour of JISON we always wrap the actual calculated
            // value in an object, where our wrapper code will then extract it once we get outside the jison
            // engine/driver.
            return {
                value: $$[$0 - 1]
            }; 
break;
case 2 : 
/*! Production::     start_parsing : do_the_work error */
 rv = yy.parser.parseError("We do not expect anything following the valid expression.", {
                text: $$[$0],
                token: $$[$0],
                line: _$[$0],
                loc: _$[$0],
                outer_loc: this._$,
                expected: [],
                recoverable: false
            });
            assert(rv === null);
            return {
                value: NaN
            }; 
break;
case 3 : 
/*! Production::     do_the_work : '=' math_expression */
 patch_resulttype(FT_FORMULA);

            this.$ = $$[$0]; 
break;
case 4 : 
/*! Production::     do_the_work : accept_direct_value */
 rv = $$[$0];
            // A bit of a hack: when you enter a 'direct value EXPRESSION', e.g. `E1`, where the
            // referenced cell doesn't exist and therefor has no value (`undefined`), we *still*
            // want the resulting value right here to be one of string/boolean/number/date/whatever,
            // but we certainly DO NOT want it to produce the value `undefined`.
            //
            // Hence we coerce the result (as little as possible) before feeding it back to the caller.
            this.$ = coerceValueToStringIfUndefined(rv); 
break;
case 5 : 
/*! Production::     do_the_work : CELLREF_PARSE_MODE cell_reference */
 case 65 : 
/*! Production::     data_source : multivalued_data_source */
 case 70 : 
/*! Production::     json_filter_expression : one_json_filter_level */
 case 72 : 
/*! Production::     one_json_filter_level : JSON_FIELD_NAME */
 case 88 : 
/*! Production::     fundamental_cell_reference : CELLREF */
 case 103 : 
/*! Production::     arglist : one_argument */
 this.$ = $$[$0]; 
break;
case 6 : 
/*! Production::     do_the_work : CELLREF_PARSE_MODE error */
 rv = yy.parser.parseError("Expected a single cell reference.", {
                text: $$[$0],
                token: $$[$0],
                line: _$[$0],
                loc: _$[$0],
                outer_loc: this._$,
                expected: [],
                recoverable: false
            });
            assert(rv === null);
            this.$ = NaN; 
break;
case 7 : 
/*! Production::     do_the_work : RANGEREF_PARSE_MODE any_range_reference */
 /*
             * Check whether the AST is really a RANGEREF and not a CELLREF as the `any_range_reference` rule
             * can deliver a single CELLREF node due to LALR(1) grammar restrictions keeping us from
             * completely separating CELLREF and RANGEREF parsing.
             *
             * Anything apart from a RANGEREF should trigger an error report.
             */
            if (Array.isArray($$[$0])) {
                this.$ = $$[$0];
            } else {
                rv = yy.parser.parseError("Expected a cell range reference.", {
                    text: $$[$0],
                    token: $$[$0],
                    line: _$[$0],
                    loc: _$[$0],
                    outer_loc: this._$,
                    expected: [],
                    recoverable: false
                });
                assert(rv === null);
                this.$ = NaN;
            } 
break;
case 8 : 
/*! Production::     do_the_work : RANGEREF_PARSE_MODE error */
 rv = yy.parser.parseError("Expected a cell range reference.", {
                text: $$[$0],
                token: $$[$0],
                line: _$[$0],
                loc: _$[$0],
                outer_loc: this._$,
                expected: [],
                recoverable: false
            });
            assert(rv === null);
            this.$ = NaN; 
break;
case 9 : 
/*! Production::     do_the_work : VALUE_PARSE_MODE accept_direct_value */
 /*
             * TODO:
             *
             * Check whether the AST so far is 'basic' and suitable for 'folding' to a single value.
             *
             * Anything else should trigger an error report.
             */
            this.$ = $$[$0]; 
break;
case 17 : 
/*! Production::     accept_direct_value : percentage_alternative_for_data_entry */
 /* see the rule comment: this is to support Excel-compatible value data entry */
            this.$ = $$[$0]; 
break;
case 18 : 
/*! Production::     accept_direct_value : EXCEL_FORCED_STRING */
 patch_resulttype(FT_STRING);

            /* see the rule comment: this is to support Excel-compatible value data entry */
            assert(typeof $$[$0] === "string");
            this.$ = $$[$0]; 
break;
case 19 : 
/*! Production::     accept_direct_value : error */
 case 59 : 
/*! Production::     atomic_expression : error */
 rv = yy.parser.parseError("Expected a value or formula expression.", {
                text: $$[$0],
                token: $$[$0],
                line: _$[$0],
                loc: _$[$0],
                outer_loc: this._$,
                expected: [],
                recoverable: false
            });
            assert(rv === null);
            this.$ = NaN; 
break;
case 21 : 
/*! Production::     boolean_expression : boolean_expression[first] BOOLEAN_AND_OPERATOR boolean_expression[last] */
 // Excel: `=AND("T",1)` gives `#VALUE!`; we do not emulate that behaviour here!
            this.$ = !!($$[$0 - 2] && $$[$0]); 
break;
case 22 : 
/*! Production::     boolean_expression : boolean_expression[first] BOOLEAN_OR_OPERATOR boolean_expression[last] */
 // Excel: `=OR("T",1)` gives `#VALUE!`; we do not emulate that behaviour here!
            this.$ = !!($$[$0 - 2] || $$[$0]); 
break;
case 24 : 
/*! Production::     compare_expression : compare_expression[first] NOT_EQUAL compare_expression[last] */
 case 25 : 
/*! Production::     compare_expression : compare_expression[first] NOT_IDENTICAL compare_expression[last] */
 // WARNING: see the Excel note below at IS_EQUAL: we don't really have a type-agnostic compare available!
            $$[$0 - 2] = coerceValueToStringIfUndefined($$[$0 - 2]);
            $$[$0] = coerceValueToStringIfUndefined($$[$0]);
            this.$ = ($$[$0 - 2] !== $$[$0]); 
break;
case 26 : 
/*! Production::     compare_expression : numeric_expression[first] ALMOST_EQUAL numeric_expression[last] */
 var f = coerceValueToNumeric($$[$0 - 2]);
            var l = coerceValueToNumeric($$[$0]);
            if (!isNaN(f) && !isNaN(l)) {
            	// TODO: constant values: move this outside so we don't need to calculate this every time!
            	var ε = 1e-9;
            	var ACCEPTED_NUMERIC_ACCURACY_LOG = Math.log(1 + ε);

            	// NEARNESS is a *relative* thing: it's about accuracy. Here we hardcode an 'accepted accuracy' of 0.001ppm.
            	// Since we use logarithms for this, we must ensure that both values being compared are non-zero *positive*
            	// numbers, hence we offset them by the minimum of the two, plus 1.0:
            	var lowest = Math.min(f, l);
            	f += 1 + lowest;
            	l += 1 + lowest;
	            if (isFinite(f) && isFinite(l)) {
	            	var df = Math.log(f);
	            	var dl = Math.log(l);
		            assert(isFinite(f));
		            assert(isFinite(l));
	                this.$ = (Math.abs(df - dl) <= ACCEPTED_NUMERIC_ACCURACY_LOG); /* ε */
	            } else {
	                // arguments may be nearly-out-of-range numeric values: in this case we cop out and turn this into
	                // an identity check; if only one of them 'INF-ed out', we got a winner too.
                    this.$ = ($$[$0 - 2] === $$[$0]);
	            }
            } else {
                // arguments may be a non-numeric type: here we perform a type-agnostic comparison then.
                // Also make sure that NaN compares to NaN as TRUE (JavaScript gives FALSE for that particular comparison)
                this.$ = ($$[$0 - 2] == $$[$0]) || (isNaN($$[$0 - 2]) && isNaN($$[$0]));
            } 
break;
case 27 : 
/*! Production::     compare_expression : compare_expression[first] IS_IDENTICAL compare_expression[last] */
 // WARNING: see the Excel note below at IS_EQUAL: we don't really have a type-agnostic compare available!
            $$[$0 - 2] = coerceValueToStringIfUndefined($$[$0 - 2]);
            $$[$0] = coerceValueToStringIfUndefined($$[$0]);
            this.$ = ($$[$0 - 2] === $$[$0]); 
break;
case 28 : 
/*! Production::     compare_expression : string_concatenation_expression[first] GREATER_OR_EQUAL string_concatenation_expression[last] */
 $$[$0 - 2] = coerceValueToNumeric($$[$0 - 2]);
            $$[$0] = coerceValueToNumeric($$[$0]);
            // Excel: `=FALSE>1.0e300` gives TRUE: we do not emulate that behaviour here.
            //
            // Excel treats TRUE and FALSE as being *outside* the numeric range.
            // Other Excel peculiarities, such as `=TRUE+1` --> `` (empty!) are also unsupported!
            this.$ = ($$[$0 - 2] >= $$[$0]); 
break;
case 29 : 
/*! Production::     compare_expression : string_concatenation_expression[first] LESS_OR_EQUAL string_concatenation_expression[last] */
 $$[$0 - 2] = coerceValueToNumeric($$[$0 - 2]);
            $$[$0] = coerceValueToNumeric($$[$0]);
            // Excel: `=FALSE>1.0e300` gives TRUE: we do not emulate that behaviour here.
            //
            // Excel treats TRUE and FALSE as being *outside* the numeric range.
            // Other Excel peculiarities, such as `=TRUE+1` --> `` (empty!) are also unsupported!
            this.$ = ($$[$0 - 2] <= $$[$0]); 
break;
case 30 : 
/*! Production::     compare_expression : string_concatenation_expression[first] '>'[greater_than] string_concatenation_expression[last] */
 $$[$0 - 2] = coerceValueToNumeric($$[$0 - 2]);
            $$[$0] = coerceValueToNumeric($$[$0]);
            // Excel: `=FALSE>1.0e300` gives TRUE: we do not emulate that behaviour here.
            //
            // Excel treats TRUE and FALSE as being *outside* the numeric range.
            // Other Excel peculiarities, such as `=TRUE+1` --> `` (empty!) are also unsupported!
            this.$ = ($$[$0 - 2] > $$[$0]); 
break;
case 31 : 
/*! Production::     compare_expression : string_concatenation_expression[first] '<'[less_than] string_concatenation_expression[last] */
 $$[$0 - 2] = coerceValueToNumeric($$[$0 - 2]);
            $$[$0] = coerceValueToNumeric($$[$0]);
            // Excel: `=FALSE>1.0e300` gives TRUE: we do not emulate that behaviour here.
            //
            // Excel treats TRUE and FALSE as being *outside* the numeric range.
            // Other Excel peculiarities, such as `=TRUE+1` --> `` (empty!) are also unsupported!
            this.$ = ($$[$0 - 2] < $$[$0]); 
break;
case 32 : 
/*! Production::     compare_expression : compare_expression[first] '='[equals] compare_expression[last] */
 // Excel says `="1"=1` is FALSE so doesn't perform auto-type-coercion while JavaScript does.
            // Hence we have to use `===` instead of `==` here:
            $$[$0 - 2] = coerceValueToStringIfUndefined($$[$0 - 2]);
            $$[$0] = coerceValueToStringIfUndefined($$[$0]);
            this.$ = ($$[$0 - 2] === $$[$0]); 
break;
case 33 : 
/*! Production::     compare_expression : compare_expression[first] IS_EQUAL compare_expression[last] */
 /*
             * This is just another notation for `=`, but we don't allow `==`, etc. as start markers
             * of a formula, so we end up having to 'is equal' opcode tokens, alas.
             */
            $$[$0 - 2] = coerceValueToStringIfUndefined($$[$0 - 2]);
            $$[$0] = coerceValueToStringIfUndefined($$[$0]);
            this.$ = ($$[$0 - 2] === $$[$0]); 
break;
case 35 : 
/*! Production::     string_concatenation_expression : string_concatenation_expression[first] STRING_CONCATENATION_OPERATOR string_concatenation_expression[last] */
 $$[$0 - 2] = coerceValueToStringIfUndefined($$[$0 - 2]);
            $$[$0] = coerceValueToStringIfUndefined($$[$0]);
            this.$ = ('' + $$[$0 - 2] + $$[$0]); 
break;
case 37 : 
/*! Production::     numeric_expression : numeric_expression[first] '+'[add] numeric_expression[last] */
 $$[$0 - 2] = coerceValueToNumeric($$[$0 - 2]);
            $$[$0] = coerceValueToNumeric($$[$0]);
            // Excel: `=FALSE>1.0e300` gives TRUE: we do not emulate that behaviour here.
            //
            // Excel treats TRUE and FALSE as being *outside* the numeric range.
            // Other Excel peculiarities, such as `=TRUE+1` --> `` (empty!) are also unsupported!
            this.$ = ($$[$0 - 2] + $$[$0]); 
break;
case 38 : 
/*! Production::     numeric_expression : numeric_expression[first] '-'[subtract] numeric_expression[last] */
 $$[$0 - 2] = coerceValueToNumeric($$[$0 - 2]);
            $$[$0] = coerceValueToNumeric($$[$0]);
            // Excel: `=FALSE>1.0e300` gives TRUE: we do not emulate that behaviour here.
            //
            // Excel treats TRUE and FALSE as being *outside* the numeric range.
            // Other Excel peculiarities, such as `=TRUE+1` --> `` (empty!) are also unsupported!
            this.$ = ($$[$0 - 2] - $$[$0]); 
break;
case 40 : 
/*! Production::     multiply_expression : multiply_expression[first] '*'[multiply] multiply_expression[last] */
 $$[$0 - 2] = coerceValueToNumeric($$[$0 - 2]);
            $$[$0] = coerceValueToNumeric($$[$0]);
            // Excel: `=TRUE*1` --> `1`: for multiplication, TRUE and FALSE are treated as numeric 1 and 0, respectively.
            // Of course, we *do* support that behaviour!
            this.$ = ($$[$0 - 2] * $$[$0]); 
break;
case 41 : 
/*! Production::     multiply_expression : multiply_expression[first] '/'[divide] multiply_expression[last] */
 $$[$0 - 2] = coerceValueToNumeric($$[$0 - 2]);
            $$[$0] = coerceValueToNumeric($$[$0]);
            this.$ = ($$[$0 - 2] / $$[$0]);
            // TODO: detect division by zero for two non-error inputs and then report #DIV/0 
break;
case 42 : 
/*! Production::     multiply_expression : multiply_expression[first] MODULO_OPERATOR multiply_expression[last] */
 $$[$0 - 2] = coerceValueToNumeric($$[$0 - 2]);
            $$[$0] = coerceValueToNumeric($$[$0]);
            this.$ = ($$[$0 - 2] % $$[$0]); 
break;
case 44 : 
/*! Production::     exponential_expression : atomic_expression[first] '^'[power] exponential_expression[last] */
 $$[$0 - 2] = coerceValueToNumeric($$[$0 - 2]);
            $$[$0] = coerceValueToNumeric($$[$0]);
            this.$ = Math.pow($$[$0 - 2], $$[$0]); 
break;
case 45 : 
/*! Production::     exponential_expression : SQRT_OPERATOR exponential_expression */
 $$[$0] = coerceValueToNumeric($$[$0]);
            this.$ = Math.sqrt($$[$0]); 
break;
case 46 : 
/*! Production::     exponential_expression : exponential_expression SQUARE_OPERATOR */
 $$[$0 - 1] = coerceValueToNumeric($$[$0 - 1]);
            this.$ = Math.pow($$[$0 - 1], 2); 
break;
case 47 : 
/*! Production::     exponential_expression : exponential_expression CUBE_OPERATOR */
 $$[$0 - 1] = coerceValueToNumeric($$[$0 - 1]);
            this.$ = Math.pow($$[$0 - 1], 3); 
break;
case 48 : 
/*! Production::     exponential_expression : exponential_expression '?'[TOPS20_help_request] */
 rv = yy.parser.parseError("TODO: provide inline/online help for this expression.", {
                text: $$[$0],
                token: $$[$0],
                line: _$[$0],
                loc: _$[$0],
                outer_loc: this._$,
                expected: [],
                recoverable: false
            });
            assert(rv === null);
            this.$ = NaN; 
break;
case 60 : 
/*! Production::     unary_expression : '-'[minus] unary_expression_rvalue */
 this.$ = -coerceValueToNumeric($$[$0]); 
break;
case 61 : 
/*! Production::     unary_expression : '+'[plus] unary_expression_rvalue */
 this.$ = +coerceValueToNumeric($$[$0]); 
break;
case 62 : 
/*! Production::     unary_expression : '!'[negate] unary_expression_rvalue */
 if (!isNaN($$[$0])) {
                this.$ = !($$[$0]);   // No need to coerce the operand to numeric value before we apply boolean NOT
            } else {
                // propagate errors (NaN)
                this.$ = $$[$0];
            } 
break;
case 64 : 
/*! Production::     unary_expression_rvalue : error */
 rv = yy.parser.parseError("Expected a numeric value or bracketed formula expression.", {
                text: $$[$0],
                token: $$[$0],
                line: _$[$0],
                loc: _$[$0],
                outer_loc: this._$,
                expected: [],
                recoverable: false
            });
            assert(rv === null);
            this.$ = NaN; 
break;
case 66 : 
/*! Production::     data_source : multivalued_data_source '.'[dot] json_filter_expression */
 case 71 : 
/*! Production::     json_filter_expression : one_json_filter_level '.'[dot] json_filter_expression */
 rv = yy.parser.parseError("Dotted references into cell values are currently not support yet.", {
                text: $$[$0],
                token: $$[$0],
                line: _$[$0],
                loc: _$[$0],
                outer_loc: this._$,
                expected: [],
                recoverable: false
            });
            assert(rv === null);
            this.$ = NaN; 
break;
case 67 : 
/*! Production::     multivalued_data_source : FUNCTION '('[open] arglist ')'[close] */
 /*
             * get the function name and attributes from the token argument:
             */
            var f_tok_locinfo = _$[$0 - 3];
            var f_tok_spec = $$[$0 - 3];
            var a = $$[$0 - 1];
            var chk;
            //console.log("exec function: ", f_tok_locinfo, f_tok_spec, a);
            assert(vUserPreferences.quality >= VQ_PRODUCTION_READY ? f_tok_spec.opcode ? (f_tok_spec.opcode.implementation || f_tok_spec.opcode.value !== undefined) : false /* only entries with good implementation are allowed */ : true);
            if (f_tok_spec.opcode && f_tok_spec.opcode.implementation) {
                // TODO: call generic validation function which picks up .opcode.parameters_set_definition[]
                // WARNING: that def array is not the bees' knees as it is flaky concerning functions
                // which accept arbitrary number and/or type of arguments: e.g. SUM, MAX, MIN: it TRIES to
                // encode that knowledge in the array, but you WILL hit snags as the idea has been coded but
                // never tested as is: THIS is testing time... :-(

                chk = yy.parser.passingArgumentSetValidation(f_tok_spec.opcode, a);
                if (chk) {
                    //console.log("Function " + f_tok_spec.text + ": ", chk);

                    // Implementation Notes
                    // --------------------
                    //
                    // You MUST invoke the custom parseError() coming from parserinput.js@134 by using the 'yy'
                    // variable as that one is the only one pointing at your 'live' Parser instance.
                    // ('this' points to the current yyval without the parser actions, which contrasts with the lexer actions...)
                    if (chk.is_user_failure) {
                        // When the error is a user formula entry mistake, it will abort and flag the formula as an error.
                        rv = yy.parser.parseError("Function " + f_tok_spec.text + ": " + chk.message, {
                            text: $$[$0 - 3],
                            token: $$[$0 - 3],
                            line: _$[$0 - 3],
                            loc: _$[$0 - 3],
                            expected: [],
                            recoverable: false,
                            failure_info: chk
                        });
                        assert(rv === null);
                        this.$ = NaN;
                    } else {
                        // Otherwise, the validation code discover a data input ('sourcing') error, which doesn't invalidate
                        // the function used, it merely will make it *fail* at run-time, producing an error (NaN) value.
                        //
                        // This type of error has no further impact: it only should be reported to help the user while she is
                        // entering the formula, thus serving as a notification that "you shouldn't expect anything sane from this
                        // formula given these inputs you're feeding it!"
                        //
                        // Ergo we DO report this issue, but DO NOT push an ERROR token into the tokenstream or otherwise abort
                        // the formula parsing process right now.
                        vGraph._dispatchEvent(vGraph.EVENT.onParseError, {
                            message: "Function " + f_tok_spec.text + ": " + chk.message,
                            dataErrorInfo: chk
                        });
                        // continue as if nothing untoward happened:
                        chk = false;
                    }
                }

                if (!chk) {
                    //console.log("a: ", a); // this is an array of values: one value per function argument.
                    if (f_tok_spec.opcode.subject_category_references === FCT_CATEGORY_QA) {
                        // provide our QA UDFs with location info for better reporting:
                        a.push({
                            command_token: f_tok_spec,
                            command_locinfo: _$[$0 - 3],
                            args_start_locinfo: _$[$0 - 2],
                            args_locinfo: _$[$0 - 1],
                            args_end_locinfo: _$[$0]
                        });
                    }
                    //WAS: $$ = f_tok_spec.opcode.implementation.apply(this, a);
                    this.$ = Visyond.Functions.__exec_wrapper(f_tok_spec, a);        // 'flatten' and 'coerce' the argument list where needed.
                }
            } else if (f_tok_spec.opcode && f_tok_spec.opcode.value != null) {
                // We are invoking an Excel-like 'function constant'.
                // Make sure didn't pass any parameters, as passing any would be illegal.
                //
                // Note that the 'epsilon' argument (of which we expect exactly ONE), itself is
                // encoded as NULL!
                assert(a.length >= 1);
                if (a.length !== 1 && a[0] !== null) {
                    //console.log("Functional CONSTANT " + f_tok_spec.text + ": ", a);
                    // Implementation Notes
                    // --------------------
                    //
                    // You MUST invoke the custom parseError() coming from parserinput.js@134 by using the 'yy'
                    // variable as that one is the only one pointing at your 'live' Parser instance.
                    // ('this' points to the current yyval without the parser actions, which contrasts with the lexer actions...)
                    rv = yy.parser.parseError("Functional CONSTANT " + f_tok_spec.text + ": does not accept any arguments", {
                        text: $$[$0 - 3],
                        token: $$[$0 - 3],
                        line: _$[$0 - 3],
                        loc: _$[$0 - 3],
                        expected: [],
                        recoverable: false
                    });
                    assert(rv === null);
                    this.$ = NaN;
                } else {
                    this.$ = f_tok_spec.opcode.value;
                }
            } else {
                // we are trying to invoke a function which does NOT have any implementation!
                // This is an error - of the kind of 'not implemented yet?'
                rv = yy.parser.parseError("Function " + f_tok_spec.text + " has not been implemented yet.", {
                    text: $$[$0 - 3],
                    token: $$[$0 - 3],
                    line: _$[$0 - 3],
                    loc: _$[$0 - 3],
                    expected: [],
                    recoverable: false
                });
                assert(rv === null);
                this.$ = NaN;
            } 
break;
case 68 : 
/*! Production::     multivalued_data_source : '(' math_expression ')' */
 case 112 : 
/*! Production::     price : value CURRENCY */
 this.$ = $$[$0 - 1]; 
break;
case 69 : 
/*! Production::     multivalued_data_source : cell_reference */
 this.$ = getCellValueByLabel($$[$0]); 
break;
case 73 : 
/*! Production::     one_json_filter_level : JSON_FILTER_FUNCTION '(' arglist ')' */
 case 74 : 
/*! Production::     one_json_filter_level : one_json_filter_level '[' math_expression ']'[last] */
 this.$ = $$[$0 - 3]; 
break;
case 75 : 
/*! Production::     one_json_filter_level : error */
 rv = yy.parser.parseError("Sub-level filters into cell values are currently not support yet.", {
                text: $$[$0],
                token: $$[$0],
                line: _$[$0],
                loc: _$[$0],
                outer_loc: this._$,
                expected: [],
                recoverable: false
            });
            assert(rv === null);
            this.$ = NaN; 
break;
case 77 : 
/*! Production::     cell_reference : remote_address fundamental_cell_reference */
 rv = yy.parser.parseError("Remote / Cross-project cell references are currently not support yet.", {
                text: $$[$0 - 1],
                token: $$[$0 - 1],
                line: _$[$0 - 1],
                loc: _$[$0 - 1],
                outer_loc: this._$,
                expected: [],
                recoverable: false
            });
            assert(rv === null);
            this.$ = NaN; 
break;
case 78 : 
/*! Production::     remote_address : string remote_address_marker */
 // classic Excel mode: the 'remote' bit is stored in a string
            this.$ = $$[$0 - 1]; 
break;
case 79 : 
/*! Production::     remote_address : URI optional_remote_address_marker */
 // we accept an OPTIONAL 'remote address marker' as '/' (which is part of the uri path) at the end is good enough as a separator too
            this.$ = $$[$0 - 1]; 
break;
case 80 : 
/*! Production::     remote_address : PATH optional_remote_address_marker */
 // we accept an OPTIONAL 'remote address marker' as '/' (which is part of the path) at the end is good enough as a separator too
            this.$ = $$[$0 - 1]; 
break;
case 81 : 
/*! Production::     remote_address : '(' URI ')' optional_remote_address_marker */
 case 82 : 
/*! Production::     remote_address : '(' PATH ')' optional_remote_address_marker */
 case 84 : 
/*! Production::     remote_address : '[' PATH ']' optional_remote_address_marker */
 this.$ = $$[$0 - 2]; 
break;
case 83 : 
/*! Production::     remote_address : '[' URI ']' optional_remote_address_marker */
 // Excel way of referencing another workbook file...
            //
            // http://www.officetooltips.com/excel/tips/referencing_cells_outside_the_worksheet.html
            this.$ = $$[$0 - 2]; 
break;
case 89 : 
/*! Production::     any_range_reference : any_range_reference[first] ARRAY_CONCATENATION_OPERATOR any_range_reference[last] */
 /* a fragmented range, using alternative notation, i.e. this is equivalent to `{ any_range_reference , any_range_reference }` */
            //console.log("any_range_reference rule 1 :", @$);
            range = parser.mergeRanges($$[$0 - 2], $$[$0]);
            parser.updateRangeLocationInfo(range, this._$, +1);
            this.$ = range; 
break;
case 90 : 
/*! Production::     any_range_reference : any_range_reference[left] ARRAY_CONCATENATION_OPERATOR error */
 rv = yy.parser.parseError("Expected a cell or range reference to complete the range.", {
                text: $$[$0],
                token: $$[$0],
                line: _$[$0],
                loc: _$[$0],
                outer_loc: this._$,
                expected: [],
                recoverable: false
            });
            assert(rv === null);
            //console.log("any_range_reference rule 2 : error: ", @$);
            this.$ = $$[$0 - 2]; 
break;
case 92 : 
/*! Production::     curlybraced_range_reference : '{'[open] ambiguous_any_range_reference '}'[close] */
 /*
             * A single range reference hiding in fragmented range notation or a fragmented range references with multiple curly braces surrounding it.
             *
             * We call the inner rule `**ambiguous_**any_range_reference` as it allows a cell range to be constructed
             * using ',' comma separated cell references, which as a notation is *ambiguous* when used in a function parameter list:
             * neither man nor machine will be able to identify which bits constitute a bundled range of cells and which items
             * are separate function arguments then if we do not use a bit of 'assistive' notation: the '{' '}' curly braces
             * which 'wrap' such an *ambiguous* range notation, e.g. `SUMPRODUCT({A1,A2,B1,B2},{C1,C2})`
             */
            range = $$[$0 - 1];
            parser.updateRangeLocationInfo(range, this._$, +2);
            this.$ = range; 
break;
case 93 : 
/*! Production::     ambiguous_any_range_reference : ambiguous_any_range_reference[first] ',' ambiguous_any_range_reference[last] */
 /* a fragmented range: */
            //console.log("ambiguous_any_range_reference rule 1 :", @$);
            range = parser.mergeRanges($$[$0 - 2], $$[$0]);
            parser.updateRangeLocationInfo(range, this._$, +1);
            this.$ = range; 
break;
case 94 : 
/*! Production::     ambiguous_any_range_reference : any_range_reference */
 /* a fragmented range, a cell reference or a regular range reference */
            this.$ = $$[$0]; 
break;
case 95 : 
/*! Production::     ambiguous_any_range_reference : cell_reference */
 /* a single cell reference, possibly acting as a range-of-one, depending on where this is used: */
            //console.log("ambiguous_any_range_reference rule 3 : cell: ", @$);
            range = parser.createRangeFromCell($$[$0]);
            parser.updateRangeLocationInfo(range, this._$, +1);
            this.$ = range; 
break;
case 96 : 
/*! Production::     ambiguous_any_range_reference : error */
 rv = yy.parser.parseError("Expected a (possibly fragmented) range reference.", {
                text: $$[$0],
                token: $$[$0],
                line: _$[$0],
                loc: _$[$0],
                outer_loc: this._$,
                expected: [],
                recoverable: false
            });
            assert(rv === null);
            //console.log("ambiguous_any_range_reference rule 4 : error: ", @$);
            range = {
                rangeRef: null,
                locInfo: null,
                consumeCount: 0
            };
            parser.updateRangeLocationInfo(range, this._$, 0);
            this.$ = range; 
break;
case 97 : 
/*! Production::     single_range_reference_fragment : range_reference */
 /* a regular range reference: */
            //console.log("range_reference rule 1 : range: ", @$);
            range = parser.createRangeFromRange($$[$0]);
            parser.updateRangeLocationInfo(range, this._$, +1);
            this.$ = range; 
break;
case 98 : 
/*! Production::     single_range_reference_fragment : curlybraced_range_reference */
 /* a nested range reference which will be merged/flattened with any other cells / ranges in the outer range reference: */
            this.$ = $$[$0]; 
break;
case 99 : 
/*! Production::     range_reference : RANGEREF */
 /*
             * > ### Note on cell reference order in a range
             * >
             * > we don't mind if 'first' is below or to the right of 'last'.
             * > The area is calculated in the action function where the range is used
             * > and there the row / col min and max values will be determined, so
             * > that we can use a simple and effective storage method here.
             * >
             * > Besides, the user might have a good reason to specify the range
             * > that way, so we better keep the first->last order as specified by
             * > the user to insure we can deliver expected behaviour (and not loose
             * > context information in the parse).
             */
            this.$ = $$[$0]; 
break;
case 100 : 
/*! Production::     one_argument : math_expression */
 this.$ = [$$[$0]]; 
break;
case 101 : 
/*! Production::     one_argument : any_range_reference */
 // this still is a single function argument and should be identifiable as such:
            // hence the range specified as argument is stored into a single outer array entry here.
            //
            // Example to see the 'trouble': =MATCH(7,A1:A6,0): to properly feed MATCH() it should
            // receive 3 arguments: [1, [...], 0], where [...] is an ARRAY value listing the values
            // obtained from the range A1:A6, e.g. [3,4,5,6,7,8]
            //
            // WARNING: the current parser (the non-AST one!) always converts cell (and range) references
            // to values extremely quickly; this implies that functions such as ADDRESS() or INDEX() are
            // not supported as those require access to the actual cell references themselves.
            //
            // (Aside: of course we can be nasty and hack a cellref on top of a value as a JavaScript object attribute
            // but I'd rather not go there and do it properly with AST objects instead using the new parser...)
            //
            // Now for the slightly less positive news: =SUM(A1:A6) vs. =SUM(A1,A2,A3,A4,A5,A6) vs. =SUM(A1:A4,A5,A6):
            // all MUST deliver the same value due to the way SUM is meant to work, but these three will 'invoke'
            // the SUM() operator very differently: here are their arglist arrays: (assume A1=1, A2=2, ...)
            //
            //   =SUM(A1:A6)             : A1:A6             -> one_array_entry                           -> arglist = [[1,2,3,4,5,6]]
            //   =SUM(A1,A2,A3,A4,A5,A6) : A1,A2,A3,A4,A5,A6 -> one_element, one_element, ... (6x)        -> arglist = [1,2,3,4,5,6]
            //   =SUM(A1:A4,A5,A6)       : A1:A4,A5,A6       -> one_array_entry, one_element, one_element -> arglist = [[1,2,3,4],5,6]
            //
            // Now for the REAL trouble:
            //   =MATCH(7,A1:A6,0) (or any other Excel function that expects at least one other function parameter next to an array)
            //   -> do some projection or row insert/delete op in the grid: Visyond will 'service' you by rewriting the array TOKEN
            //      into an ARRAY of tokens. Great idea but you just lost everything as now the parameter list is ambiguous and cannot
            //      be resolved any more for such functions:
            //   -> drag/drop / insert row / other action that rewrites arrays in tokenarray
            //   -> =MATCH(7,A1,A2,A3,A4,A5,A6,0)
            //   -> OUCH! Nobody can tell us later on whether this is a user mistake feeding the function too many arguments or
            //      this being an expanded array in there. (Yes, there do exist Excel functions (Matrix ops!) which expect 2(!) or more
            //      array references as function arguments: when both are expanded (and they will), there is no telling where one
            //      ends and the next starts.)
            //   => Support for these functions (including SUMA(), SUMIF(), ...) is only possible when 'token stream rewriting' is heavily
            //      augmented and the parser is taught some additional notation as well (this is partly available in the AST grammar as
            //      it supports a superset of the Excel formula notation), e.g.
            //   =MATCH(7,A1:A6,0) -> tokenstream rewrite -> =MATCH(7,{A1,A2,A3,A4,A5,A6},0)
            //      or when expansion is done partially:
            //   =MATCH(7,A1:A6,0) -> tokenstream rewrite -> =MATCH(7,{A1,A2:A5,A6},0)
            //      With this 'extended' notation re-using the '{}' curly braces (also used by Excel for array formulas but we do not support those (yet))
            //      anything inside the curly braces is treated as part of a single array element:
            //   {A1,A2,A3,A4,A5,A6} is equivalent to {A1,A2:A5,A6} is equivalent to {A1:A6} is equivalent to A1:A6
            //
            // Anyhow, the above is NOT supported by this parser; only the AST parser provides for these constructs. The above explanation
            // is included here so y'all know what goes wrong and why...
            range = $$[$0];

            //patch_tokenstream("RANGEREF", range, 1 /* range.consumeCount */, @any_range_reference);

            /* This rule 'outputs' an array of values, each representing one cell value in the specified array */
            this.$ = [parser.getArrayValueOfCellRangeSpec(range.rangeRef)]; 
break;
case 102 : 
/*! Production::     one_argument : ε */
 /*
             * No argument specified at all: some functions accept this kind of behaviour.
             * It also serves as a way to specify a function with zero arguments, e.g.
             * `RANDOM()`.
             *
             * An empty argument is also legal as part of a larger argument set where *optional*
             * argument entries are accepted, e.g. `IF(A1,B1,)` or `LINEST(A1:A3,B1:B3,,1)`
             * hence we must push a special `nil` AST node for every empty argument.
             */

            // empty argument must take up a slot in the args array, hence we push NULL:
            this.$ = [null]; 
break;
case 104 : 
/*! Production::     arglist : arglist ','[comma] one_argument */
 this.$ = $$[$0 - 2].concat($$[$0]); 
break;
case 105 : 
/*! Production::     percentage_alternative_for_data_entry : MODULO_OPERATOR value */
 // Excel supports percentage direct value entry as `%5` next to `5%`
            patch_tokenstream("PERCENTAGE_OPERATOR", null, 1, _$[$0 - 1]);
            this.$ = $$[$0] / 100; 
break;
case 106 : 
/*! Production::     percentage_alternative_for_data_entry : PERCENTAGE_OPERATOR value */
 // Excel supports percentage direct value entry as `%5` next to `5%`
            this.$ = $$[$0] / 100; 
break;
case 107 : 
/*! Production::     percentage_alternative_for_data_entry : PROMILAGE_OPERATOR value */
 this.$ = $$[$0] / 1000; 
break;
case 108 : 
/*! Production::     percentage : value PERCENTAGE_OPERATOR */
 this.$ = $$[$0 - 1] / 100; 
break;
case 109 : 
/*! Production::     percentage : value PROMILAGE_OPERATOR */
 this.$ = $$[$0 - 1] / 1000; 
break;
case 110 : 
/*! Production::     radians : value DEGREES_OPERATOR */
 // convert value to radians!
            this.$ = $$[$0 - 1] * 2 * Math.PI / 360; 
break;
case 111 : 
/*! Production::     price : CURRENCY value */
 /* The `CURRENCY` AST opcode has the notation attributes we need: */
            this.$ = $$[$0]; 
break;
case 113 : 
/*! Production::     value : '-'[minus] number */
 case 119 : 
/*! Production::     constant : '-'[minus] CONSTANT */
 this.$ = -($$[$0]); 
break;
case 114 : 
/*! Production::     value : '+'[plus] number */
 case 120 : 
/*! Production::     constant : '+'[plus] CONSTANT */
 this.$ = +($$[$0]); 
break;
case 116 : 
/*! Production::     number : NUMBER */
 assert(Number($$[$0]) === yytext);
            this.$ = $$[$0]; 
break;
case 117 : 
/*! Production::     number : INTEGER_NUMBER */
 assert(Number($$[$0]) === yytext);
            //console.log("Integer Number: value = ", $INTEGER_NUMBER, @INTEGER_NUMBER, yytext);
            this.$ = $$[$0]; 
break;
}
},
table: bt({
  len: u([
  30,
  1,
  2,
  40,
  2,
  11,
  7,
  24,
  6,
  s,
  [2, 9],
  4,
  4,
  31,
  27,
  6,
  27,
  27,
  28,
  s,
  [6, 3],
  31,
  31,
  1,
  1,
  2,
  7,
  12,
  20,
  17,
  23,
  26,
  27,
  34,
  27,
  27,
  31,
  s,
  [27, 5],
  29,
  27,
  19,
  19,
  15,
  28,
  1,
  40,
  28,
  29,
  2,
  29,
  4,
  4,
  s,
  [2, 5],
  3,
  2,
  s,
  [6, 4],
  18,
  2,
  s,
  [27, 4],
  31,
  c,
  [39, 4],
  3,
  3,
  s,
  [2, 3],
  39,
  39,
  s,
  [38, 5],
  s,
  [36, 3],
  s,
  [37, 5],
  s,
  [35, 3],
  s,
  [26, 3],
  34,
  26,
  1,
  1,
  s,
  [27, 5],
  5,
  50,
  1,
  5,
  5,
  29,
  s,
  [1, 7],
  7,
  c,
  [67, 3],
  2,
  7,
  7,
  s,
  [12, 5],
  14,
  20,
  20,
  13,
  19,
  s,
  [13, 3],
  17,
  s,
  [23, 3],
  26,
  27,
  29,
  29,
  1,
  29,
  c,
  [98, 4],
  28,
  s,
  [4, 4],
  c,
  [101, 4],
  5,
  40,
  50,
  28,
  49,
  s,
  [1, 4],
  2,
  27,
  1,
  2,
  2,
  29,
  29
]),
  symbol: u([
  2,
  43,
  45,
  61,
  127,
  128,
  130,
  131,
  133,
  s,
  [135, 10, 1],
  160,
  190,
  191,
  s,
  [193, 8, 1],
  1,
  1,
  2,
  2,
  33,
  40,
  43,
  45,
  91,
  129,
  132,
  c,
  [31, 7],
  s,
  [145, 4, 3],
  159,
  161,
  162,
  163,
  166,
  167,
  169,
  171,
  176,
  177,
  179,
  181,
  182,
  c,
  [43, 9],
  2,
  2,
  40,
  91,
  132,
  142,
  c,
  [20, 5],
  200,
  2,
  123,
  134,
  184,
  185,
  187,
  188,
  c,
  [93, 3],
  130,
  c,
  [87, 21],
  2,
  s,
  [190, 4, 1],
  1,
  2,
  1,
  2,
  c,
  [4, 14],
  c,
  [31, 4],
  c,
  [4, 4],
  1,
  2,
  s,
  [41, 5, 1],
  47,
  s,
  [60, 4, 1],
  93,
  94,
  146,
  147,
  149,
  150,
  152,
  153,
  s,
  [155, 4, 1],
  160,
  164,
  165,
  c,
  [57, 6],
  c,
  [31, 25],
  43,
  45,
  136,
  c,
  [65, 3],
  c,
  [33, 27],
  c,
  [27, 29],
  33,
  c,
  [88, 31],
  c,
  [6, 12],
  c,
  [164, 58],
  c,
  [31, 5],
  c,
  [346, 3],
  c,
  [35, 3],
  44,
  93,
  146,
  147,
  c,
  [7, 4],
  61,
  c,
  [8, 3],
  149,
  150,
  153,
  157,
  c,
  [12, 3],
  c,
  [53, 3],
  c,
  [52, 3],
  c,
  [16, 5],
  c,
  [50, 6],
  c,
  [32, 4],
  c,
  [18, 8],
  c,
  [17, 8],
  c,
  [91, 8],
  c,
  [39, 11],
  160,
  c,
  [114, 13],
  c,
  [244, 40],
  c,
  [478, 6],
  c,
  [477, 8],
  c,
  [472, 22],
  c,
  [332, 54],
  c,
  [286, 56],
  c,
  [27, 110],
  c,
  [498, 26],
  178,
  c,
  [310, 28],
  c,
  [746, 4],
  167,
  168,
  c,
  [298, 7],
  c,
  [297, 4],
  200,
  c,
  [19, 33],
  c,
  [329, 8],
  46,
  c,
  [81, 20],
  40,
  c,
  [870, 42],
  c,
  [69, 26],
  c,
  [28, 15],
  125,
  c,
  [29, 13],
  176,
  182,
  c,
  [31, 29],
  33,
  178,
  180,
  182,
  c,
  [4, 4],
  179,
  181,
  c,
  [664, 4],
  33,
  178,
  c,
  [8, 4],
  183,
  c,
  [675, 6],
  125,
  c,
  [8, 3],
  c,
  [6, 16],
  c,
  [219, 3],
  123,
  132,
  134,
  c,
  [1005, 6],
  s,
  [184, 5, 1],
  c,
  [153, 3],
  c,
  [468, 135],
  c,
  [607, 58],
  c,
  [58, 58],
  c,
  [413, 3],
  c,
  [1042, 5],
  c,
  [261, 4],
  c,
  [850, 14],
  c,
  [457, 25],
  c,
  [39, 53],
  c,
  [38, 190],
  151,
  c,
  [36, 108],
  c,
  [145, 37],
  c,
  [37, 147],
  c,
  [35, 91],
  c,
  [1569, 39],
  c,
  [26, 39],
  c,
  [1594, 47],
  c,
  [60, 13],
  182,
  c,
  [1165, 8],
  c,
  [1069, 128],
  2,
  170,
  173,
  174,
  175,
  c,
  [202, 3],
  c,
  [1910, 4],
  91,
  123,
  129,
  132,
  134,
  c,
  [912, 19],
  172,
  c,
  [1254, 7],
  187,
  188,
  189,
  c,
  [218, 8],
  41,
  33,
  41,
  c,
  [1328, 4],
  c,
  [5, 4],
  c,
  [1366, 29],
  s,
  [182, 3],
  93,
  93,
  41,
  41,
  c,
  [2318, 7],
  44,
  125,
  c,
  [1338, 3],
  c,
  [5, 4],
  c,
  [2041, 11],
  c,
  [2048, 18],
  c,
  [12, 48],
  c,
  [125, 3],
  c,
  [2110, 31],
  c,
  [2130, 21],
  c,
  [52, 8],
  c,
  [33, 15],
  c,
  [32, 21],
  c,
  [13, 27],
  c,
  [2201, 47],
  c,
  [23, 46],
  c,
  [2247, 42],
  c,
  [390, 13],
  91,
  c,
  [29, 44],
  40,
  c,
  [30, 29],
  41,
  44,
  41,
  44,
  c,
  [4, 4],
  c,
  [1783, 4],
  c,
  [1912, 25],
  c,
  [1852, 8],
  c,
  [4, 8],
  c,
  [1839, 36],
  c,
  [633, 8],
  c,
  [2037, 37],
  c,
  [673, 50],
  c,
  [175, 28],
  c,
  [78, 31],
  c,
  [77, 18],
  s,
  [182, 4],
  c,
  [693, 5],
  c,
  [382, 24],
  93,
  c,
  [291, 4],
  c,
  [387, 58]
]),
  type: u([
  s,
  [2, 4],
  s,
  [0, 3],
  c,
  [6, 6],
  s,
  [0, 5],
  s,
  [2, 5],
  c,
  [6, 6],
  2,
  1,
  s,
  [2, 8],
  s,
  [0, 16],
  c,
  [52, 5],
  c,
  [44, 6],
  c,
  [43, 7],
  c,
  [39, 9],
  c,
  [10, 14],
  c,
  [50, 10],
  c,
  [44, 16],
  s,
  [2, 19],
  c,
  [135, 5],
  s,
  [2, 63],
  c,
  [129, 8],
  s,
  [2, 80],
  c,
  [207, 8],
  c,
  [100, 92],
  s,
  [2, 120],
  c,
  [472, 33],
  s,
  [2, 243],
  c,
  [683, 32],
  c,
  [302, 7],
  c,
  [42, 11],
  c,
  [19, 30],
  c,
  [392, 46],
  c,
  [398, 81],
  c,
  [64, 32],
  c,
  [102, 4],
  c,
  [168, 10],
  c,
  [110, 36],
  c,
  [982, 8],
  c,
  [1012, 10],
  c,
  [556, 252],
  c,
  [259, 15],
  c,
  [457, 39],
  c,
  [39, 53],
  c,
  [38, 188],
  c,
  [36, 108],
  c,
  [37, 184],
  c,
  [35, 94],
  c,
  [1594, 270],
  c,
  [1211, 13],
  s,
  [0, 17],
  c,
  [212, 7],
  c,
  [1254, 7],
  c,
  [216, 3],
  c,
  [46, 10],
  c,
  [21, 7],
  c,
  [295, 43],
  s,
  [2, 474],
  c,
  [1852, 8],
  c,
  [1860, 14],
  c,
  [1839, 30],
  c,
  [1900, 11],
  c,
  [2037, 42],
  c,
  [673, 44],
  c,
  [2158, 50],
  c,
  [122, 11],
  c,
  [77, 50],
  s,
  [2, 59]
]),
  state: u([
  1,
  2,
  4,
  s,
  [8, 8, 1],
  20,
  33,
  58,
  s,
  [44, 7, 1],
  s,
  [34, 7, 1],
  42,
  43,
  55,
  59,
  60,
  20,
  65,
  67,
  59,
  60,
  69,
  71,
  73,
  72,
  76,
  c,
  [40, 9],
  81,
  83,
  85,
  20,
  88,
  20,
  89,
  20,
  90,
  20,
  c,
  [49, 8],
  113,
  c,
  [44, 7],
  114,
  58,
  67,
  117,
  116,
  c,
  [9, 3],
  81,
  c,
  [8, 3],
  119,
  c,
  [8, 3],
  83,
  c,
  [8, 3],
  120,
  c,
  [8, 3],
  123,
  c,
  [90, 21],
  126,
  128,
  127,
  128,
  129,
  114,
  137,
  136,
  c,
  [97, 3],
  71,
  73,
  135,
  72,
  81,
  83,
  c,
  [38, 8],
  139,
  c,
  [38, 12],
  c,
  [21, 8],
  140,
  c,
  [21, 20],
  141,
  c,
  [20, 19],
  142,
  c,
  [20, 19],
  143,
  c,
  [20, 19],
  144,
  c,
  [20, 19],
  145,
  c,
  [20, 19],
  146,
  c,
  [18, 17],
  147,
  c,
  [18, 17],
  148,
  c,
  [18, 17],
  150,
  149,
  c,
  [19, 18],
  151,
  c,
  [19, 18],
  152,
  c,
  [19, 18],
  153,
  c,
  [19, 18],
  154,
  c,
  [19, 17],
  155,
  c,
  [17, 16],
  156,
  c,
  [17, 16],
  157,
  c,
  [17, 16],
  158,
  c,
  [16, 7],
  159,
  160,
  166,
  58,
  167,
  c,
  [400, 17],
  164,
  c,
  [389, 4],
  72,
  165,
  20,
  c,
  [404, 4],
  173,
  c,
  [10, 3],
  128,
  182,
  128,
  183,
  128,
  184,
  128,
  185,
  c,
  [415, 7],
  186,
  72,
  187,
  160,
  188,
  c,
  [454, 21],
  c,
  [77, 20],
  189,
  c,
  [77, 7],
  c,
  [28, 20],
  c,
  [27, 5],
  190,
  20
]),
  mode: u([
  s,
  [1, 38],
  2,
  2,
  c,
  [26, 30],
  s,
  [2, 18],
  c,
  [30, 8],
  s,
  [2, 56],
  c,
  [62, 62],
  c,
  [86, 28],
  c,
  [186, 10],
  c,
  [83, 71],
  c,
  [6, 5],
  c,
  [179, 10],
  1,
  c,
  [13, 5],
  c,
  [28, 6],
  c,
  [38, 10],
  c,
  [12, 8],
  c,
  [35, 3],
  c,
  [37, 6],
  c,
  [30, 12],
  c,
  [45, 15],
  c,
  [27, 15],
  c,
  [171, 15],
  c,
  [14, 15],
  c,
  [402, 19],
  c,
  [309, 83],
  s,
  [2, 137],
  c,
  [138, 53],
  c,
  [733, 32],
  c,
  [90, 26],
  c,
  [47, 26],
  c,
  [187, 80],
  c,
  [536, 4],
  c,
  [588, 7],
  c,
  [854, 5],
  c,
  [206, 35],
  s,
  [2, 253],
  c,
  [257, 10],
  s,
  [1, 324],
  c,
  [1383, 90],
  c,
  [683, 169],
  c,
  [169, 7],
  c,
  [902, 4],
  c,
  [191, 18],
  c,
  [194, 35],
  c,
  [1811, 12],
  c,
  [1271, 83],
  c,
  [84, 61],
  c,
  [1688, 15],
  c,
  [1179, 30],
  c,
  [13, 26],
  c,
  [1245, 50],
  c,
  [23, 46],
  c,
  [1772, 17],
  c,
  [61, 27],
  c,
  [272, 45],
  c,
  [1403, 31],
  c,
  [1097, 8],
  c,
  [1440, 33],
  c,
  [35, 21],
  c,
  [861, 34],
  c,
  [596, 18],
  c,
  [585, 31],
  c,
  [50, 47],
  c,
  [55, 9],
  s,
  [2, 59]
]),
  goto: u([
  17,
  19,
  18,
  3,
  5,
  6,
  7,
  16,
  26,
  27,
  28,
  22,
  29,
  30,
  21,
  23,
  24,
  25,
  31,
  32,
  51,
  54,
  57,
  53,
  52,
  64,
  41,
  56,
  62,
  63,
  61,
  c,
  [20, 7],
  4,
  4,
  66,
  68,
  64,
  c,
  [15, 3],
  25,
  70,
  75,
  74,
  c,
  [50, 3],
  c,
  [46, 11],
  10,
  10,
  77,
  78,
  80,
  79,
  11,
  11,
  12,
  12,
  13,
  13,
  14,
  14,
  15,
  15,
  16,
  16,
  17,
  17,
  18,
  18,
  19,
  19,
  29,
  30,
  82,
  29,
  30,
  84,
  s,
  [115, 31],
  s,
  [118, 27],
  87,
  86,
  29,
  30,
  s,
  [121, 27],
  s,
  [122, 27],
  s,
  [123, 28],
  c,
  [86, 4],
  c,
  [4, 8],
  s,
  [116, 31],
  s,
  [117, 31],
  1,
  2,
  3,
  3,
  s,
  [20, 5],
  91,
  92,
  s,
  [23, 4],
  96,
  s,
  [23, 3],
  93,
  94,
  95,
  97,
  s,
  [36, 3],
  99,
  36,
  100,
  s,
  [36, 8],
  98,
  s,
  [36, 5],
  s,
  [34, 4],
  104,
  34,
  103,
  s,
  [34, 6],
  101,
  102,
  34,
  105,
  s,
  [39, 3],
  106,
  s,
  [39, 3],
  107,
  s,
  [39, 14],
  108,
  s,
  [43, 11],
  111,
  s,
  [43, 12],
  109,
  110,
  s,
  [49, 13],
  112,
  s,
  [49, 13],
  c,
  [428, 18],
  s,
  [50, 27],
  s,
  [51, 27],
  s,
  [52, 27],
  c,
  [481, 4],
  s,
  [53, 27],
  s,
  [54, 27],
  s,
  [55, 27],
  s,
  [56, 27],
  s,
  [57, 27],
  58,
  58,
  115,
  s,
  [58, 25],
  s,
  [59, 27],
  118,
  57,
  64,
  c,
  [289, 4],
  c,
  [660, 3],
  25,
  c,
  [11, 9],
  84,
  c,
  [11, 8],
  25,
  s,
  [65, 7],
  121,
  s,
  [65, 20],
  122,
  c,
  [352, 8],
  124,
  125,
  c,
  [352, 8],
  s,
  [69, 28],
  s,
  [76, 29],
  61,
  s,
  [88, 29],
  115,
  85,
  115,
  85,
  130,
  131,
  5,
  5,
  6,
  6,
  115,
  132,
  133,
  7,
  7,
  134,
  8,
  8,
  s,
  [91, 6],
  s,
  [97, 6],
  s,
  [98, 6],
  s,
  [99, 6],
  138,
  68,
  64,
  75,
  c,
  [184, 3],
  74,
  25,
  9,
  9,
  s,
  [108, 27],
  s,
  [109, 27],
  s,
  [112, 27],
  s,
  [110, 27],
  s,
  [113, 31],
  s,
  [119, 27],
  s,
  [114, 31],
  s,
  [120, 27],
  s,
  [111, 27],
  29,
  30,
  29,
  30,
  105,
  105,
  106,
  106,
  107,
  107,
  c,
  [771, 18],
  c,
  [18, 306],
  s,
  [46, 26],
  s,
  [47, 26],
  s,
  [48, 26],
  c,
  [96, 18],
  s,
  [45, 26],
  78,
  87,
  s,
  [60, 27],
  s,
  [63, 27],
  s,
  [64, 27],
  s,
  [61, 27],
  s,
  [62, 27],
  163,
  161,
  162,
  c,
  [184, 3],
  102,
  53,
  102,
  52,
  64,
  75,
  c,
  [187, 5],
  74,
  c,
  [188, 7],
  168,
  115,
  169,
  85,
  115,
  170,
  85,
  s,
  [77, 29],
  79,
  86,
  80,
  171,
  172,
  169,
  170,
  174,
  75,
  74,
  176,
  175,
  94,
  94,
  134,
  95,
  95,
  96,
  96,
  s,
  [21, 7],
  s,
  [22, 7],
  s,
  [24, 12],
  s,
  [25, 12],
  s,
  [27, 12],
  s,
  [32, 12],
  s,
  [33, 12],
  s,
  [26, 3],
  99,
  26,
  100,
  s,
  [26, 8],
  s,
  [37, 20],
  s,
  [38, 20],
  s,
  [28, 12],
  105,
  c,
  [1688, 14],
  s,
  [36, 5],
  s,
  [29, 12],
  105,
  s,
  [30, 12],
  105,
  s,
  [31, 12],
  105,
  s,
  [35, 17],
  s,
  [40, 22],
  108,
  s,
  [41, 22],
  108,
  s,
  [42, 22],
  108,
  s,
  [44, 24],
  109,
  110,
  s,
  [66, 27],
  s,
  [70, 7],
  177,
  s,
  [70, 5],
  178,
  s,
  [70, 15],
  s,
  [72, 29],
  179,
  s,
  [75, 29],
  180,
  181,
  103,
  103,
  100,
  100,
  101,
  101,
  134,
  s,
  [68, 28],
  c,
  [1440, 4],
  c,
  [4, 4],
  s,
  [89, 6],
  s,
  [90, 6],
  s,
  [92, 6],
  c,
  [1424, 9],
  c,
  [578, 6],
  c,
  [876, 18],
  c,
  [596, 19],
  s,
  [67, 28],
  c,
  [50, 22],
  s,
  [81, 4, 1],
  93,
  93,
  s,
  [71, 27],
  191,
  192,
  181,
  104,
  104,
  s,
  [74, 29],
  s,
  [73, 29]
])
}),
defaultActions: bda({
  idx: u([
  31,
  32,
  114,
  115,
  127,
  128,
  129,
  s,
  [182, 4, 1]
]),
  pop: u([
  s,
  [2, 11]
]),
  rule: u([
  1,
  2,
  78,
  87,
  79,
  86,
  s,
  [80, 5, 1]
])
}),
parseError: function parseError(str, hash) {
    if (hash.recoverable) {
        this.trace(str);
    } else {
        throw new this.JisonParserError(str, hash);
    }
},
quoteName: function quoteName(id_str) {
    return '"' + id_str + '"';
},
describeSymbol: function describeSymbol(symbol) {
    if (symbol !== this.EOF && this.terminal_descriptions_ && this.terminal_descriptions_[symbol]) {
        return this.terminal_descriptions_[symbol];
    } 
    else if (symbol === this.EOF) {
        return 'end of input';
    }
    else if (this.terminals_[symbol]) {
        return this.quoteName(this.terminals_[symbol]);
    }
    return null;
},
parse: function parse(input) {
    var self = this,
        stack = [0],        // state stack: stores pairs of state (odd indexes) and token (even indexes)

        vstack = [null],    // semantic value stack
        lstack = [],        // location stack
        table = this.table;
    var recovering = 0;     // (only used when the grammar contains error recovery rules)
    var TERROR = this.TERROR,
        EOF = this.EOF;

    var args = stack.slice.call(arguments, 1);

    //this.reductionCount = this.shiftCount = 0;

    var lexer;
    if (this.__lexer__) {
        lexer = this.__lexer__;
    } else {
        lexer = this.__lexer__ = Object.create(this.lexer);
    }

    var sharedState = {
      yy: {}
    };
    // copy state
    for (var k in this.yy) {
      if (Object.prototype.hasOwnProperty.call(this.yy, k)) {
        sharedState.yy[k] = this.yy[k];
      }
    }

    sharedState.yy.lexer = lexer;
    sharedState.yy.parser = this;






    lexer.setInput(input, sharedState.yy);

    if (typeof lexer.yylloc === 'undefined') {
        lexer.yylloc = {};
    }
    var yyloc = lexer.yylloc;
    lstack.push(yyloc);
    
    if (typeof lexer.yytext === 'undefined') {
        lexer.yytext = '';
    }
    var yytext = lexer.yytext;
    if (typeof lexer.yylineno === 'undefined') {
        lexer.yylineno = 0;
    }




    var ranges = lexer.options && lexer.options.ranges;

    // Does the shared state override the default `parseError` that already comes with this instance?
    if (typeof sharedState.yy.parseError === 'function') {
        this.parseError = sharedState.yy.parseError;
    }
    // Does the shared state override the default `quoteName` that already comes with this instance?
    if (typeof sharedState.yy.quoteName === 'function') {
        this.quoteName = sharedState.yy.quoteName;
    }

    function popStack(n) {

        if (!n) return;
        stack.length = stack.length - 2 * n;
        vstack.length = vstack.length - n;
        lstack.length = lstack.length - n;
    }


    function lex() {
        var token;
        token = lexer.lex() || EOF;
        // if token isn't its numeric value, convert
        if (typeof token !== 'number') {
            token = self.symbols_[token] || token;
        }
        return token;
    }


    var symbol = null;
    var preErrorSymbol = null;
    var state, action, r;
    var yyval = {};
    var p, len, this_production;
    var lstack_begin, lstack_end;
    var newState;
    var expected = [];
    var retval = false;

    if (this.pre_parse) {
        this.pre_parse.apply(this, [sharedState.yy].concat(args));
    }
    if (sharedState.yy.pre_parse) {
        sharedState.yy.pre_parse.apply(this, [sharedState.yy].concat(args));
    }


    // Return the rule stack depth where the nearest error rule can be found.
    // Return FALSE when no error recovery rule was found.
    function locateNearestErrorRecoveryRule(state) {
        var stack_probe = stack.length - 1;
        var depth = 0;

        // try to recover from error
        for (;;) {
            // check for error recovery rule in this state
            var action = table[state][TERROR];
            if (action && action.length && action[0]) {
                return depth;
            }
            if (state === 0 /* $accept rule */ || stack_probe < 2) {
                return false; // No suitable error recovery rule available.
            }
            stack_probe -= 2; // popStack(1): [symbol, action]
            state = stack[stack_probe];
            ++depth;
        }
    }


    // Produce a (more or less) human-readable list of expected tokens at the point of failure.
    // 
    // The produced list may contain token or token set descriptions instead of the tokens
    // themselves to help turning this output into something that easier to read by humans.
    // 
    // The returned list (array) will not contain any duplicate entries.
    function collect_expected_token_set(state) {
        var tokenset = [];
        var check = {};
        // Has this (error?) state been outfitted with a custom expectations description text for human consumption?
        // If so, use that one instead of the less palatable token set.
        if (self.state_descriptions_ && self.state_descriptions_[p]) {
            return [
                self.state_descriptions_[p]
            ];
        }
        for (var p in table[state]) {
            if (p !== TERROR) {
                var d = self.describeSymbol(p);
                if (d && !check[d]) {
                    tokenset.push(d);
                    check[d] = true;        // Mark this token description as already mentioned to prevent outputting duplicate entries.
                }
            }
        }
        return tokenset;
    }

    try {
        for (;;) {
            // retrieve state number from top of stack
            state = stack[stack.length - 1];

            // use default actions if available
            if (this.defaultActions[state]) {
                action = this.defaultActions[state];
            } else {
                // The single `==` condition below covers both these `===` comparisons in a single
                // operation:
                // 
                //     if (symbol === null || typeof symbol === 'undefined') ...
                if (symbol == null) {
                    symbol = lex();
                }
                // read action for current state and first input
                action = table[state] && table[state][symbol];
            }




            // handle parse error
            if (!action || !action.length || !action[0]) {
                var error_rule_depth = 0;
                var errStr = null;

                if (!recovering) {
                    // first see if there's any chance at hitting an error recovery rule:
                    error_rule_depth = locateNearestErrorRecoveryRule(state);

                    // Report error
                    expected = collect_expected_token_set(state);
                    if (lexer.showPosition) {
                        errStr = 'Parse error on line ' + (lexer.yylineno + 1) + ':\n' + lexer.showPosition() + '\n';
                    } else {
                        errStr = 'Parse error on line ' + (lexer.yylineno + 1) + ': ';
                    }
                    if (expected.length) {
                        errStr += 'Expecting ' + expected.join(', ') + ', got unexpected ' + (this.describeSymbol(symbol) || symbol);
                    } else {
                        errStr += 'Unexpected ' + (this.describeSymbol(symbol) || symbol);
                    }
                    r = this.parseError(errStr, p = {
                        text: lexer.match,
                        value: lexer.yytext,
                        token: this.describeSymbol(symbol) || symbol,
                        token_id: symbol,
                        line: lexer.yylineno,
                        loc: lexer.yylloc,
                        expected: expected,
                        recoverable: (error_rule_depth !== false),
                        state_stack: stack,
                        value_stack: vstack,
                        location_stack: lstack,
                        lexer: lexer
                    });

                    if (!p.recoverable) {
                        retval = r;
                        break;
                    }
                } else if (preErrorSymbol !== EOF) {
                    error_rule_depth = locateNearestErrorRecoveryRule(state);
                }



                // just recovered from another error
                if (recovering === 3) {
                    if (symbol === EOF || preErrorSymbol === EOF) {
                        retval = this.parseError(errStr || 'Parsing halted while starting to recover from another error.', {
                            text: lexer.match,
                            value: lexer.yytext,
                            token: this.describeSymbol(symbol) || symbol,
                            token_id: symbol,
                            line: lexer.yylineno,
                            loc: lexer.yylloc,
                            expected: expected,
                            recoverable: false,
                            state_stack: stack,
                            value_stack: vstack,
                            location_stack: lstack,
                            lexer: lexer
                        });
                        break;
                    }

                    // discard current lookahead and grab another

                    yytext = lexer.yytext;

                    yyloc = lexer.yylloc;
                    symbol = lex();


                }

                // try to recover from error
                if (error_rule_depth === false) {
                    retval = this.parseError(errStr || 'Parsing halted. No suitable error recovery rule available.', {
                        text: lexer.match,
                        value: lexer.yytext,
                        token: this.describeSymbol(symbol) || symbol,
                        token_id: symbol,
                        line: lexer.yylineno,
                        loc: lexer.yylloc,
                        expected: expected,
                        recoverable: false,
                        state_stack: stack,
                        value_stack: vstack,
                        location_stack: lstack,
                        lexer: lexer
                    });
                    break;
                }
                popStack(error_rule_depth);

                preErrorSymbol = (symbol === TERROR ? null : symbol); // save the lookahead token
                symbol = TERROR;            // insert generic error symbol as new lookahead
                recovering = 3;             // allow 3 real symbols to be shifted before reporting a new error



                continue;
            }



            switch (action[0]) {
            // catch misc. parse failures:
            default:
                // this shouldn't happen, unless resolve defaults are off
                if (action[0] instanceof Array) {
                    retval = this.parseError('Parse Error: multiple actions possible at state: ' + state + ', token: ' + symbol, {
                        text: lexer.match,
                        value: lexer.yytext,
                        token: this.describeSymbol(symbol) || symbol,
                        token_id: symbol,
                        line: lexer.yylineno,
                        loc: lexer.yylloc,
                        expected: expected,
                        recoverable: false,
                        state_stack: stack,
                        value_stack: vstack,
                        location_stack: lstack,
                        lexer: lexer
                    });
                    break;
                }
                // Another case of better safe than sorry: in case state transitions come out of another error recovery process
                // or a buggy LUT (LookUp Table):
                retval = this.parseError('Parsing halted. No viable error recovery approach available due to internal system failure.', {
                    text: lexer.match,
                    value: lexer.yytext,
                    token: this.describeSymbol(symbol) || symbol,
                    token_id: symbol,
                    line: lexer.yylineno,
                    loc: lexer.yylloc,
                    expected: expected,
                    recoverable: false,
                    state_stack: stack,
                    value_stack: vstack,
                    location_stack: lstack,
                    lexer: lexer
                });
                break;

            // shift:
            case 1: 
                //this.shiftCount++;
                stack.push(symbol);
                vstack.push(lexer.yytext);
                lstack.push(lexer.yylloc);
                stack.push(action[1]); // push state
                symbol = null;
                if (!preErrorSymbol) { // normal execution / no error
                    // Pick up the lexer details for the current symbol as that one is not 'look-ahead' any more:

                    yytext = lexer.yytext;

                    yyloc = lexer.yylloc;

                    if (recovering > 0) {
                        recovering--;

                    }
                } else {
                    // error just occurred, resume old lookahead f/ before error
                    symbol = preErrorSymbol;
                    preErrorSymbol = null;

                }
    
                continue;

            // reduce:
            case 2:
                //this.reductionCount++;
                newState = action[1];
                this_production = this.productions_[newState - 1];  // `this.productions_[]` is zero-based indexed while states start from 1 upwards... 
                len = this_production[1];
                lstack_end = lstack.length;
                lstack_begin = lstack_end - (len || 1);
                lstack_end--;



                // perform semantic action
                yyval.$ = vstack[vstack.length - len]; // default to $$ = $1
                // default location, uses first token for firsts, last for lasts
                yyval._$ = {
                    first_line: lstack[lstack_begin].first_line,
                    last_line: lstack[lstack_end].last_line,
                    first_column: lstack[lstack_begin].first_column,
                    last_column: lstack[lstack_end].last_column
                };
                if (ranges) {
                  yyval._$.range = [lstack[lstack_begin].range[0], lstack[lstack_end].range[1]];
                }

                r = this.performAction.apply(yyval, [yytext, sharedState.yy, newState, vstack, lstack].concat(args));

                if (typeof r !== 'undefined') {
                    retval = r;
                    break;
                }

                // pop off stack
                popStack(len);

                stack.push(this_production[0]);    // push nonterminal (reduce)
                vstack.push(yyval.$);
                lstack.push(yyval._$);
                // goto new state = table[STATE][NONTERMINAL]
                newState = table[stack[stack.length - 2]][stack[stack.length - 1]];
                stack.push(newState);

                continue;

            // accept:
            case 3:
                retval = true;
                // Return the `$accept` rule's `$$` result, if available.
                // 
                // Also note that JISON always adds this top-most `$accept` rule (with implicit, 
                // default, action):
                //   
                //     $accept: <startSymbol> $end
                //                  %{ $$ = $1; @$ = @1; %}
                //     
                // which, combined with the parse kernel's `$accept` state behaviour coded below, 
                // will produce the `$$` value output of the <startSymbol> rule as the parse result, 
                // IFF that result is *not* `undefined`. (See also the parser kernel code.)
                // 
                // In code:
                // 
                //                  %{
                //                      @$ = @1;            // if location tracking support is included
                //                      if (typeof $1 !== 'undefined')
                //                          return $1;
                //                      else
                //                          return true;           // the default parse result if the rule actions don't produce anything
                //                  %}
                if (typeof yyval.$ !== 'undefined') {
                    retval = yyval.$;
                }
                break;
            }

            // break out of loop: we accept or fail with error
            break;
        }
    } catch (ex) {
        // report exceptions through the parseError callback too:
        retval = this.parseError('Parsing aborted due to exception.', {
            exception: ex,
            text: lexer.match,
            value: lexer.yytext,
            token: this.describeSymbol(symbol) || symbol,
            token_id: symbol,
            line: lexer.yylineno,
            loc: lexer.yylloc,
            // expected: expected,
            recoverable: false,
            state_stack: stack,
            value_stack: vstack,
            location_stack: lstack,
            lexer: lexer
        });
    } finally {
        var rv;

        if (sharedState.yy.post_parse) {
            rv = sharedState.yy.post_parse.apply(this, [sharedState.yy, retval].concat(args));
            if (typeof rv !== 'undefined') retval = rv;
        }
        if (this.post_parse) {
            rv = this.post_parse.apply(this, [sharedState.yy, retval].concat(args));
            if (typeof rv !== 'undefined') retval = rv;
        }
    }

    return retval;
}
};

    /*
     * This chunk is included in the parser code, before the lexer definition section and after the parser has been defined.
     *
     * WARNING:
     *
     * Meanwhile, keep in mind that all the parser actions, which will execute inside the `parser.performAction()` function,
     * will have a `this` pointing to `$$`.
     *
     * If you want to access the lexer and/or parser, these are accessible inside the parser rule action code via
     * the `yy.lexer` and `yy.parser` dereferences respectively.
     */

    //console.log("parser object definition: ", this);











/*
 * This chunk is included in the parser object code,
 * following the 'init' code block that may be set in `%{ ... %}` at the top of this
 * grammar definition file.
 */



parser.createRangeFromRange = function (rangeref) {
    return {
        rangeRef: [rangeLabelWithDollarToRowColWorkbook(rangeref)],
        locInfo: null,
        consumeCount: 0
    };
};

parser.createRangeFromCell = function (cellref) {
    var coord = cellLabelWithDollarToRowColWorkbook(cellref);
    assert(coord);
    return {
        rangeRef: [{
            row: coord.row,
            row2: coord.row,
            col: coord.col,
            col2: coord.col,
            workbookIndex: coord.workbookIndex
        }],
        locInfo: null,
        consumeCount: 0
    };
};

parser.updateRangeLocationInfo = function (range, locInfo, consumeCount) {
    if (!range.locInfo) {
        range.locInfo = locInfo;
        assert(range.consumeCount === 0);
    } else {
        if (range.locInfo.last_line < locInfo.last_line || (range.locInfo.last_line === locInfo.last_line && range.locInfo.last_column < locInfo.last_column)) {
            range.locInfo.last_line = locInfo.last_line;
            range.locInfo.last_column = locInfo.last_column;
            if (locInfo.range) {
                assert(range.locInfo.range);
                assert(range.locInfo.range[1] <= locInfo.range[1]);
                assert(range.locInfo.range[1] <= locInfo.range[0]);
                range.locInfo.range[1] = locInfo.range[1];
            }
        }
        if (range.locInfo.first_line > locInfo.first_line || (range.locInfo.first_line === locInfo.first_line && range.locInfo.first_column > locInfo.first_column)) {
            range.locInfo.first_line = locInfo.first_line;
            range.locInfo.first_column = locInfo.first_column;
            if (locInfo.range) {
                assert(range.locInfo.range);
                assert(range.locInfo.range[0] <= locInfo.range[0]);
                assert(range.locInfo.range[1] <= locInfo.range[0]);
                range.locInfo.range[0] = locInfo.range[0];
            }
        }
    }
    range.consumeCount += consumeCount;
};

parser.mergeRanges = function (range1, range2) {
    assert(range1);
    assert(range2);
    range1.rangeRef = range1.rangeRef.concat(range2.rangeRef);
    this.updateRangeLocationInfo(range1, range2.locInfo, range2.consumeCount);
    return range1;
};

//e.g., gets {B4:A2,C7} and returns the values of [A2,B2,A3,B3,A4,B4,C7]
//e.g., Revenues[2011]:Revenues[2014], transforms into an array Cell IDs (e.g., [A2,B2,C2,D2]) and returns the values of the cells in the array
//
//Note: user can type B4:A2
parser.getArrayValueOfCellRangeSpec = function (rangeSpec) {
    // In order to prevent double references in the range spec to be executed twice or more, we first collect
    // the set of referenced cells:
    var collection = new Uint8ClampedArray(MAX_GRID_ROW * MAX_GRID_COL);
    var rangesize = 0;
    for (var k = 0, len = rangeSpec.length; k < len; k++) {
        var spec = rangeSpec[k];
        rangesize += (spec.row2 - spec.row + 1) * (spec.col2 + spec.col + 1);
    }
    var values = new Array(rangesize);
    var valindex = 0;
    for (var k = 0, len = rangeSpec.length; k < len; k++) {
        var spec = rangeSpec[k];
        //create the array of cells
        for (var i = spec.row; i <= spec.row2; i++) {
            var rowstep = i * MAX_GRID_COL;
            for (var j = spec.col; j <= spec.col2; j++) {
                var cellRef = j + rowstep;
                if (!collection[cellRef]) {
                    collection[cellRef] = 1;
                    spec.workbookIndex = spec.workbookIndex || getImplicitWBIdx();
                    assert(spec.workbookIndex);
                    values[valindex++] = getCellValueByRowColWS(i, j, spec.workbookIndex);
                }
            }
        }
    }
    // and redimension the array once so that the receiver gets a nice, clean, array of cell values.
    values.length = valindex;
    return values;
};






/*
 * Return TRUE if all AST nodes in the arglist collection (an array) are constants.
 *
 * Otherwise return FALSE.
 */
parser.isEntireArgListConstant = function (arglist) {
    var i,
        l = arglist.length;
    for (i = 0; i < l; l++) {
        if (!arglist[i].constant) {
            return false;
        }
    }
    return true;
};


/*
 * Return the UNIT of the arglist collective: when all have the same UNIT, it is that.
 *
 * Otherwise it is `FU_ANY` as we cannot say how these AST nodes combine (`SUM`/`AVG`/`MULTIPLY`/...).
 */
parser.determineArgListUnit = function (arglist) {
    var i, u, l = arglist.length;
    if (!l) {
        return FU_ANY;
    }
    u = arglist[0].unit;
    for (i = 1; i < l; l++) {
        if (arglist[i].unit != u) {
            return FU_ANY;
        }
    }
    return u;
};


/*
 * Decode cell references such as `A5` when these are entered in input fields, etc.
 *
 * This performs a regular parse and then makes sure that the parsed 'formula' is actually
 * a single, valid, cell reference and returns the corresponding AST object.
 *
 * When the entered content is NOT a valid cell reference, an exception (error message) is thrown.
 */
parser.parseCellReference = function (input) {
    this.parse_mode = FPM_CELLREF;
    var ast;

    try {
        ast = this.parse(input);
    }
    finally {
        this.parse_mode = FPM_FORMULA;
    }

    if (typeof ast !== "undefined" && ast.opcode == FKW_CELLREF) {
        return ast;
    }

    throw new Error(input + " is not a valid cell reference");
};


/*
 * Decode cell range references such as `A5:C7` when these are entered in input fields, etc.
 *
 * This performs a regular parse and then makes sure that the parsed 'formula' is actually
 * a single, valid, range reference and returns the corresponding AST object.
 *
 * When the entered content is NOT a valid range reference, an exception (error message) is thrown.
 */
parser.parseRangeReference = function (input) {
    this.parse_mode = FPM_RANGEREF;
    var ast;

    try {
        ast = this.parse(input);
    }
    finally {
        this.parse_mode = FPM_FORMULA;
    }

    if (typeof ast !== "undefined" && ast.opcode == FKW_RANGEREF) {
        return ast;
    }

    throw new Error(input + " is not a valid range reference");
};


/*
 * Decode the input expression and 'fold' it into a single value, i.e. calculate its present value.
 *
 * This performs a regular parse and then makes sure that the parsed 'formula' is 'folded'
 * into a single (numeric / string / boolean) value and returns the corresponding AST object.
 *
 * When the entered content is NOT a valid immediate value expression, an exception (error message) is thrown.
 */
parser.parseValue = function (input) {
    this.parse_mode = FPM_IMMEDIATE_VALUE;
    var ast;

    try {
        ast = this.parse(input);
    }
    finally {
        this.parse_mode = FPM_FORMULA;
    }

    if (typeof ast !== "undefined" && ast.opcode == FKW_VALUE) {
        return ast;
    }

    throw new Error(input + " is not a valid value expression");
};


/*
 * Remove duplicated quotes (of the form `quote_str + quote_str`, e.g. `""`) from the input string.
 */
parser.dedupQuotedString = function (str, quote_str) {
    return str.replace(quote_str + quote_str, quote_str);
};


// Would it be a viable basic column identifier?
parser.isValidColumnID = function (s) {
    var col;
    var match;

    if (s.length <= MAX_GRID_COL_ID_LENGTH) {
        s = s.toUpperCase();
        match = s.match(/^[A-Z]+$/);
        if (match) {
            // check if this is a legal column id:
            col = colLetterToNumber(s);
            assert(col === false || assertGraphCol(col));
            if (col) {
                return col;
            }
        }
    }
    return false;
};


// Would it be a viable basic row identifier?
parser.isValidRowID = function (s) {
    var row;
    var match;

    if (s.length <= MAX_GRID_ROW_ID_LENGTH) {
        s = s.toUpperCase();
        match = s.match(/^[0-9]+$/);
        if (match) {
            // check if this is a legal column id:
            row = Number(s);
            if (row >= 1 && row <= MAX_GRID_ROW) {
                return row;
            }
        }
    }
    return false;
};




// Would it be a viable cell reference?
parser.isValidCellRef = function (s) {
    var rv = cellLabelWithDollarToRowColWorkbook(s, {
        fireEventOnError: false
    });
    return rv;
};




// Would it be a viable cell range reference?
parser.isValidCellRange = function (s) {
    var rv = rangeLabelWithDollarToRowColWorkbook(s, {
        fireEventOnError: false
    });
    return rv;
};



/*
 * Return the definition structure for the given symbol name, or FALSE when the symbol is unknown.
 *
 * The definition structure contains these elements:
 *
 * - token
 * - defined_value
 */

parser.getSymbol4Function = function (name) {
    name = name.toUpperCase();
    assert(this._symbol2token_lookup_table);
    assert(this._symbol2token_lookup_table.functions);
    var rv = this._symbol2token_lookup_table.functions[name];
    if (rv && rv.quality < vUserPreferences.quality) {
        return false;
    }
    return rv || false;
};

parser.getSymbol4DefinedConstant = function (name, mandatory_category_bits) {
    mandatory_category_bits |= 0;
    name = name.toUpperCase();
    assert(this._symbol2token_lookup_table);
    assert(this._symbol2token_lookup_table.constants);
    var rv = this._symbol2token_lookup_table.constants[name];
    if (rv && rv.quality < vUserPreferences.quality) {
        return false;
    }
    if (rv && (rv.category & mandatory_category_bits) !== mandatory_category_bits) {
        return false;
    }
    return rv || false;
};

parser.getSymbol4Currency = function (name) {
    name = name.toUpperCase();
    assert(this._symbol2token_lookup_table);
    assert(this._symbol2token_lookup_table.currencies);
    var rv = this._symbol2token_lookup_table.currencies[name];
    if (rv && rv.quality < vUserPreferences.quality) {
        return false;
    }
    /*
     * output structure:
     *
     * - notation: FKA constant
     * - prefix:   string (optional; required for currencies which are not hard-coded FKA notation constants)
     */
    return rv || false;
};

parser.getJSONfilterSymbol = function (name) {
    name = name.toUpperCase();
    assert(this._symbol2token_lookup_table);
    assert(this._symbol2token_lookup_table.json_filter_functions);
    var rv = this._symbol2token_lookup_table.json_filter_functions[name];
    return rv || false;
};

parser.getSymbol4RowOrColumnName = function (name) {
    var rv = this.getSymbol4RowName(name);
    if (!rv) {
        rv = this.getSymbol4ColumnName(name);
        if (rv) {
            assert(rv.col >= 1);
            assert(rv.provides === NRA_COLUMN);
            return rv;
        }
        return false;
    } else {
        assert(rv.row >= 1);
        assert(rv.provides === NRA_ROW);
        return rv;
    }
};

parser.getSymbol4RowName = function (name) {
    var rv = vGraph.getRowOfLabel(name);
    if (rv) {
        return {
            row: rv,
            provides: NRA_ROW
        };
    }
    return false;
};

parser.getSymbol4ColumnName = function (name) {
    var rv = vGraph.getColOfLabel(name);
    if (rv) {
        return {
            col: rv,
            provides: NRA_COLUMN
        };
    }
    return false;
};

parser.getSymbol4CellRef = function (name) {
    var rv = vGraph.getCellOfLabel(name);
    if (rv) {
        return {
            col: rv.col,
            row: rv.row,
            provides: NRA_COLUMN | NRA_ROW
        };
    }
    return false;
};


/*
 * Initialize the symbol lookup tables.
 */
parser.initSymbolTable = function (custom_symbols) {
    this._symbol2token_lookup_table = {
        functions: {},                  // hash table ~ dictionary
        constants: {},                  // hash table ~ dictionary
        currencies: {},                 // hash table ~ dictionary
        json_filter_functions: {}       // hash table ~ dictionary
    };

    // first set up the default symbols: constants, etc.; once that is done, register the custom symbols:
    this.addSymbols(get_predefined_formula_constants(), FSC_PREDEFINED_CONSTANT);
    this.addSymbols(get_predefined_formula_currencies(), FSC_CURRENCY);
    this.addSymbols(get_predefined_formula_functions(), FSC_FUNCTION);

    return this.addSymbols(custom_symbols);
};


/*
 * Register one or more symbols in the symbol lookup tables:
 */
parser.addSymbols = function (symbols, default_category) {
    var s, category, name, done, node, alts, k;

    for (var i = 0, len = symbols.length; i < len; i++) {
        s = symbols[i];

        // ignore symbols which are not enabled / suitable for the current quality level:
        if (s.quality < vUserPreferences.quality) {
            continue;
        }

        category = s.category || default_category;
        done = 0;
        if (category & FSC_FUNCTION) {
            alts = s.alts || [];
            alts.push(String(s.name).toUpperCase());
            for (k in alts) {
                this._symbol2token_lookup_table.functions[alts[k]] = s;
            }
            ++done;
        }
        if (category & FSC_PREDEFINED_CONSTANT) {
            alts = s.alts || [];
            alts.push(String(s.name).toUpperCase());
            for (k in alts) {
                this._symbol2token_lookup_table.constants[alts[k]] = s;
            }
            ++done;
        }
        if (category & FSC_CURRENCY) {
            alts = s.alts || [];
            alts.push(String(s.name).toUpperCase());
            for (k in alts) {
                this._symbol2token_lookup_table.currencies[alts[k]] = s;
            }
            ++done;
        }
        if (category & FSC_CELL_LABEL) {
            vGraph.setCellLabel(s.col, s.row, s.name);
            ++done;
        }
        if (category & FSC_COLUMN_LABEL) {
            vGraph.setColLabel(s.col, s.name);
            ++done;
        }
        if (category & FSC_ROW_LABEL) {
            vGraph.setRowLabel(s.row, s.name);
            ++done;
        }
        if (category & FSC_JSON_FILTER_FUNCTION) {
            alts = s.alts || [];
            alts.push(String(s.name).toUpperCase());
            for (k in alts) {
                this._symbol2token_lookup_table.json_filter_functions[alts[k]] = s;
            }
            ++done;
        }
        if (category & FSC_CELL_VALUE_PRESET) {
            // WARNING: this category is really here to assist the unit tests; in actual use, this is never expected to be invoked!
            node = vGraph.createBlankNode(s.row, s.col);
            assert(node, "Old vs New: createBlankNode does not always create node anymore when collaborator");

//            node.formula = "" + s.value;
            node.value = s.value;
            vProject.addNode(node, node.value);
            ++done;
        }
        if (!done) {
            //console.log("symbol [" + s.name + "] does not belong in any category: ", i, s, category);
            throw new Error("symbol [" + s.name + "] does not belong in any category");
        }
    }
    return this;
};




/*
 * Store the current comment which has terminated and needs to be stored until the next token is produced by the lexer.
 */
parser.pushComment = function () {
    var lexer = this.lexer;

    // a la pastInput():
    var past = lexer.matched.substr(0, this.matched.length - this.match.length);
    var startloc = lexer.inline_comment_start_yylloc.ranges[1]; // pick the offset beyond the comment-start marker!
    past = past.substr(startloc);
    // strip surrounding whitespace:
    // http://jsperf.com/javascript-trim-string/2
    past = past.trim();

    var node = new Visyond.FormulaParser.inlineComment(FKW_INLINE_COMMENT, lexer.inline_comment_start_yylloc, past);
    this.comments.push(node);
    return this;
};


/*
 * Return the array of comments when there are any, otherwise return FALSE.
 *
 * Also empty the comment store.
 */
parser.popComments = function () {
    var rv = this.comments;
    this.clearComments();
    if (typeof rv !== "undefined" && rv.length > 0) {
        return rv;
    } else {
        return false;
    }
};


/*
 * Clear / (re-)initialize the comments' store.
 */
parser.clearComments = function () {
    this.comments = [];
    return this;
};


/*
 * Return the index to the next available slot in the comment store.
 *
 * Consequently returns 0 when the comment store is empty.
 */
parser.getNextCommentIndex = function () {
    var rv = this.comments;
    if (typeof rv !== "undefined" && rv.length > 0) {
        return rv.length;
    } else {
        return 0;
    }
};


parser.pre_parse = function (yy) {
    //console.log("parser init", this, arguments);

    /*
     * The 'init phase' is always invoked for every parse invocation.
     *
     * At this point in time, nothing has happened yet: no token has
     * been lexed, no real statement has been parsed yet.
     *
     * Incidentally, we also use this moment in time to reset the
     * 'inline comments' monitor: depending on the `options.inline_comments_mode`
     * setting do we allow inline comments
     *
     *  - always,
     *  - only after the "=" starting the formula, or
     *  - never
     *
     * The grammar has been constructed such that this rule can be
     * resolved without any look-ahead, thanks to a 'default action'.
     */
    //yy.lexer.options.backtrack_lexer = true;
    //yy.lexer.options.ranges = true;             // required for the inline comments to work as the start location is tracked via the `yylloc.range[]`
    yy.lexer.options.inline_comment_mode = yy.inline_comment_mode | 0;

    if (yy.lexer.options.inline_comment_mode < 2) {
        yy.lexer.inline_comments_monitor = 0; // for `mode=1` comment support will be enabled as soon as we encounter a `=`
    } else {
        yy.lexer.inline_comments_monitor = yy.lexer.options.inline_comment_mode + 1;
    }

    // and make sure the comments store is prepped:
    yy.parser.clearComments();

    // and init the symbol tables if the caller didn't do so already (we do this in order to prevent undesirable crashes)
    if (typeof yy.parser._symbol2token_lookup_table === "undefined") {
        yy.parser.initSymbolTable([]);
    }

    /*
     * Depending on parser mode we must push a 'magick marker' into the lexer stream
     * which is a hack offering a working alternative to having the parser generator
     * support multiple %start rules.
     */
    yy.lexer.pushState('PARSE_MODE_DETECTION');
    switch (yy.parser.parser_mode) {
    default:
        break;

    case FPM_CELLREF:
        yy.lexer.unput("\u0001");
        break;

    case FPM_RANGEREF:
        yy.lexer.unput("\u0002");
        break;

    case FPM_IMMEDIATE_VALUE:
        yy.lexer.unput("\u0003");
        break;
    }
};







// Return FALSE on success, return object containing both index number of argument which mismatched the spec + minimal error report
//
// break_on_severity_level: when set, it determines whether this validation function will break on the first WARNING (-1/false) or ERROR (+1/true)
parser.passingArgumentSetValidation = function (opcode, args_array, break_on_severity_level) {
    // opcode is a reference to the object

    break_on_severity_level |= 0;
    break_on_severity_level--;          // FALSE --> -1 // TRUE --> 0

    // console.log("opcode.parameter_set_definition from passingArgumentSetValidation: ",opcode.parameter_set_definition);
    // console.log("args_array from passingArgumentSetValidation: ",args_array);

    var arg_def_set = opcode.parameter_set_definition;
    var alen, dlen, ai, di, dt, at, i;
    var basic_type, dotdotdot, coerce;
    var oki;

    alen = args_array.length;
    dlen = arg_def_set.length;

    // example: [FAX_NUMBER | FAX_COERCE | FAX_DOTDOTDOT]

    // check each incoming argument against the function interface specification:
    di = 0;
    for (ai = 0; ai < alen; ai++) {
        if (di >= dlen) {
            // We ran out of argument specs early: apparently we received more function arguments than is legally allowed!
            return {
                severity: 1,         // ERROR > 0
                index: ai,
                spec_index: di,
                spec_bits: null,
                is_user_failure: true,
                message: "Argument #" + (ai + 1) + " is superfluous and ignored by the function"
            };
        }
        dt = arg_def_set[di]; // FAX_... bits defining the expected argument type.
        // extract basic type and option bits:
        basic_type = (dt & FAX_ANY);
        optional = (dt & FAX_OPTIONAL);
        dotdotdot = (dt & FAX_DOTDOTDOT);
        coerce = (dt & FAX_COERCE);

        at = typeof args_array[ai];
        // TODO: fix this code so it works out for COUNTIF() et al: those have FAX_DOTDOTDOT followed by 'trailing' argument(s) in the spec!
        /*
         * Nasty: two ways to invoke COUNTIF() et al as Excel formula expressions:
         *
         * **Edit: NOT TRUE -- > EXCEL DOES NOT ALLOW TO INVOKE THEM LIKE THE BELOW, ONLY RANGE AND CONDITION**
         *
         * =COUNTIF(A1, A2, A3, A4, A5, ">0");
         * -->
         * =COUNTIF(1, 2, 3, 4, 5, ">0");
         * i.e. args_array.length = 6
         *
         * =COUNTIF(A1:A5, ">0");
         * -->
         * =COUNTIF([1, 2, 3, 4, 5], ">0");
         * i.e. args_array.length = 2
         */

        di++;

        if (dotdotdot) {
            // when the spec announces it expects an arbitrary number of arguments like this one,
            // we do NOT increment the spec index as the next argument must be matched against the same
            // spec entry.
            di--;
        }

        if (optional) {
            // argument is allowed to not be present, i.e. may be undefined/null(=empty). E.g. 2nd arg for "IF(cond,,false_value)"
            if (at === 'undefined' || args_array[ai] === null) {
                continue;
            }
        }
        // when the spec announces the argument will be coerced to some type(s), we currently accept ANYTHING!
        if (coerce) {
            continue;
        }
        // when the argument may be anything, we're down with that too!
        if (basic_type === FAX_ANY) {
            continue;
        }

        // basic_type is a bitfield itself, so check argument type against the bits:
        switch (at) {
        case 'undefined':
            // that's unexpected: we only get here when the argument is NOT OPTIONAL.
            // ... and 'undefined' is NOT identical to 'empty' ...
            return {
                severity: 1,         // ERROR > 0
                index: ai,
                spec_index: di,
                spec_bits: dt,
                is_user_failure: false,
                message: "Argument #" + (ai + 1) + " is unexpectedly empty/undefined; was expecting " + parser.describeFAXbits(dt)
            };

        case 'boolean':
            if (!(basic_type & FAX_BOOLEAN)) {
                oki = {
                    severity: -1,         // WARNING < 0
                    index: ai,
                    spec_index: di,
                    spec_bits: dt,
                    is_user_failure: false,
                    message: "Argument #" + (ai + 1) + " is a boolean, which will not be coerced; was expecting " + parser.describeFAXbits(dt)
                };
                if (break_on_severity_level <= oki.severity) return oki;
            }
            continue;

        case 'string':
            if (!(basic_type & FAX_STRING)) {
                // When we don't accept a string input, we may still accept something similar: a DATE
                // (Side note: we 'know' that FAX_COMPLEX_NUMBER = FAX_STRING so we don't go and check for FAX_COMPLEX_NUMBER separately here!)
                if (!(basic_type & FAX_DATE)) {
                    oki = {
                        severity: -1,         // WARNING < 0
                        index: ai,
                        spec_index: di,
                        spec_bits: dt,
                        is_user_failure: false,
                        message: "Argument #" + (ai + 1) + " is a string, which will not be coerced; was expecting " + parser.describeFAXbits(dt)
                    };
                    if (break_on_severity_level <= oki.severity) return oki;
                }
                // When we allow a date, we now assume ANY string will correctly coerce into a valid date.
                // We do know this is a very fast and off-handed (and WRONG) approach, but we want speed over accuracy for now...
            }
            continue;

        case 'number':
            if (!(basic_type & FAX_NUMBER)) {
                // When we don't accept a numeric input, we may still accept something similar: a DATE
                if (!(basic_type & FAX_DATE)) {
                    oki = {
                        severity: -1,         // WARNING < 0
                        index: ai,
                        spec_index: di,
                        spec_bits: dt,
                        is_user_failure: false,
                        message: "Argument #" + (ai + 1) + " is a number, which will not be coerced; was expecting " + parser.describeFAXbits(dt)
                    };
                    if (break_on_severity_level <= oki.severity) return oki;
                }
                // When we allow a date, we now assume ANY number will correctly coerce into a valid date.
                // We do know this is a very fast and off-handed (and WRONG) approach, but we want speed over accuracy for now...
            }
            continue;

        default:
            // If the given argument is an array or NULL we arrive here.
            // NULL **MAY** be a result from an earlier parse error (#VALUE or some such, maybe?)
            // so we need to differentiate between NULL and 'the rest of 'em':
            if (args_array[ai] === null) {
                if (!(basic_type & FAX_VOID)) {
                    // This is pretty darn illegal as it's the same to us as 'undefined':
                    return {
                        severity: 1,         // ERROR > 0
                        index: ai,
                        spec_index: di,
                        spec_bits: dt,
                    is_user_failure: false,
                        message: "Argument #" + (ai + 1) + " is null/empty/undefined; was expecting " + parser.describeFAXbits(dt)
                    };
                } else {
                    // This function accepts a `(void)` parameter, i.e. this function accepts *zero* arguments:
                    assert(ai === 0);
                    assert(alen === 1);
                    continue;
                }
            }
            // 'the rest of 'em': RANGEREF, CELLREF, etc. will only show up as-is in the AST grammar;
            // here they have been 'expanded' in value arrays already.
            // For simplicity, we simply accept any of those when the function argument is an array/object/non-basic-JS-type:
            if (!(basic_type & (FAX_DATASET | FAX_COLREF | FAX_ROWREF | FAX_CELLREF | FAX_RANGEREF))) {
                oki = {
                    severity: -1,         // WARNING < 0
                    index: ai,
                    spec_index: di,
                    spec_bits: dt,
                    is_user_failure: false,
                    message: "Argument #" + (ai + 1) + " is of incorrect type; was expecting " + parser.describeFAXbits(dt)
                };
                if (break_on_severity_level <= oki.severity) return oki;
            }
            continue;
        }
    }

    if (di < dlen) {
        // Fewer arguments were passed than strictly required. Or is it? (FAX_OPTIONAL / FAX_DOTDOTDOT)
        //
        // It is only OKAY when
        // - ALL missing arguments are FAX_OPTIONAL
        // - this argument is FAX_DOTDOTDOT **AND** no further 'trailing' arguments are expected (COUNTIF()!!!)

        dt = arg_def_set[di]; // FAX_... bits defining the expected argument type.
        // extract basic type and option bits:
        basic_type = (dt & FAX_ANY);
        optional = (dt & FAX_OPTIONAL);
        dotdotdot = (dt & FAX_DOTDOTDOT);
        coerce = (dt & FAX_COERCE);

        if (optional) {
            // We MAY omit this argument, but then we should also be allowed to omit the subsequent ones,
            // otherwise this FAX_OPTIONAL would've been caught inside the for() loop above!
            for (i = di + 1; i < dlen; i++) {
                if (!(arg_def_set[i] & FAX_OPTIONAL)) {
                    // any NON-optional argument following us means we are at fault already!
                    return {
                        severity: 1,         // ERROR > 0
                        index: ai,
                        spec_index: i,
                        spec_bits: arg_def_set[i],
                        is_user_failure: true,
                        message: "Incorrect number of arguments; you did not specify a required argument"
                    };
                }
            }
            // It turns out this argument and all following it are optional, so we're good to go!
        } else if (dotdotdot) {
            // no more /specified/ arguments after this one allowed, because we don't have any more to offer!
            if (di + 1 < dlen) {
                return {
                    severity: 1,         // ERROR > 0
                    index: ai,
                    spec_index: di,
                    spec_bits: dt,
                    is_user_failure: true,
                    message: "Incorrect number of arguments; you did not specify the trailing arguments"
                };
            }
            // We're the last spec entry, so we're good to go!
        } else {
            // We have checked all given function arguments, yet still have some unmatched argument specs, which are NON-OPTIONAL.
            // This means the user didn't provide all the required arguments!
            return {
                severity: 1,         // ERROR > 0
                index: ai,
                spec_index: di,
                spec_bits: dt,
                is_user_failure: true,
                message: "Incorrect number of arguments; you did not specify one or more required arguments"
            };
        }
    }

    return false;
};


parser.describeFAXbits = function (t) {
    var s, b, v, d, c, o;

    t |= 0;
    b = (t & FAX_ANY);
    v = (t & FAX_VOID);
    o = (t & FAX_OPTIONAL);
    c = (t & FAX_COERCE);
    d = (t & FAX_DOTDOTDOT);

    if (b === FAX_ANY) {
        s = "(anything)";
    } else if (v) {
        s = "(void)";
    } else {
        assert(b != 0);
        s = "(";
        if (b & FAX_NUMBER) {
            s += "number";
        }

        // tricky: we 'know' the FAX_COMPLEX_NUMBER only shows up in the spec when it is FAX_NUMBER | FAX_COMPLEX_NUMBER, i.e. FAX_NUMBER | FAX_STRING:
        if ((FAX_NUMBER | FAX_STRING | FAX_COMPLEX_NUMBER) === (b & (FAX_NUMBER | FAX_STRING | FAX_COMPLEX_NUMBER))) {
            if (s) s += ",";
            s += "complex";
        }

        if (b & FAX_DATE) {
            if (s) s += ",";
            s += "date";
        }
        if (b & FAX_BOOLEAN) {
            if (s) s += ",";
            s += "boolean";
        }
        if (b & FAX_STRING) {
            if (s) s += ",";
            s += "string";
        }
        if (b & FAX_DATASET) {
            if (s) s += ",";
            s += "dataset";
        }
        if (b & FAX_COLREF) {
            if (s) s += ",";
            s += "columnREF";
        }
        if (b & FAX_ROWREF) {
            if (s) s += ",";
            s += "rowREF";
        }
        if (b & FAX_CELLREF) {
            if (s) s += ",";
            s += "cellREF";
        }
        if (b & FAX_RANGEREF) {
            if (s) s += ",";
            s += "rangeREF";
        }

        s += ")";
    }

    if (c) {
        s += "*";
    }

    if (d) {
        s += "...";
    }

    if (o) {
        s = "[" + s + "]";
    }

    return s;
};

/* generated by jison-lex 0.3.4-130 */
var lexer = (function () {
// See also:
// http://stackoverflow.com/questions/1382107/whats-a-good-way-to-extend-error-in-javascript/#35881508
// but we keep the prototype.constructor and prototype.name assignment lines too for compatibility
// with userland code which might access the derived class in a 'classic' way.
function JisonLexerError(msg, hash) {
    Object.defineProperty(this, 'name', {
        enumerable: false,
        writable: false,
        value: 'JisonLexerError'
    });

    if (msg == null) msg = '???';

    Object.defineProperty(this, 'message', {
        enumerable: false,
        writable: true,
        value: msg
    });

    this.hash = hash;

    var stacktrace;
    if (hash && hash.exception instanceof Error) {
        var ex2 = hash.exception;
        this.message = ex2.message || msg;
        stacktrace = ex2.stack;
    }
    if (!stacktrace) {
        if (Error.hasOwnProperty('captureStackTrace')) { // V8
            Error.captureStackTrace(this, this.constructor);
        } else {
            stacktrace = (new Error(msg)).stack;
        }
    }
    if (stacktrace) {
        Object.defineProperty(this, 'stack', {
            enumerable: false,
            writable: false,
            value: stacktrace
        });
    }
}

    if (typeof Object.setPrototypeOf === 'function') {
        Object.setPrototypeOf(JisonLexerError.prototype, Error.prototype);
    } else {
        JisonLexerError.prototype = Object.create(Error.prototype);
    }
    JisonLexerError.prototype.constructor = JisonLexerError;
    JisonLexerError.prototype.name = 'JisonLexerError';


var lexer = {

EOF:1,

ERROR:2,

parseError:function lexer_parseError(str, hash) {
        if (this.yy.parser && typeof this.yy.parser.parseError === 'function') {
            return this.yy.parser.parseError(str, hash) || this.ERROR;
        } else {
            throw new this.JisonLexerError(str);
        }
    },

// resets the lexer, sets new input
setInput:function lexer_setInput(input, yy) {
        this.yy = yy || this.yy || {};
        this._input = input;
        this._more = this._backtrack = this._signaled_error_token = this.done = false;
        this.yylineno = this.yyleng = 0;
        this.yytext = this.matched = this.match = '';
        this.conditionStack = ['INITIAL'];
        this.yylloc = {
            first_line: 1,
            first_column: 0,
            last_line: 1,
            last_column: 0
        };
        if (this.options.ranges) {
            this.yylloc.range = [0, 0];
        }
        this.offset = 0;
        return this;
    },

// consumes and returns one char from the input
input:function lexer_input() {
        if (!this._input) {
            this.done = true;
            return null;
        }
        var ch = this._input[0];
        this.yytext += ch;
        this.yyleng++;
        this.offset++;
        this.match += ch;
        this.matched += ch;
        // Count the linenumber up when we hit the LF (or a stand-alone CR).
        // On CRLF, the linenumber is incremented when you fetch the CR or the CRLF combo
        // and we advance immediately past the LF as well, returning both together as if
        // it was all a single 'character' only.
        var slice_len = 1;
        var lines = false;
        if (ch === '\n') {
            lines = true;
        } else if (ch === '\r') {
            lines = true;
            var ch2 = this._input[1];
            if (ch2 === '\n') {
                slice_len++;
                ch += ch2;
                this.yytext += ch2;
                this.yyleng++;
                this.offset++;
                this.match += ch2;
                this.matched += ch2;
                if (this.options.ranges) {
                    this.yylloc.range[1]++;
                }
            }
        }
        if (lines) {
            this.yylineno++;
            this.yylloc.last_line++;
        } else {
            this.yylloc.last_column++;
        }
        if (this.options.ranges) {
            this.yylloc.range[1]++;
        }

        this._input = this._input.slice(slice_len);
        return ch;
    },

// unshifts one char (or a string) into the input
unput:function lexer_unput(ch) {
        var len = ch.length;
        var lines = ch.split(/(?:\r\n?|\n)/g);

        this._input = ch + this._input;
        this.yytext = this.yytext.substr(0, this.yyleng - len);
        //this.yyleng -= len;
        this.offset -= len;
        var oldLines = this.match.split(/(?:\r\n?|\n)/g);
        this.match = this.match.substr(0, this.match.length - len);
        this.matched = this.matched.substr(0, this.matched.length - len);

        if (lines.length - 1) {
            this.yylineno -= lines.length - 1;
        }

        this.yylloc.last_line = this.yylineno + 1;
        this.yylloc.last_column = (lines ?
                (lines.length === oldLines.length ? this.yylloc.first_column : 0)
                + oldLines[oldLines.length - lines.length].length - lines[0].length :
                this.yylloc.first_column - len);

        if (this.options.ranges) {
            this.yylloc.range[1] = this.yylloc.range[0] + this.yyleng - len;
        }
        this.yyleng = this.yyleng;
        this.done = false;
        return this;
    },

// When called from action, caches matched text and appends it on next action
more:function lexer_more() {
        this._more = true;
        return this;
    },

// When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.
reject:function lexer_reject() {
        if (this.options.backtrack_lexer) {
            this._backtrack = true;
        } else {
            // when the parseError() call returns, we MUST ensure that the error is registered.
            // We accomplish this by signaling an 'error' token to be produced for the current
            // .lex() run.
            this._signaled_error_token = (this.parseError('Lexical error on line ' + (this.yylineno + 1) + ': You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\n' + this.showPosition(), {
                text: this.match,
                token: null,
                line: this.yylineno,
                loc: this.yylloc,
                lexer: this
            }) || this.ERROR);
        }
        return this;
    },

// retain first n characters of the match
less:function lexer_less(n) {
        this.unput(this.match.slice(n));
    },

// return (part of the) already matched input, i.e. for error messages
pastInput:function lexer_pastInput(maxSize) {
        var past = this.matched.substr(0, this.matched.length - this.match.length);
        if (maxSize < 0)
            maxSize = past.length;
        else if (!maxSize)
            maxSize = 20;
        return (past.length > maxSize ? '...' + past.substr(-maxSize) : past);
    },

// return (part of the) upcoming input, i.e. for error messages
upcomingInput:function lexer_upcomingInput(maxSize) {
        var next = this.match;
        if (maxSize < 0)
            maxSize = next.length + this._input.length;
        else if (!maxSize)
            maxSize = 20;
        if (next.length < maxSize) {
            next += this._input.substr(0, maxSize - next.length);
        }
        return (next.length > maxSize ? next.substr(0, maxSize) + '...' : next);
    },

// return a string which displays the character position where the lexing error occurred, i.e. for error messages
showPosition:function lexer_showPosition() {
        var pre = this.pastInput().replace(/\s/g, ' ');
        var c = new Array(pre.length + 1).join('-');
        return pre + this.upcomingInput().replace(/\s/g, ' ') + '\n' + c + '^';
    },

// test the lexed token: return FALSE when not a match, otherwise return token
test_match:function lexer_test_match(match, indexed_rule) {
        var token,
            lines,
            backup;

        if (this.options.backtrack_lexer) {
            // save context
            backup = {
                yylineno: this.yylineno,
                yylloc: {
                    first_line: this.yylloc.first_line,
                    last_line: this.last_line,
                    first_column: this.yylloc.first_column,
                    last_column: this.yylloc.last_column
                },
                yytext: this.yytext,
                match: this.match,
                matches: this.matches,
                matched: this.matched,
                yyleng: this.yyleng,
                offset: this.offset,
                _more: this._more,
                _input: this._input,
                yy: this.yy,
                conditionStack: this.conditionStack.slice(0),
                done: this.done
            };
            if (this.options.ranges) {
                backup.yylloc.range = this.yylloc.range.slice(0);
            }
        }

        lines = match[0].match(/(?:\r\n?|\n).*/g);
        if (lines) {
            this.yylineno += lines.length;
        }
        this.yylloc = {
            first_line: this.yylloc.last_line,
            last_line: this.yylineno + 1,
            first_column: this.yylloc.last_column,
            last_column: lines ?
                         lines[lines.length - 1].length - lines[lines.length - 1].match(/\r?\n?/)[0].length :
                         this.yylloc.last_column + match[0].length
        };
        this.yytext += match[0];
        this.match += match[0];
        this.matches = match;
        this.yyleng = this.yyleng;
        if (this.options.ranges) {
            this.yylloc.range = [this.offset, this.offset + this.yyleng];
        }
        this.offset += this.yyleng;
        this._more = false;
        this._backtrack = false;
        this._input = this._input.slice(match[0].length);
        this.matched += match[0];
        token = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);
        if (this.done && this._input) {
            this.done = false;
        }
        if (token) {
            return token;
        } else if (this._backtrack) {
            // recover context
            for (var k in backup) {
                this[k] = backup[k];
            }
            return false; // rule action called reject() implying the next rule should be tested instead.
        } else if (this._signaled_error_token) {
            // produce one 'error' token as .parseError() in reject() did not guarantee a failure signal by throwing an exception!
            token = this._signaled_error_token;
            this._signaled_error_token = false;
            return token;
        }
        return false;
    },

// return next match in input
next:function lexer_next() {
        function clear() {
            this.yytext = '';
            this.yyleng = 0;
            this.match = '';
            this.matches = false;
            this._more = false;
            this._backtrack = false;
        }

        if (this.done) {
            clear.call(this);
            return this.EOF;
        }
        if (!this._input) {
            this.done = true;
        }

        var token,
            match,
            tempMatch,
            index;
        if (!this._more) {
            clear.call(this);
        }
        var rules = this._currentRules();
        for (var i = 0; i < rules.length; i++) {
            tempMatch = this._input.match(this.rules[rules[i]]);
            if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
                match = tempMatch;
                index = i;
                if (this.options.backtrack_lexer) {
                    token = this.test_match(tempMatch, rules[i]);
                    if (token !== false) {
                        return token;
                    } else if (this._backtrack) {
                        match = false;
                        continue; // rule action called reject() implying a rule MISmatch.
                    } else {
                        // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
                        return false;
                    }
                } else if (!this.options.flex) {
                    break;
                }
            }
        }
        if (match) {
            token = this.test_match(match, rules[index]);
            if (token !== false) {
                return token;
            }
            // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
            return false;
        }
        if (this._input === '') {
            clear.call(this);
            this.done = true;
            return this.EOF;
        } else {
            token = this.parseError('Lexical error on line ' + (this.yylineno + 1) + ': Unrecognized text.\n' + this.showPosition(), {
                text: this.match + this._input,
                token: null,
                line: this.yylineno,
                loc: this.yylloc,
                lexer: this
            }) || this.ERROR;
            if (token === this.ERROR) {
                // we can try to recover from a lexer error that parseError() did not 'recover' for us, by moving forward at least one character at a time:
                if (!this.match.length) {
                    this.input();
                }
            }
            return token;
        }
    },

// return next match that has a token
lex:function lexer_lex() {
        var r;
        // allow the PRE/POST handlers set/modify the return token for maximum flexibility of the generated lexer:
        if (typeof this.options.pre_lex === 'function') {
            r = this.options.pre_lex.call(this);
        }
        while (!r) {
            r = this.next();
        }
        if (typeof this.options.post_lex === 'function') {
            // (also account for a userdef function which does not return any value: keep the token as is)
            r = this.options.post_lex.call(this, r) || r;
        }
        return r;
    },

// activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)
begin:function lexer_begin(condition) {
        this.conditionStack.push(condition);
    },

// pop the previously active lexer condition state off the condition stack
popState:function lexer_popState() {
        var n = this.conditionStack.length - 1;
        if (n > 0) {
            return this.conditionStack.pop();
        } else {
            return this.conditionStack[0];
        }
    },

// produce the lexer rule set which is active for the currently active lexer condition state
_currentRules:function lexer__currentRules() {
        if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {
            return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
        } else {
            return this.conditions['INITIAL'].rules;
        }
    },

// return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available
topState:function lexer_topState(n) {
        n = this.conditionStack.length - 1 - Math.abs(n || 0);
        if (n >= 0) {
            return this.conditionStack[n];
        } else {
            return 'INITIAL';
        }
    },

// alias for begin(condition)
pushState:function lexer_pushState(condition) {
        this.begin(condition);
    },

// return the number of states currently on the stack
stateStackSize:function lexer_stateStackSize() {
        return this.conditionStack.length;
    },
options: {
  backtrack_lexer: true
},
JisonLexerError: JisonLexerError,
performAction: function anonymous(yy, yy_, $avoiding_name_collisions, YY_START) {

    /*
     * This chunk is included in the lexer action code at the very start of that method.
     *
     * `YY_START` is defined then, `YYSTATE` is not! `yy` and `yy_` are also available here.
     */
    var s, s2, s3;
    var rv, rv2, e_offset, col, row, len, value;
    var match, match2;

    //console.log("lexer action: ", yy, yy_, this, yy_.yytext, YY_START, $avoiding_name_collisions);

    var parser = yy.parser;

var YYSTATE = YY_START;
switch($avoiding_name_collisions) {
case 0 : 
/*! Conditions:: PARSE_MODE_DETECTION */ 
/*! Rule::       \u0001 */ 
 
            this.popState();
            return 131;
         
break;
case 1 : 
/*! Conditions:: PARSE_MODE_DETECTION */ 
/*! Rule::       \u0002 */ 
 
            this.popState();
            return 133;
         
break;
case 2 : 
/*! Conditions:: PARSE_MODE_DETECTION */ 
/*! Rule::       \u0003 */ 
 
            this.popState();
            return 135;
         
break;
case 3 : 
/*! Conditions:: PARSE_MODE_DETECTION */ 
/*! Rule::       . */ 
 
            this.popState();
            /*
             * When we did not observe one of the special character codes at the forefront of our
             * input stream then we will parsing the entire input in the default mode, i.e. as a formula.
             *
             * Therefore, let the previous lexer state (should be `INITIAL`) process this bit instead;
             * do not consume the matched input.
             *
             * **WARNING**: you might think this would be easily accomplished using the lexer.reject()
             * call like this:
             *
             *     this.reject();
             *
             * but `reject()` only works as expected _as long as you do NOT switch lexer states_!
             *
             * Some understanding of the lexer internals is required here: when you call `reject()`, the
             * lexer will simply test the input against the next regex in the current set. The key here
             * is _the current set_: when the lexer is required to produce a token, it will construct
             * a _regex set_ given the _current lexer state_.
             *
             * What we need here is the lexer retrying matching the same input after we changed the
             * lexer state above when we called:
             *
             *     this.popState();
             *
             * The way to accomplish this is to 'push back' the matched content into the input buffer using
             * `.unput()` and then signal the lexer that we matched nothing by returning no token at all:
             *
             *      return false;
             *
             * That `return false` will make sure the lexer considers this action as 'complete' (by
             * us `return`ing from the lexer), while the boolean `false` tells the lexer it will need
             * to run another round in order to provide its caller with a 'real' lexed token.
             *
             *
             * ### For the technically inquisitive
             *
             * The crux is us employing the side effects of the jison lexer engine,
             * more specifically this bit, where I'd like you to take notice of
             * the recursive nature of the `.lex()` method in here, plus the fact that `.next()`
             * will call `._currentRules()` each time it is invoked (while this is a very much
             * reduced and somewhat paraphrased extract of the original):
             *
             *      // generated by jison-lex...
             *      parser.lexer = {
             *          ...,
             *          next: function () {
             *              ...
             *              var match, token, rule_under_test;
             *              var rules = this._currentRules();
             *              for (var i = 0; i < rules.length; i++) {
             *                  rule_under_test = this.rules[rules[i]];
             *                  match = this._input.match(rule_under_test);
             *                  ...
             *                  if (match) {
             *                      // exec the matching lexer action code:
             *                      token = this.test_match(match, rule_under_test);
             *
             *                      // stay in this loop when .reject() was called,
             *                      // otherwise we'll run with this match:
             *                      if (!this.rejected) break;
             *                  }
             *              }
             *              if (match) {
             *                  ...
             *                  if (token !== false) {
             *                      return token;
             *                  }
             *                  // else: this is a lexer rule which consumes input
             *                  //       without producing a token (e.g. whitespace)
             *                  return false;
             *              }
             *              ...
             *          },
             *
             *          // return next match that has a token
             *          lex: function lex() {
             *              var r = this.next();
             *              if (r) {
             *                  return r;
             *              } else {
             *                  return this.lex();
             *              }
             *          },
             *
             *          // produce the lexer rule set which is active
             *          // for the currently active lexer condition state
             *          _currentRules: function _currentRules() {
             *              ...
             *              return this.conditions[...].rules;
             *          },
             *
             *          ...
             *
             *          conditions: {
             *              "PARSE_MODE_DETECTION": {
             *                  rules: [
             *                      0, 1, 2, 3, 4
             *                  ],
             *                  inclusive: false
             *              },
             *              ...
             *              "INITIAL": {
             *                  rules: [
             *                      5, 6, 7, 8, 9,
             *                      ...
             *                  ],
             *                  inclusive: true
             *              }
             *          }
             *      };
             *
             */
            this.unput(this.matches[0]);
            return false;
         
break;
case 4 : 
/*! Conditions:: PARSE_MODE_DETECTION */ 
/*! Rule::       $ */ 
 
            this.popState();
            // let the previous lexer state process that EOF for real...
            return false;
         
break;
case 5 : 
/*! Conditions:: INITIAL */ 
/*! Rule::       {DOTTED_ID}(\s*\(\s*\)) */ 
 
            /*
             * lookup this blurb: it MAY be an Excel constant posing as a function (e.g. `PI()`).
             *
             * Note that this is really another kind of lexical hack as here we include
             * a part of the GRAMMAR KNOWLEDGE in the lexer itself:
             *
             * since we 'know' now that the blurb `\1` is followed by an open brace `(`, we
             * can be certain that this is a function identifier and nothing else
             * that may have the same 'name', e.g. constant `E` or `PI` (or for very wide
             * spreadsheets: `ABS`).
             *
             * > ### Note
             * >
             * > the braces in the regex are there so we can easily grab each bit,
             * > and in particular that very last bit: it will ALWAYS be pushed back
             * > into the lexer queue as that bit is our 'additional look-ahead' at
             * > work!
             */
            // console.log("looking up functional constant in symbol table: ", yy_.yytext, this, this.matches);
            /*
             * **WARNING**: take heed of the comment further above regarding the `ID` and `WORD`
             * lexer regex 'macros' and JISON's behaviour regarding those!
             *
             * Hence we should be able to pick up the `(` at the end at `this.matches[2]`!
             */
            //this.unput(this.matches[2]);
            s = this.matches[1];
            rv = parser.getSymbol4DefinedConstant(s, FSC_FUNCTION);
            if (rv) {
                yy_.yytext = rv.value;
                switch (rv.attributes & OPCODE_MASK_FOR_FT_VALUE_TYPE) {
                default:
                    return 197;

                case FT_BOOLEAN:
                    if (rv.value)
                        return 198;
                    else
                        return 199;

                case FT_STRING:
                    return 200;
                }
            }

            // DRY: and go test the next rule(s) on the same content:
            this.reject();
         
break;
case 6 : 
/*! Conditions:: INITIAL */ 
/*! Rule::       {DOTTED_ID}(?=\s*\() */ 
 
            /*
             * lookup this blurb: it MAY be a (possibly namespaced) function identifier
             * (e.g. `SUM`, `namespace.user_defined_function42`).
             *
             * When it is not, then it most probably is a cell reference with a JSON filter expression,
             * including a filter _function_.
             *
             * Note that this is really another kind of lexical hack as here we include
             * a part of the GRAMMAR KNOWLEDGE in the lexer itself:
             *
             * since we 'know' now that the blurb `\1` is followed by an open brace `(`, we
             * can be certain that this is a function identifier and nothing else
             * that may have the same 'name', e.g. constant `E` or `PI` (or for very wide
             * spreadsheets: `ABS`).
             *
             * > ### Note
             * >
             * > the braces in the regex are there so we can easily grab each bit,
             * > and in particular that very last bit: it will ALWAYS be pushed back
             * > into the lexer queue as that bit is our 'additional look-ahead' at
             * > work!
             */
            // console.log("looking up function identifier token (+ look-ahead) in symbol table: ", yy_.yytext, this, this.matches);
            /*
             * **WARNING**: take heed of the comment further above regarding the `ID` and `WORD`
             * lexer regex 'macros' and JISON's behaviour regarding those!
             *
             * Hence we should be able to pick up the `(` at the end at `this.matches[3]`!
             */
            s = yy_.yytext;
            rv = parser.getSymbol4Function(s);
            /*
             * play nasty: produce a token ID for all functions which we support directly
             * and produce a FUNCTION token (with attribute) for everyone else.
             */
            if (rv) {
                yy_.yytext = {
                    opcode: rv,
                    text: s
                };

                return 171;
            }

            // DRY: and go test the next rule(s) on the same content:
            this.reject();
         
break;
case 7 : 
/*! Conditions:: INITIAL */ 
/*! Rule::       {WORKBOOK_PREFIX}?{DOLLAR}?[{LABEL_MIDDLE}]+\[{DOLLAR}?[{LABEL_MIDDLE}]+\][:]{WORKBOOK_PREFIX}?{DOLLAR}?[{LABEL_MIDDLE}]+\[{DOLLAR}?[{LABEL_MIDDLE}]+\] */ 
  if (parser.isValidCellRange(yy_.yytext)) { return 188; } else { this.reject(); }  
break;
case 8 : 
/*! Conditions:: INITIAL */ 
/*! Rule::       {WORKBOOK_PREFIX}?{DOLLAR}?[{LABEL_MIDDLE}]+\[{DOLLAR}?[{LABEL_MIDDLE}]+\][:]{WORKBOOK_PREFIX}?{DOLLAR}?[{UNICODE_LETTER_RANGE}]+{DOLLAR}?[0-9]+ */ 
  if (parser.isValidCellRange(yy_.yytext)) { return 188; } else { this.reject(); }  
break;
case 9 : 
/*! Conditions:: INITIAL */ 
/*! Rule::       {WORKBOOK_PREFIX}?{DOLLAR}?[{LABEL_MIDDLE}]+\[{DOLLAR}?[{LABEL_MIDDLE}]+\] */ 
  if (parser.isValidCellRef(yy_.yytext)) { return 182; } else { this.reject(); }  
break;
case 10 : 
/*! Conditions:: INITIAL */ 
/*! Rule::       {WORKBOOK_PREFIX}?{DOLLAR}?[{UNICODE_LETTER_RANGE}]+{DOLLAR}?[0-9]+[:]{WORKBOOK_PREFIX}?{DOLLAR}?[{LABEL_MIDDLE}]+\[{DOLLAR}?[{LABEL_MIDDLE}]+\] */ 
  if (parser.isValidCellRange(yy_.yytext)) { return 188; } else { this.reject(); }  
break;
case 11 : 
/*! Conditions:: INITIAL */ 
/*! Rule::       {WORKBOOK_PREFIX}?{DOLLAR}?[{UNICODE_LETTER_RANGE}]+{DOLLAR}?[0-9]+[:]{WORKBOOK_PREFIX}?{DOLLAR}?[{UNICODE_LETTER_RANGE}]+{DOLLAR}?[0-9]+ */ 
  if (parser.isValidCellRange(yy_.yytext)) { return 188; } else { this.reject(); }  
break;
case 12 : 
/*! Conditions:: INITIAL */ 
/*! Rule::       {WORKBOOK_PREFIX}?{DOLLAR}?[{UNICODE_LETTER_RANGE}]+{DOLLAR}?[0-9]+ */ 
  if (parser.isValidCellRef(yy_.yytext)) { return 182; } else { this.reject(); }  
break;
case 13 : 
/*! Conditions:: INITIAL */ 
/*! Rule::       {DOTTED_ID}(?={DUALIC_OPERATOR_MUST_FOLLOW}) */ 
 
            /*
             * lookup this blurb: it MAY be a namespaced constant (`LN10`, `namespace.user_defined_constant42`, `MATH.E`).
             */
            // console.log("looking up namespaced constant identifier token (+ look-ahead) in symbol table: ", yy_.yytext, this, this.matches);
            s = yy_.yytext;
            rv = parser.getSymbol4DefinedConstant(s);
            if (rv) {
                yy_.yytext = rv.value;
                switch (rv.attributes & OPCODE_MASK_FOR_FT_VALUE_TYPE) {
                default:
                    return 197;

                case FT_BOOLEAN:
                    if (rv.value)
                        return 198;
                    else
                        return 199;

                case FT_STRING:
                    return 200;
                }
            }

            // DRY: and go test the next rule(s) on the same content:
            this.reject();
         
break;
case 14 : 
/*! Conditions:: INITIAL */ 
/*! Rule::       (?:[{LABEL_START}][{LABEL_START} \\\/,.:-]+)(?=\s*$) */ 
 
            // TODO: parse as date (+ optional timestamp): if it is A-okay, then we have a hit.
            //
            // Else: reject.

            // DRY: and go test the next rule(s) on the same content:
            this.reject();
         
break;
case 15 : 
/*! Conditions:: INITIAL */ 
/*! Rule::       {BASIC_FLOATING_POINT_NUMBER}[kKmMgG]|[0-9]+[kKmMgG][0-9]+ */ 
 
            /*
             * Numbers with Kilo, Mega or Giga, including **resistor notation**, i.e. `1K5`.
             *
             * Keep in mind that certain locations in a formula do accept 'labels'
             * which can look **exactly** like 'numbers' for pathologically-named
             * row/column labels, e.g. `2K12`.
             *
             * We use the parser to disambiguate between the two when the lexer rules
             * above haven't already dealt with this condition.
             */
            s = yy_.yytext;         
            rv = s.match(/^([^kKmMgG]+)([kKmMgG])([^kKmMgG]*)$/);
            //console.log("parsing 'resistor notation' value: ", rv, s);
            switch (rv[2].toUpperCase()) {
            case "K":
                rv2 = 1E3;
                break;

            case "M":
                rv2 = 1E6;
                break;

            case "G":
                rv2 = 1E9;
                break;

            default:
                rv2 = 1;
                break;
            }
            if (rv[3].length > 0) {
                rv[1] += "." + rv[3];
            }
            // http://jsperf.com/number-vs-plus-vs-toint-vs-tofloat/26 --> parseFloat()
            s2 = parseFloat(rv[1]) * rv2;

            yy_.yytext = s2;

            // since these numbers cannot 'pose' as ROW numbers, we need not check for `INTEGER_NUMBER` suitability:
            return 195;
         
break;
case 16 : 
/*! Conditions:: INITIAL */ 
/*! Rule::       {BASIC_FLOATING_POINT_NUMBER}(?:[eE][+-]?[0-9]+)? */ 
 
            /*
             * Any numbers, including those in 'scientific notation', i.e. `1E5`
             *
             * Keep in mind that certain locations in a formula do accept 'labels'
             * which can look **exactly** like 'numbers' for pathologically-named
             * row / column labels, e.g. `2012`.
             *
             * We use the parser to disambiguate between the two when the lexer rules
             * above haven't already dealt with this condition.
             */

            s = yy_.yytext;
            // http://jsperf.com/number-vs-plus-vs-toint-vs-tofloat/26 --> parseFloat()
            s2 = parseFloat(s);

            yy_.yytext = s2;

            // for a number to be a floating point number, it must have a dot or an E part or be too large / small to be an integer
            if (parseInt(s, 10) !== s2) {
                return 195;
            }
            // else:
            return 196;
         
break;
case 17 : 
/*! Conditions:: INITIAL */ 
/*! Rule::       [%](?=\s*([^{IDENTIFIER_LAST}\(\s]|$)) */ 
 
            yy_.yytext = '%';
            return 190;
         
break;
case 18 : 
/*! Conditions:: INITIAL */ 
/*! Rule::       {OPERATOR} */ 
 
            /*
             * Check if the matched string STARTS WITH an operator in the list below.
             *
             * On the first pass, a hash table is created (and cached) to speed up matching.
             */
            if (!this.__operator_hash_table) {
                var definition_table = [
                    {
                        name: "$",
                        lexer_opcode: FKA_FIXED_ROW_OR_COLUMN_MARKER,
                        produce: function () {
                            return 36;
                        }
                    },
                    {
                        name: ":",
                        lexer_opcode: FKA_RANGE_MARKER,
                        produce: function () {
                            return 58;
                        }
                    },
                    {
                        name: "...",                   /* .. and ... equal : */
                        lexer_opcode: FKA_RANGE_MARKER,
                        produce: function () {
                            return 58;
                        }
                    },
                    {
                        name: "..",                    /* .. and ... equal : */
                        lexer_opcode: FKA_RANGE_MARKER,
                        produce: function () {
                            return 58;
                        }
                    },
                    {
                        name: ",",
                        lexer_opcode: FKA_COMMA,
                        produce: function () {
                            return 44;
                        }
                    },
                    {
                        name: "/*",
                        produce: function (loc) {
                            // set the end-of-comment marker for this comment and switch to parsing the comment
                            if (this.options.inline_comment_mode < this.inline_comments_monitor) {
                                this.inline_comment_end_markers = ["*/"];
                                this.inline_comment_start_yylloc = parser.deepCopy(loc);
                                this.pushState('INLINE_COMMENT');
                                return false;
                            }
                            // no dice, try another!
                            this.reject();
                        }
                    },
                    {
                        name: "(*",
                        produce: function (loc) {
                            // set the end-of-comment marker for this comment and switch to parsing the comment
                            if (this.options.inline_comment_mode < this.inline_comments_monitor) {
                                this.inline_comment_end_markers = ["*)"];
                                this.inline_comment_start_yylloc = parser.deepCopy(loc);
                                this.pushState('INLINE_COMMENT');
                                return false;
                            }
                            // no dice, try another!
                            this.reject();
                        }
                    },
                    {
                        name: "{*",
                        produce: function (loc) {
                            // set the end-of-comment marker for this comment and switch to parsing the comment
                            if (this.options.inline_comment_mode < this.inline_comments_monitor) {
                                this.inline_comment_end_markers = ["*}"];
                                this.inline_comment_start_yylloc = parser.deepCopy(loc);
                                this.pushState('INLINE_COMMENT');
                                return false;
                            }
                            // no dice, try another!
                            this.reject();
                        }
                    },
                    {
                        name: "#",
                        produce: function (loc) {
                            // set the end-of-comment marker for this comment and switch to parsing the comment
                            if (this.options.inline_comment_mode < this.inline_comments_monitor) {
                                this.inline_comment_end_markers = ["#"];
                                this.inline_comment_start_yylloc = parser.deepCopy(loc);
                                this.pushState('INLINE_COMMENT');
                                return false;
                            }
                            // no dice, try another!
                            this.reject();
                        }
                    },
                    {
                        name: "\u203c",                                  /* ‼ */
                        produce: function (loc) {
                            // set the end-of-comment marker for this comment and switch to parsing the comment
                            if (this.options.inline_comment_mode < this.inline_comments_monitor) {
                                this.inline_comment_end_markers = ["!!", "\u203c" /* ‼ */];
                                this.inline_comment_start_yylloc = parser.deepCopy(loc);
                                this.pushState('INLINE_COMMENT');
                                return false;
                            }
                            // no dice, try another!
                            this.reject();
                        }
                    },
                    {
                        name: "\u2590",                                  /* ▐ */
                        produce: function (loc) {
                            // set the end-of-comment marker for this comment and switch to parsing the comment
                            if (this.options.inline_comment_mode < this.inline_comments_monitor) {
                                this.inline_comment_end_markers = ["\u258c" /* ▌ */, "\u2590" /* ▐ */];
                                this.inline_comment_start_yylloc = parser.deepCopy(loc);
                                this.pushState('INLINE_COMMENT');
                                return false;
                            }
                            // no dice, try another!
                            this.reject();
                        }
                    },
                    {
                        name: "&&",
                        opcode: FKW_BOOLEAN_AND_OPERATOR | FT_BOOLEAN | FU_DERIVED,
                        produce: function () {
                            return 146;
                        }
                    },
                    {
                        name: "||",
                        opcode: FKW_BOOLEAN_OR_OPERATOR | FT_BOOLEAN | FU_DERIVED,
                        produce: function () {
                            return 147;
                        }
                    },
                    {
                        name: "&",
                        opcode: FKW_STRING_CONCATENATION_OPERATOR | FT_STRING | FU_STRING,
                        produce: function () {
                            return 158;
                        }
                    },
                    {
                        name: "<=",                                     // Unicode alternatives: \u22dc
                        opcode: FKW_LESS_OR_EQUAL | FT_BOOLEAN | FU_DERIVED,
                        produce: function () {
                            return 156;
                        }
                    },
                    {
                        name: ">=",                                     // Unicode alternatives: \u22dd
                        opcode: FKW_GREATER_OR_EQUAL | FT_BOOLEAN | FU_DERIVED,
                        produce: function () {
                            return 155;
                        }
                    },
                    {
                        name: "\u2264",
                        opcode: FKW_LESS_OR_EQUAL | FT_BOOLEAN | FU_DERIVED,
                        produce: function () {
                            return 156;                         /* ≤ */
                        }
                    },
                    {
                        name: "\u2266",
                        opcode: FKW_LESS_OR_EQUAL | FT_BOOLEAN | FU_DERIVED,
                        produce: function () {
                            return 156;                         /* ≦ */
                        }
                    },
                    {
                        name: "\u2265",
                        opcode: FKW_GREATER_OR_EQUAL | FT_BOOLEAN | FU_DERIVED,
                        produce: function () {
                            return 155;                      /* ≥ */
                        }
                    },
                    {
                        name: "\u2267",
                        opcode: FKW_GREATER_OR_EQUAL | FT_BOOLEAN | FU_DERIVED,
                        produce: function () {
                            return 155;                      /* ≧ */
                        }
                    },
                    {
                        name: "<>",                                     // Unicode alternatives: \u2276, \u2277
                        opcode: FKW_NOT_EQUAL | FT_BOOLEAN | FU_DERIVED,
                        produce: function () {
                            return 149;
                        }
                    },
                    {
                        name: "!=",                                     // Unicode alternatives: \u2260
                        opcode: FKW_NOT_EQUAL | FT_BOOLEAN | FU_DERIVED,
                        produce: function () {
                            return 149;
                        }
                    },
                    {
                        name: "!==",
                        opcode: FKW_NOT_IDENTICAL | FT_BOOLEAN | FU_DERIVED,
                        produce: function () {
                            return 150;
                        }
                    },
                    {
                        name: "<",
                        opcode: FKW_LESS_THAN | FT_BOOLEAN | FU_DERIVED,
                        produce: function () {
                            return 60;
                        }
                    },
                    {
                        name: ">",
                        opcode: FKW_GREATER_THAN | FT_BOOLEAN | FU_DERIVED,
                        produce: function () {
                            return 62;
                        }
                    },
                    {
                        name: "===",
                        opcode: FKW_IS_IDENTICAL | FT_BOOLEAN | FU_DERIVED,
                        produce: function () {
                            return 153;
                        }
                    },
                    {
                        name: "==",
                        opcode: FKW_EQUAL | FT_BOOLEAN | FU_DERIVED,
                        produce: function () {
                            return 157;
                        }
                    },
                    {
                        name: "=",
                        opcode: FKW_EQUAL | FT_BOOLEAN | FU_DERIVED,
                        produce: function () {
                            // This MAY be the `=` starting a formula: mark the event for the inline comments:
                            if (this.options.inline_comment_mode > 0) {
                                if (!this.inline_comments_monitor) {
                                    this.inline_comments_monitor = this.options.inline_comment_mode + 1;
                                }
                            }
                            return 61;
                        }
                    },
                    {
                        name: "**",
                        opcode: FKW_POWER | FT_NUMBER | FU_ANY,
                        produce: function () {
                            return 94;
                        }
                    },
                    {
                        name: "*",
                        opcode: FKW_MULTIPLY | FT_NUMBER | FU_DERIVED,
                        produce: function () {
                            return 42;
                        }
                    },
                    {
                        name: "/",
                        opcode: FKW_DIVIDE | FT_NUMBER | FU_DERIVED,
                        produce: function () {
                            return 47;
                        }
                    },
                    {
                        name: "-",
                        opcode: FKW_SUBTRACT | FT_NUMBER | FU_DERIVED,
                        produce: function () {
                            return 45;
                        }
                    },
                    {
                        name: "+",
                        opcode: FKW_ADD | FT_NUMBER | FU_DERIVED,
                        produce: function () {
                            return 43;
                        }
                    },
                    {
                        name: "^",
                        opcode: FKW_POWER | FT_NUMBER | FU_ANY,
                        produce: function () {
                            return 94;
                        }
                    },
                    {
                        name: "%",
                        opcode: FKW_MODULO_OPERATOR,
                        produce: function () {
                            return 160;
                        }
                    },
                    {
                        name: "\u2030",
                        opcode: FKW_PROMILAGE_OPERATOR,
                        produce: function () {
                            return 191;                 /* ‰ */
                        }
                    },
                    {
                        name: "\u221a",
                        opcode: FKW_SQRT_OPERATOR | FT_NUMBER | FU_ANY,
                        produce: function () {
                            return 163;                     /* √ */
                        }
                    },
                    {
                        name: "\u2248",
                        opcode: FKW_ALMOST_EQUAL | FT_BOOLEAN | FU_DERIVED,
                        produce: function () {
                            return 152;                      /* ≈ */
                        }
                    },
                    {
                        name: "\u2260",
                        opcode: FKW_NOT_EQUAL | FT_BOOLEAN | FU_DERIVED,
                        produce: function () {
                            return 149;                         /* ≠ */
                        }
                    },
                    {
                        name: "\u2264",
                        opcode: FKW_LESS_OR_EQUAL | FT_BOOLEAN | FU_DERIVED,
                        produce: function () {
                            return 156;                     /* ≤ */
                        }
                    },
                    {
                        name: "\u2265",
                        opcode: FKW_GREATER_OR_EQUAL | FT_BOOLEAN | FU_DERIVED,
                        produce: function () {
                            return 155;                  /* ≥ */
                        }
                    },
                    {
                        name: "\u2212",
                        opcode: FKW_SUBTRACT | FT_NUMBER | FU_DERIVED,
                        produce: function () {
                            return 45;                                 /* − */
                        }
                    },
                    {
                        name: "\u2013",
                        opcode: FKW_SUBTRACT | FT_NUMBER | FU_DERIVED,
                        produce: function () {
                            return 45;                                 /* – */
                        }
                    },
                    {
                        name: "\u2012",
                        opcode: FKW_SUBTRACT | FT_NUMBER | FU_DERIVED,
                        produce: function () {
                            return 45;                                 /* ‒ */
                        }
                    },
                    {
                        name: "\u2014",
                        opcode: FKW_SUBTRACT | FT_NUMBER | FU_DERIVED,
                        produce: function () {
                            return 45;                                 /* — */
                        }
                    },
                    {
                        name: "\u2215",
                        opcode: FKW_DIVIDE | FT_NUMBER | FU_DERIVED,
                        produce: function () {
                            return 47;                                 /* ∕ */
                        }
                    },
                    {
                        name: "\u2044",
                        opcode: FKW_DIVIDE | FT_NUMBER | FU_DERIVED,
                        produce: function () {
                            return 47;                                 /* ⁄ */
                        }
                    },
                    {
                        name: "\u2219",
                        opcode: FKW_MULTIPLY | FT_NUMBER | FU_DERIVED,
                        produce: function () {
                            return 42;                                 /* ∙ */
                        }
                    },
                    {
                        name: "\u2022",
                        opcode: FKW_MULTIPLY | FT_NUMBER | FU_DERIVED,
                        produce: function () {
                            return 42;                                 /* • */
                        }
                    },
                    {
                        name: "\u2261",
                        opcode: FKW_IS_IDENTICAL | FT_BOOLEAN | FU_DERIVED,
                        produce: function () {
                            return 153;                      /* ≡ */
                        }
                    },
                    {
                        name: "\u2310",
                        opcode: FKW_BOOLEAN_NOT_OPERATOR | FT_BOOLEAN | FU_DERIVED,
                        produce: function () {
                            return 33;                                 /* ⌐ */
                        }
                    },
                    {
                        name: "\u00ac",
                        opcode: FKW_BOOLEAN_NOT_OPERATOR | FT_BOOLEAN | FU_DERIVED,
                        produce: function () {
                            return 33;                                 /* ¬ */
                        }
                    },
                    {
                        name: "!",
                        opcode: FKW_BOOLEAN_NOT_OPERATOR | FT_BOOLEAN | FU_DERIVED,
                        produce: function () {
                            return 33;
                        }
                    },
                    {
                        name: "\u2229",
                        opcode: FKW_BOOLEAN_AND_OPERATOR | FT_BOOLEAN | FU_DERIVED,
                        produce: function () {
                            return 146;              /* ∩ */
                        }
                    },
                    {
                        name: "\u00f7",
                        opcode: FKW_DIVIDE | FT_NUMBER | FU_DERIVED,
                        produce: function () {
                            return 47;                                 /* ÷ */
                        }
                    },
                    {
                        name: "\u00d7",
                        opcode: FKW_MULTIPLY | FT_NUMBER | FU_DERIVED,
                        produce: function () {
                            return 42;                                 /* × */
                        }
                    },
                    {
                        name: "\u00b7",
                        opcode: FKW_MULTIPLY | FT_NUMBER | FU_DERIVED,
                        produce: function () {
                            return 42;                                 /* · */
                        }
                    },
                    {
                        name: "\u2219",
                        opcode: FKW_MULTIPLY | FT_NUMBER | FU_DERIVED,
                        produce: function () {
                            return 42;                                 /* ∙ */
                        }
                    },
                    {
                        name: "\u00b0",
                        opcode: FKW_DEGREES_OPERATOR,
                        produce: function () {
                            return 192;                  /* ° */
                        }
                    },
                    {
                        name: "\u00b2",
                        opcode: FKW_SQUARE_OPERATOR | FT_NUMBER | FU_DERIVED,
                        produce: function () {
                            return 164;                   /* ² */
                        }
                    },
                    {
                        name: "\u00b3",
                        opcode: FKW_CUBE_OPERATOR | FT_NUMBER | FU_DERIVED,
                        produce: function () {
                            return 165;                     /* ³ */
                        }
                    },
                    {
                        /*
                         * This token is an alternative notation which does not require the curly braces around
                         * a 'fragmented range reference', e.g. `{A1, A2, A3, B1}` is equivalent to `A1 ○ A2 ○ A3 ○ B1`
                         * which could also be written as `A1:A3 ○ B1`
                         */
                        name: "\u25cb",
                        opcode: FKW_ARRAY_CONCATENATION_OPERATOR,
                        produce: function () {
                            return 183;      /* ○ */
                        }
                    },
                    {
                        /*
                         * This token is an alternative notation which does not require the curly braces around
                         * a 'fragmented range reference', e.g. `{A1, A2, A3, B1}` is equivalent to `A1 ◦ A2 ◦ A3 ◦ B1`
                         * which could also be written as `A1:A3 ◦ B1`
                         */
                        name: "\u25e6",
                        opcode: FKW_ARRAY_CONCATENATION_OPERATOR,
                        produce: function () {
                            return 183;      /* ◦ */
                        }
                    },
                    {
                        name: "@",
                        opcode: FKW_DATA_MARKER,
                        produce: function () {
                            return 64;
                        }
                    },
                    {
                        name: ".",
                        opcode: FKW_DOT,
                        produce: function () {
                            // switch lexer modes RIGHT NOW: next up is the `json_filter_expression` rule!
                            assert(this.topState() !== 'JSON_FILTERING');
                            //this.pushState('JSON_FILTERING');   -- Fixed #880 

                            return 46;
                        }
                    }
                ];
                var k, d, tlen, ht;

                ht = [{}, {}, {}, {}];
                for (var k = 0, tlen = definition_table.length; k < tlen; k++) {
                    d = definition_table[k];
                    assert(d.name);
                    ht[d.name.length][d.name] = d;
                }

                this.__operator_hash_table = ht;
            }

            var s1 = false, s2 = false, s3 = false;

            s = yy_.yytext;
            switch (s.length) {
            case 3:
                s3 = s;
                s = s.substr(0, 2);
                // fall through
            case 2:
                s2 = s;
                s = s.substr(0, 1);
                // fall through
            case 1:
                s1 = s;
                break;
            default:
                assert(0, "should never get here");
                break;
            }

            // reset `s`:
            s = yy_.yytext;

            // now find matches in the operator lookup table, largest match first:
            rv = this.__operator_hash_table[3][s3] || this.__operator_hash_table[2][s2] || this.__operator_hash_table[1][s1];
            if (rv) {
                // push the remainder back into the buffer before we continue:
                if (s.length > rv.name.length) {
                    this.unput(s.substr(rv.name.length));
                }

                if (rv.opcode) {
                    yy_.yytext = rv.name;
                } else if (rv.lexer_opcode) {
                    yy_.yytext = rv.name;
                }
                return rv.produce.call(this, yy_.yylloc, yy_.yytext);
            }

            /* This may be a single Unicode character representing some constant or currency */
            if (s.length > 1) {
                this.unput(s.substr(1));
            }
            s = s1;

            rv = parser.getSymbol4Currency(s);
            if (rv) {
                yy_.yytext = s;
                return 193;
            }

            // no dice, now see if this is a predefined constant
            rv = parser.getSymbol4DefinedConstant(s);
            if (rv) {
                yy_.yytext = rv.value;
                switch (rv.attributes & OPCODE_MASK_FOR_FT_VALUE_TYPE) {
                default:
                    return 197;

                case FT_BOOLEAN:
                    if (rv.value)
                        return 198;
                    else
                        return 199;

                case FT_STRING:
                    return 200;
                }
            }

            // when we don't have a match at all, we leave it to the other rules to hit something:
            this.reject();
         
break;
case 25 : 
/*! Conditions:: INITIAL */ 
/*! Rule::       \u2039([^\u203a]*)\u203a */ 
                                                   /* ‹string› */
            s = this.matches[1];
            yy_.yytext = s;
            return 200;
         
break;
case 26 : 
/*! Conditions:: INITIAL */ 
/*! Rule::       \u201c([^\u201d]*)\u201d */ 
                                                   /* “string” */
            s = this.matches[1];
            yy_.yytext = s;
            return 200;
         
break;
case 27 : 
/*! Conditions:: INITIAL */ 
/*! Rule::       \u00ab([^\u00bb]*)\u00bb */ 
                                                   /* «string» */
            s = this.matches[1];
            yy_.yytext = s;
            return 200;
         
break;
case 28 : 
/*! Conditions:: INITIAL */ 
/*! Rule::       '(.*)$ */ 
 
            // This lexer rule should only accept Excel string values, i.e. non-formula entities
            // which start with a quote.
            //
            // TODO: later on make the lexer smarter (and a bit faster) by using lexer states
            // instead of this hack which checks the location info to recognize whether this is
            // the very first token we encounter: only when it is does this special situation apply.
            var pos = this.offset - yy_.yyleng;
            if (pos > 0) {
                this.reject();
            } else {
                s = this.matches[1];
                // s2 = parser.dedupQuotedString(s, "'");  -- Excel does not 'deduplicate' quotes in literal string values like these.

                yy_.yytext = s;
                // In MS Excel you can force any (entire!) formula or other input to be parsed as a string by prefixing it with a single "'" single quote.
                return 144;
            }
         
break;
case 29 : 
/*! Conditions:: INITIAL */ 
/*! Rule::       "(.*)$ */ 
 
            // This lexer rule should only accept Excel string values, i.e. non-formula entities
            // which start with a quote.
            //
            // TODO: later on make the lexer smarter (and a bit faster) by using lexer states
            // instead of this hack which checks the location info to recognize whether this is
            // the very first token we encounter: only when it is does this special situation apply.
            var pos = this.offset - yy_.yyleng;
            if (pos > 0) {
                this.reject();
            } else {
                s = this.matches[1];
                // s2 = parser.dedupQuotedString(s, '"');  -- Excel does not 'deduplicate' quotes in literal string values like these.

                yy_.yytext = s;
                // In MS Excel you can force any (entire!) formula or other input to be parsed as a string by prefixing it with a single "'" single quote.
                return 144;
            }
         
break;
case 30 : 
/*! Conditions:: INITIAL */ 
/*! Rule::       '([^']*(?:''[^']*)*)'{TOKEN_SENTINEL} */ 
 
            this.unput(this.matches[2]);

            s = this.matches[1];
            s2 = parser.dedupQuotedString(s, "'");
            yy_.yytext = s2;
            return 200;
         
break;
case 31 : 
/*! Conditions:: INITIAL */ 
/*! Rule::       "([^"]*(?:""[^"]*)*)"{TOKEN_SENTINEL} */ 
 
            this.unput(this.matches[2]);

            s = this.matches[1];
            s2 = parser.dedupQuotedString(s, '"');
            yy_.yytext = s2;
            return 200;
         
break;
case 32 : 
/*! Conditions:: INITIAL */ 
/*! Rule::       \s+ */ 
 /*: skip whitespace */ 
break;
case 34 : 
/*! Conditions:: INITIAL */ 
/*! Rule::       {DOTTED_WORDS} */ 
 
            rv = yy.parser.parseError("Don't know what to do with this: it's unsupported input.", {
                text: yy_.yytext,
                //token: $error,
                line: yy_.yylloc,
                loc: yy_.yylloc,
                outer_loc: yy_.yylloc,
                expected: [],
                recoverable: false
            });
            assert(rv === null);
            return 2;
         
break;
case 35 : 
/*! Conditions:: INITIAL */ 
/*! Rule::       . */ 
 
            rv = yy.parser.parseError("Don't know what to do with this: it's unsupported input.", {
                text: yy_.yytext,
                //token: $error,
                line: yy_.yylloc,
                loc: yy_.yylloc,
                outer_loc: yy_.yylloc,
                expected: [],
                recoverable: false
            });
            assert(rv === null);
            return 2;
         
break;
case 36 : 
/*! Conditions:: INLINE_COMMENT */ 
/*! Rule::       [^\/\*\)\}#!\u203c\u258c\u2590]+ */ 
                                                   /* * / ) | # ! ‼ ▌ ▐ */
            /* keep it all; we haven't hit an end-of-comment marker starting character yet! */
            this.more();
         
break;
case 37 : 
/*! Conditions:: INLINE_COMMENT */ 
/*! Rule::       . */ 
 
            for (rv = 0, len = this.inline_comment_end_markers.length; rv < len; rv++) {
                s2 = this.inline_comment_end_markers[rv];
                if (s2[0] === this.matches[0]) {
                    // we got a POTENTIAL MATCH; let's see if we need more:
                    if (s2.length > 1) {
                        // when yes, test the next rule!
                        this.reject();
                        return false;
                    } else {
                        /*
                        * Full match! end of comment reached.
                        *
                        * Remove this last bit from the parsed text and strip leading / trailing whitespace.
                        *
                        * > ### Notes
                        * >
                        * > Since returning actual tokens for any inline comments would
                        * > break the LALR(1) grammar most severely, we concatenate
                        * > comments and attach them to the next token.
                        * >
                        * > Since the 'next token' MAY be `EOF`, we need the parser
                        * > to check if there's any leech called `comment` hanging
                        * > off that EOF it might've got dropped in the in-box...
                        */
                        parser.pushComment();
                        this.popState();
                        return false;
                    }
                }
            }
            // collect input until we hit something we know:
            this.more();
         
break;
case 38 : 
/*! Conditions:: INLINE_COMMENT */ 
/*! Rule::       .. */ 
 
            /*
             * We only hit this rule when the previous one was `reject()`-ed
             * as that rule will match anything that's the start of this one.
             *
             * Hence we know we have a partial match on a comment terminator,
             * but we need to make sure.
             *
             * We also know that our longest 'end markers' are 2 characters wide,
             * so this solution is sufficient and complete.
             *
             * Now all we have to do is scan the longer-than-1-character
             * comment markers against what we've got here and if there's
             * NO MATCH, we need to keep in mind that nasty people can write
             * comments like `{***}` and we have a hit on `**}` so we may only
             * consume one character here in that case.
             */
            for (rv = 0, len = this.inline_comment_end_markers.length; rv < len; rv++) {
                s2 = this.inline_comment_end_markers[rv];
                if (s2 === this.matches[0]) {
                    /*
                     * Full match! end of comment reached.
                     *
                     * Remove this last bit from the parsed text and strip leading/trailing whitespace.
                     *
                     * Since returning actual tokens for any inline comments would
                     * break the LALR(1) grammar most severely, we concatenate
                     * comments and attach them to the next token.
                     *
                     * Since the 'next token' MAY be `EOF`, we need the parser
                     * to check if there's any leech called `comment` hanging
                     * of that EOF it might've got dropped in the in-box...
                     */
                    parser.pushComment();
                    this.popState();
                    return false;
                }
            }
            // we may only consume a single character, so we `unput()` the last one:
            this.less(1);

            // collect input until we hit something we know:
            this.more();
         
break;
case 39 : 
/*! Conditions:: INLINE_COMMENT */ 
/*! Rule::       $ */ 
 
            parser.pushComment();

            rv = yy.parser.parseError("Unterminated inline comment.", {
                text: yy_.yytext,
                //token: $error,
                line: yy_.yylloc,
                loc: yy_.yylloc,
                outer_loc: yy_.yylloc,
                expected: [],
                recoverable: false
            });
            assert(rv === null);
            return 2;
         
break;
default:
  return this.simpleCaseActionClusters[$avoiding_name_collisions];
}
},
simpleCaseActionClusters: {

  /*! Conditions:: INITIAL */ 
  /*! Rule::       \( */ 
   19 : 40,
  /*! Conditions:: INITIAL */ 
  /*! Rule::       \) */ 
   20 : 41,
  /*! Conditions:: INITIAL */ 
  /*! Rule::       \{ */ 
   21 : 123,
  /*! Conditions:: INITIAL */ 
  /*! Rule::       \} */ 
   22 : 125,
  /*! Conditions:: INITIAL */ 
  /*! Rule::       \[ */ 
   23 : 91,
  /*! Conditions:: INITIAL */ 
  /*! Rule::       \] */ 
   24 : 93,
  /*! Conditions:: INITIAL */ 
  /*! Rule::       $ */ 
   33 : 1
},
rules: [
/^(?:\u0001)/,
/^(?:\u0002)/,
/^(?:\u0003)/,
/^(?:.)/,
/^(?:$)/,
/^(?:([^\u0000-@\[-\^`{-©«-´¶-¹»-¿×÷˂-˅˒-˟˥-˫˭˯-̈́͆-ͯ͵͸͹;΀-΅·΋΍΢϶҂-҉԰՗՘՚-ՠֈ-֯־׀׃׆׈-׏׫-ׯ׳-؏؛-؟٘٠-٭۔۝-۠۩-۬۰-۹۽۾܀-܏݀-݌޲-߉߫-߳߶-߹߻-߿࠘࠙࠭-࠿࡙-࢟ࢵ-࣢࣪-़्࣯॑-॔।-॰঄঍঎঑঒঩঱঳-঵঺-়৅৆৉৊্৏-৖৘-৛৞৤-৯৲-਀਄਋-਎਑਒਩਱਴਷਺-਽੃-੆੉੊੍-੐੒-੘੝੟-੯੶-઀઄઎઒઩઱઴઺-઼૆૊્-૏૑-૟૤-૸ૺ-଀଄଍଎଑଒଩଱଴଺-଼୅୆୉୊୍-୕୘-୛୞୤-୰୲-஁஄஋-஍஑஖-஘஛஝஠-஢஥-஧஫-஭஺-஽௃-௅௉்-௏௑-௖௘-௿ఄ఍఑఩఺-఼౅౉్-౔౗౛-౟౤-ಀ಄಍಑಩಴಺-಼೅೉್-೔೗-ೝ೟೤-೰ೳ-ഀഄ഍഑഻഼൅൉്൏-ൖ൘-൞൤-൹඀ඁ඄඗-඙඲඼඾඿෇-෎෕෗෠-෱෴-฀฻-฿็-์๎-຀຃຅ຆຉ຋ຌຎ-ຓຘຠ຤຦ຨຩຬ຺຾຿໅໇-໌໎-໛໠-໿༁-༿཈཭-཰ྂ-྇྘྽-࿿့္်၀-၏ၣၤၩ-ၭႇ-ႍႏ-ႛ႞႟჆჈-჌჎჏჻቉቎቏቗቙቞቟኉኎኏኱኶኷኿዁዆዇዗጑጖጗፛-፞፠-፿᎐-᎟᏶᏷᏾-᐀᙭᙮ ᚛-᚟᛫-᛭᛹-᛿ᜍ᜔-ᜟ᜴-᜿᝔-᝟᝭᝱᝴-᝿឴឵៉-៖៘-៛៝-᠟ᡸ-᡿᢫-᢯᣶-᣿᤟᤬-᤯᤹-᥏᥮᥯᥵-᥿᦬-᦯᧊-᧿᨜-᨟᩟᩠᩵-᪦᪨-᫿᬴᭄ᭌ-᭿᮪᮫᮰-᮹᯦᯲-᯿ᰶ-᱌᱐-᱙᱾-᳨᳭᳴᳷-᳿᷀-ᷦ᷵-᷿἖἗἞἟὆὇὎὏὘὚὜὞὾὿᾵᾽᾿-῁῅῍-῏῔῕῜-῟῭-῱῵´-⁰⁲-⁾₀-₏₝-℁℃-℆℈℉℔№-℘℞-℣℥℧℩℮℺℻⅀-⅄⅊-⅍⅏-⅟↉-⒵⓪-⯿Ⱟⱟ⳥-⳪⳯-⳱⳴-⳿⴦⴨-⴬⴮⴯⵨-⵮⵰-⵿⶗-⶟⶧⶯⶷⶿⷇⷏⷗⷟⸀-⸮⸰-〄〈-〠〪-〰〶〷〽-぀゗-゜゠・㄀-㄄ㄮ-㄰㆏-㆟ㆻ-㇯㈀-㏿䶶-䷿鿖-鿿꒍-꓏꓾꓿꘍-꘏꘠-꘩꘬-꘿꙯-꙳꙼-꙾꛰-꜖꜠꜡꞉꞊ꞮꞯꞸ-ꟶꠂ꠆ꠋ꠨-꠿꡴-꡿꣄-꣱꣸-꣺꣼ꣾ-꤉꤫-꤯꥓-꥟꥽-꥿꦳꧀-꧎꧐-꧟ꧥ꧰-꧹꧿꨷-꨿꩎-꩟꩷-꩹ꩻ-ꩽ꪿꫁꫃-꫚꫞꫟꫰꫱꫶-꬀꬇꬈꬏꬐꬗-꬟꬧꬯꭛ꭦ-꭯꯫-꯿힤-힯퟇-퟊퟼-﩮﩯﫚-﫿﬇-﬒﬘-﬜﬩﬷﬽﬿﭂﭅﮲-﯒﴾-﵏﶐﶑﷈-﷯﷼-﹯﹵﻽-＠［-｀｛-･﾿-￁￈￉￐￑￘￙￝-\uffff](?:[^\u0000-\-\/:-@\[-\^`{-©«-±´¶-¸»¿×÷˂-˅˒-˟˥-˫˭˯-̈́͆-ͯ͵͸͹;΀-΅·΋΍΢϶҂-҉԰՗՘՚-ՠֈ-֯־׀׃׆׈-׏׫-ׯ׳-؏؛-؟٘٪-٭۔۝-۠۩-۬۽۾܀-܏݀-݌޲-޿߫-߳߶-߹߻-߿࠘࠙࠭-࠿࡙-࢟ࢵ-࣢࣪-़्࣯॑-॔।॥॰঄঍঎঑঒঩঱঳-঵঺-়৅৆৉৊্৏-৖৘-৛৞৤৥৲৳৺-਀਄਋-਎਑਒਩਱਴਷਺-਽੃-੆੉੊੍-੐੒-੘੝੟-੥੶-઀઄઎઒઩઱઴઺-઼૆૊્-૏૑-૟૤૥૰-૸ૺ-଀଄଍଎଑଒଩଱଴଺-଼୅୆୉୊୍-୕୘-୛୞୤୥୰୸-஁஄஋-஍஑஖-஘஛஝஠-஢஥-஧஫-஭஺-஽௃-௅௉்-௏௑-௖௘-௥௳-௿ఄ఍఑఩఺-఼౅౉్-౔౗౛-౟౤౥౰-౷౿ಀ಄಍಑಩಴಺-಼೅೉್-೔೗-ೝ೟೤೥೰ೳ-ഀഄ഍഑഻഼൅൉്൏-ൖ൘-൞൤൥൶-൹඀ඁ඄඗-඙඲඼඾඿෇-෎෕෗෠-෥෰෱෴-฀฻-฿็-์๎๏๚-຀຃຅ຆຉ຋ຌຎ-ຓຘຠ຤຦ຨຩຬ຺຾຿໅໇-໌໎໏໚໛໠-໿༁-༟༴-༿཈཭-཰ྂ-྇྘྽-࿿့္်၊-၏ၣၤၩ-ၭႇ-ႍႏႚႛ႞႟჆჈-჌჎჏჻቉቎቏቗቙቞቟኉኎኏኱኶኷኿዁዆዇዗጑጖጗፛-፞፠-፨፽-፿᎐-᎟᏶᏷᏾-᐀᙭᙮ ᚛-᚟᛫-᛭᛹-᛿ᜍ᜔-ᜟ᜴-᜿᝔-᝟᝭᝱᝴-᝿឴឵៉-៖៘-៛៝-៟៪-៯៺-᠏᠚-᠟ᡸ-᡿᢫-᢯᣶-᣿᤟᤬-᤯᤹-᥅᥮᥯᥵-᥿᦬-᦯᧊-᧏᧛-᧿᨜-᨟᩟᩠᩵-᩿᪊-᪏᪚-᪦᪨-᫿᬴᭄ᭌ-᭏᭚-᭿᯦᮪᮫᯲-᯿ᰶ-᰿᱊-᱌᱾-᳨᳭᳴᳷-᳿᷀-ᷦ᷵-᷿἖἗἞἟὆὇὎὏὘὚὜὞὾὿᾵᾽᾿-῁῅῍-῏῔῕῜-῟῭-῱῵´-⁯⁲⁳⁺-⁾₊-₏₝-℁℃-℆℈℉℔№-℘℞-℣℥℧℩℮℺℻⅀-⅄⅊-⅍⅏↊-⑟⒜-⒵─-❵➔-⯿Ⱟⱟ⳥-⳪⳯-⳱⳴-⳼⳾⳿⴦⴨-⴬⴮⴯⵨-⵮⵰-⵿⶗-⶟⶧⶯⶷⶿⷇⷏⷗⷟⸀-⸮⸰-〄〈-〠〪-〰〶〷〽-぀゗-゜゠・㄀-㄄ㄮ-㄰㆏-㆑㆖-㆟ㆻ-㇯㈀-㈟㈪-㉇㉐㉠-㉿㊊-㊰㋀-㏿䶶-䷿鿖-鿿꒍-꓏꓾꓿꘍-꘏꘬-꘿꙯-꙳꙼-꙾꛰-꜖꜠꜡꞉꞊ꞮꞯꞸ-ꟶꠂ꠆ꠋ꠨-꠯꠶-꠿꡴-꡿꣄-꣏꣚-꣱꣸-꣺꣼ꣾꣿ꤫-꤯꥓-꥟꥽-꥿꦳꧀-꧎꧚-꧟ꧥ꧿꨷-꨿꩎꩏꩚-꩟꩷-꩹ꩻ-ꩽ꪿꫁꫃-꫚꫞꫟꫰꫱꫶-꬀꬇꬈꬏꬐꬗-꬟꬧꬯꭛ꭦ-꭯꯫-꯯꯺-꯿힤-힯퟇-퟊퟼-﩮﩯﫚-﫿﬇-﬒﬘-﬜﬩﬷﬽﬿﭂﭅﮲-﯒﴾-﵏﶐﶑﷈-﷯﷼-﹯﹵﻽-／：-＠［-｀｛-･﾿-￁￈￉￐￑￘￙￝-\uffff]*[^\u0000-\/:-@\[-\^`{-©«-±´¶-¸»¿×÷˂-˅˒-˟˥-˫˭˯-̈́͆-ͯ͵͸͹;΀-΅·΋΍΢϶҂-҉԰՗՘՚-ՠֈ-֯־׀׃׆׈-׏׫-ׯ׳-؏؛-؟٘٪-٭۔۝-۠۩-۬۽۾܀-܏݀-݌޲-޿߫-߳߶-߹߻-߿࠘࠙࠭-࠿࡙-࢟ࢵ-࣢࣪-़्࣯॑-॔।॥॰঄঍঎঑঒঩঱঳-঵঺-়৅৆৉৊্৏-৖৘-৛৞৤৥৲৳৺-਀਄਋-਎਑਒਩਱਴਷਺-਽੃-੆੉੊੍-੐੒-੘੝੟-੥੶-઀઄઎઒઩઱઴઺-઼૆૊્-૏૑-૟૤૥૰-૸ૺ-଀଄଍଎଑଒଩଱଴଺-଼୅୆୉୊୍-୕୘-୛୞୤୥୰୸-஁஄஋-஍஑஖-஘஛஝஠-஢஥-஧஫-஭஺-஽௃-௅௉்-௏௑-௖௘-௥௳-௿ఄ఍఑఩఺-఼౅౉్-౔౗౛-౟౤౥౰-౷౿ಀ಄಍಑಩಴಺-಼೅೉್-೔೗-ೝ೟೤೥೰ೳ-ഀഄ഍഑഻഼൅൉്൏-ൖ൘-൞൤൥൶-൹඀ඁ඄඗-඙඲඼඾඿෇-෎෕෗෠-෥෰෱෴-฀฻-฿็-์๎๏๚-຀຃຅ຆຉ຋ຌຎ-ຓຘຠ຤຦ຨຩຬ຺຾຿໅໇-໌໎໏໚໛໠-໿༁-༟༴-༿཈཭-཰ྂ-྇྘྽-࿿့္်၊-၏ၣၤၩ-ၭႇ-ႍႏႚႛ႞႟჆჈-჌჎჏჻቉቎቏቗቙቞቟኉኎኏኱኶኷኿዁዆዇዗጑጖጗፛-፞፠-፨፽-፿᎐-᎟᏶᏷᏾-᐀᙭᙮ ᚛-᚟᛫-᛭᛹-᛿ᜍ᜔-ᜟ᜴-᜿᝔-᝟᝭᝱᝴-᝿឴឵៉-៖៘-៛៝-៟៪-៯៺-᠏᠚-᠟ᡸ-᡿᢫-᢯᣶-᣿᤟᤬-᤯᤹-᥅᥮᥯᥵-᥿᦬-᦯᧊-᧏᧛-᧿᨜-᨟᩟᩠᩵-᩿᪊-᪏᪚-᪦᪨-᫿᬴᭄ᭌ-᭏᭚-᭿᯦᮪᮫᯲-᯿ᰶ-᰿᱊-᱌᱾-᳨᳭᳴᳷-᳿᷀-ᷦ᷵-᷿἖἗἞἟὆὇὎὏὘὚὜὞὾὿᾵᾽᾿-῁῅῍-῏῔῕῜-῟῭-῱῵´-⁯⁲⁳⁺-⁾₊-₏₝-℁℃-℆℈℉℔№-℘℞-℣℥℧℩℮℺℻⅀-⅄⅊-⅍⅏↊-⑟⒜-⒵─-❵➔-⯿Ⱟⱟ⳥-⳪⳯-⳱⳴-⳼⳾⳿⴦⴨-⴬⴮⴯⵨-⵮⵰-⵿⶗-⶟⶧⶯⶷⶿⷇⷏⷗⷟⸀-⸮⸰-〄〈-〠〪-〰〶〷〽-぀゗-゜゠・㄀-㄄ㄮ-㄰㆏-㆑㆖-㆟ㆻ-㇯㈀-㈟㈪-㉇㉐㉠-㉿㊊-㊰㋀-㏿䶶-䷿鿖-鿿꒍-꓏꓾꓿꘍-꘏꘬-꘿꙯-꙳꙼-꙾꛰-꜖꜠꜡꞉꞊ꞮꞯꞸ-ꟶꠂ꠆ꠋ꠨-꠯꠶-꠿꡴-꡿꣄-꣏꣚-꣱꣸-꣺꣼ꣾꣿ꤫-꤯꥓-꥟꥽-꥿꦳꧀-꧎꧚-꧟ꧥ꧿꨷-꨿꩎꩏꩚-꩟꩷-꩹ꩻ-ꩽ꪿꫁꫃-꫚꫞꫟꫰꫱꫶-꬀꬇꬈꬏꬐꬗-꬟꬧꬯꭛ꭦ-꭯꯫-꯯꯺-꯿힤-힯퟇-퟊퟼-﩮﩯﫚-﫿﬇-﬒﬘-﬜﬩﬷﬽﬿﭂﭅﮲-﯒﴾-﵏﶐﶑﷈-﷯﷼-﹯﹵﻽-／：-＠［-｀｛-･﾿-￁￈￉￐￑￘￙￝-\uffff])?)(\s*\(\s*\)))/,
/^(?:([^\u0000-@\[-\^`{-©«-´¶-¹»-¿×÷˂-˅˒-˟˥-˫˭˯-̈́͆-ͯ͵͸͹;΀-΅·΋΍΢϶҂-҉԰՗՘՚-ՠֈ-֯־׀׃׆׈-׏׫-ׯ׳-؏؛-؟٘٠-٭۔۝-۠۩-۬۰-۹۽۾܀-܏݀-݌޲-߉߫-߳߶-߹߻-߿࠘࠙࠭-࠿࡙-࢟ࢵ-࣢࣪-़्࣯॑-॔।-॰঄঍঎঑঒঩঱঳-঵঺-়৅৆৉৊্৏-৖৘-৛৞৤-৯৲-਀਄਋-਎਑਒਩਱਴਷਺-਽੃-੆੉੊੍-੐੒-੘੝੟-੯੶-઀઄઎઒઩઱઴઺-઼૆૊્-૏૑-૟૤-૸ૺ-଀଄଍଎଑଒଩଱଴଺-଼୅୆୉୊୍-୕୘-୛୞୤-୰୲-஁஄஋-஍஑஖-஘஛஝஠-஢஥-஧஫-஭஺-஽௃-௅௉்-௏௑-௖௘-௿ఄ఍఑఩఺-఼౅౉్-౔౗౛-౟౤-ಀ಄಍಑಩಴಺-಼೅೉್-೔೗-ೝ೟೤-೰ೳ-ഀഄ഍഑഻഼൅൉്൏-ൖ൘-൞൤-൹඀ඁ඄඗-඙඲඼඾඿෇-෎෕෗෠-෱෴-฀฻-฿็-์๎-຀຃຅ຆຉ຋ຌຎ-ຓຘຠ຤຦ຨຩຬ຺຾຿໅໇-໌໎-໛໠-໿༁-༿཈཭-཰ྂ-྇྘྽-࿿့္်၀-၏ၣၤၩ-ၭႇ-ႍႏ-ႛ႞႟჆჈-჌჎჏჻቉቎቏቗቙቞቟኉኎኏኱኶኷኿዁዆዇዗጑጖጗፛-፞፠-፿᎐-᎟᏶᏷᏾-᐀᙭᙮ ᚛-᚟᛫-᛭᛹-᛿ᜍ᜔-ᜟ᜴-᜿᝔-᝟᝭᝱᝴-᝿឴឵៉-៖៘-៛៝-᠟ᡸ-᡿᢫-᢯᣶-᣿᤟᤬-᤯᤹-᥏᥮᥯᥵-᥿᦬-᦯᧊-᧿᨜-᨟᩟᩠᩵-᪦᪨-᫿᬴᭄ᭌ-᭿᮪᮫᮰-᮹᯦᯲-᯿ᰶ-᱌᱐-᱙᱾-᳨᳭᳴᳷-᳿᷀-ᷦ᷵-᷿἖἗἞἟὆὇὎὏὘὚὜὞὾὿᾵᾽᾿-῁῅῍-῏῔῕῜-῟῭-῱῵´-⁰⁲-⁾₀-₏₝-℁℃-℆℈℉℔№-℘℞-℣℥℧℩℮℺℻⅀-⅄⅊-⅍⅏-⅟↉-⒵⓪-⯿Ⱟⱟ⳥-⳪⳯-⳱⳴-⳿⴦⴨-⴬⴮⴯⵨-⵮⵰-⵿⶗-⶟⶧⶯⶷⶿⷇⷏⷗⷟⸀-⸮⸰-〄〈-〠〪-〰〶〷〽-぀゗-゜゠・㄀-㄄ㄮ-㄰㆏-㆟ㆻ-㇯㈀-㏿䶶-䷿鿖-鿿꒍-꓏꓾꓿꘍-꘏꘠-꘩꘬-꘿꙯-꙳꙼-꙾꛰-꜖꜠꜡꞉꞊ꞮꞯꞸ-ꟶꠂ꠆ꠋ꠨-꠿꡴-꡿꣄-꣱꣸-꣺꣼ꣾ-꤉꤫-꤯꥓-꥟꥽-꥿꦳꧀-꧎꧐-꧟ꧥ꧰-꧹꧿꨷-꨿꩎-꩟꩷-꩹ꩻ-ꩽ꪿꫁꫃-꫚꫞꫟꫰꫱꫶-꬀꬇꬈꬏꬐꬗-꬟꬧꬯꭛ꭦ-꭯꯫-꯿힤-힯퟇-퟊퟼-﩮﩯﫚-﫿﬇-﬒﬘-﬜﬩﬷﬽﬿﭂﭅﮲-﯒﴾-﵏﶐﶑﷈-﷯﷼-﹯﹵﻽-＠［-｀｛-･﾿-￁￈￉￐￑￘￙￝-\uffff](?:[^\u0000-\-\/:-@\[-\^`{-©«-±´¶-¸»¿×÷˂-˅˒-˟˥-˫˭˯-̈́͆-ͯ͵͸͹;΀-΅·΋΍΢϶҂-҉԰՗՘՚-ՠֈ-֯־׀׃׆׈-׏׫-ׯ׳-؏؛-؟٘٪-٭۔۝-۠۩-۬۽۾܀-܏݀-݌޲-޿߫-߳߶-߹߻-߿࠘࠙࠭-࠿࡙-࢟ࢵ-࣢࣪-़्࣯॑-॔।॥॰঄঍঎঑঒঩঱঳-঵঺-়৅৆৉৊্৏-৖৘-৛৞৤৥৲৳৺-਀਄਋-਎਑਒਩਱਴਷਺-਽੃-੆੉੊੍-੐੒-੘੝੟-੥੶-઀઄઎઒઩઱઴઺-઼૆૊્-૏૑-૟૤૥૰-૸ૺ-଀଄଍଎଑଒଩଱଴଺-଼୅୆୉୊୍-୕୘-୛୞୤୥୰୸-஁஄஋-஍஑஖-஘஛஝஠-஢஥-஧஫-஭஺-஽௃-௅௉்-௏௑-௖௘-௥௳-௿ఄ఍఑఩఺-఼౅౉్-౔౗౛-౟౤౥౰-౷౿ಀ಄಍಑಩಴಺-಼೅೉್-೔೗-ೝ೟೤೥೰ೳ-ഀഄ഍഑഻഼൅൉്൏-ൖ൘-൞൤൥൶-൹඀ඁ඄඗-඙඲඼඾඿෇-෎෕෗෠-෥෰෱෴-฀฻-฿็-์๎๏๚-຀຃຅ຆຉ຋ຌຎ-ຓຘຠ຤຦ຨຩຬ຺຾຿໅໇-໌໎໏໚໛໠-໿༁-༟༴-༿཈཭-཰ྂ-྇྘྽-࿿့္်၊-၏ၣၤၩ-ၭႇ-ႍႏႚႛ႞႟჆჈-჌჎჏჻቉቎቏቗቙቞቟኉኎኏኱኶኷኿዁዆዇዗጑጖጗፛-፞፠-፨፽-፿᎐-᎟᏶᏷᏾-᐀᙭᙮ ᚛-᚟᛫-᛭᛹-᛿ᜍ᜔-ᜟ᜴-᜿᝔-᝟᝭᝱᝴-᝿឴឵៉-៖៘-៛៝-៟៪-៯៺-᠏᠚-᠟ᡸ-᡿᢫-᢯᣶-᣿᤟᤬-᤯᤹-᥅᥮᥯᥵-᥿᦬-᦯᧊-᧏᧛-᧿᨜-᨟᩟᩠᩵-᩿᪊-᪏᪚-᪦᪨-᫿᬴᭄ᭌ-᭏᭚-᭿᯦᮪᮫᯲-᯿ᰶ-᰿᱊-᱌᱾-᳨᳭᳴᳷-᳿᷀-ᷦ᷵-᷿἖἗἞἟὆὇὎὏὘὚὜὞὾὿᾵᾽᾿-῁῅῍-῏῔῕῜-῟῭-῱῵´-⁯⁲⁳⁺-⁾₊-₏₝-℁℃-℆℈℉℔№-℘℞-℣℥℧℩℮℺℻⅀-⅄⅊-⅍⅏↊-⑟⒜-⒵─-❵➔-⯿Ⱟⱟ⳥-⳪⳯-⳱⳴-⳼⳾⳿⴦⴨-⴬⴮⴯⵨-⵮⵰-⵿⶗-⶟⶧⶯⶷⶿⷇⷏⷗⷟⸀-⸮⸰-〄〈-〠〪-〰〶〷〽-぀゗-゜゠・㄀-㄄ㄮ-㄰㆏-㆑㆖-㆟ㆻ-㇯㈀-㈟㈪-㉇㉐㉠-㉿㊊-㊰㋀-㏿䶶-䷿鿖-鿿꒍-꓏꓾꓿꘍-꘏꘬-꘿꙯-꙳꙼-꙾꛰-꜖꜠꜡꞉꞊ꞮꞯꞸ-ꟶꠂ꠆ꠋ꠨-꠯꠶-꠿꡴-꡿꣄-꣏꣚-꣱꣸-꣺꣼ꣾꣿ꤫-꤯꥓-꥟꥽-꥿꦳꧀-꧎꧚-꧟ꧥ꧿꨷-꨿꩎꩏꩚-꩟꩷-꩹ꩻ-ꩽ꪿꫁꫃-꫚꫞꫟꫰꫱꫶-꬀꬇꬈꬏꬐꬗-꬟꬧꬯꭛ꭦ-꭯꯫-꯯꯺-꯿힤-힯퟇-퟊퟼-﩮﩯﫚-﫿﬇-﬒﬘-﬜﬩﬷﬽﬿﭂﭅﮲-﯒﴾-﵏﶐﶑﷈-﷯﷼-﹯﹵﻽-／：-＠［-｀｛-･﾿-￁￈￉￐￑￘￙￝-\uffff]*[^\u0000-\/:-@\[-\^`{-©«-±´¶-¸»¿×÷˂-˅˒-˟˥-˫˭˯-̈́͆-ͯ͵͸͹;΀-΅·΋΍΢϶҂-҉԰՗՘՚-ՠֈ-֯־׀׃׆׈-׏׫-ׯ׳-؏؛-؟٘٪-٭۔۝-۠۩-۬۽۾܀-܏݀-݌޲-޿߫-߳߶-߹߻-߿࠘࠙࠭-࠿࡙-࢟ࢵ-࣢࣪-़्࣯॑-॔।॥॰঄঍঎঑঒঩঱঳-঵঺-়৅৆৉৊্৏-৖৘-৛৞৤৥৲৳৺-਀਄਋-਎਑਒਩਱਴਷਺-਽੃-੆੉੊੍-੐੒-੘੝੟-੥੶-઀઄઎઒઩઱઴઺-઼૆૊્-૏૑-૟૤૥૰-૸ૺ-଀଄଍଎଑଒଩଱଴଺-଼୅୆୉୊୍-୕୘-୛୞୤୥୰୸-஁஄஋-஍஑஖-஘஛஝஠-஢஥-஧஫-஭஺-஽௃-௅௉்-௏௑-௖௘-௥௳-௿ఄ఍఑఩఺-఼౅౉్-౔౗౛-౟౤౥౰-౷౿ಀ಄಍಑಩಴಺-಼೅೉್-೔೗-ೝ೟೤೥೰ೳ-ഀഄ഍഑഻഼൅൉്൏-ൖ൘-൞൤൥൶-൹඀ඁ඄඗-඙඲඼඾඿෇-෎෕෗෠-෥෰෱෴-฀฻-฿็-์๎๏๚-຀຃຅ຆຉ຋ຌຎ-ຓຘຠ຤຦ຨຩຬ຺຾຿໅໇-໌໎໏໚໛໠-໿༁-༟༴-༿཈཭-཰ྂ-྇྘྽-࿿့္်၊-၏ၣၤၩ-ၭႇ-ႍႏႚႛ႞႟჆჈-჌჎჏჻቉቎቏቗቙቞቟኉኎኏኱኶኷኿዁዆዇዗጑጖጗፛-፞፠-፨፽-፿᎐-᎟᏶᏷᏾-᐀᙭᙮ ᚛-᚟᛫-᛭᛹-᛿ᜍ᜔-ᜟ᜴-᜿᝔-᝟᝭᝱᝴-᝿឴឵៉-៖៘-៛៝-៟៪-៯៺-᠏᠚-᠟ᡸ-᡿᢫-᢯᣶-᣿᤟᤬-᤯᤹-᥅᥮᥯᥵-᥿᦬-᦯᧊-᧏᧛-᧿᨜-᨟᩟᩠᩵-᩿᪊-᪏᪚-᪦᪨-᫿᬴᭄ᭌ-᭏᭚-᭿᯦᮪᮫᯲-᯿ᰶ-᰿᱊-᱌᱾-᳨᳭᳴᳷-᳿᷀-ᷦ᷵-᷿἖἗἞἟὆὇὎὏὘὚὜὞὾὿᾵᾽᾿-῁῅῍-῏῔῕῜-῟῭-῱῵´-⁯⁲⁳⁺-⁾₊-₏₝-℁℃-℆℈℉℔№-℘℞-℣℥℧℩℮℺℻⅀-⅄⅊-⅍⅏↊-⑟⒜-⒵─-❵➔-⯿Ⱟⱟ⳥-⳪⳯-⳱⳴-⳼⳾⳿⴦⴨-⴬⴮⴯⵨-⵮⵰-⵿⶗-⶟⶧⶯⶷⶿⷇⷏⷗⷟⸀-⸮⸰-〄〈-〠〪-〰〶〷〽-぀゗-゜゠・㄀-㄄ㄮ-㄰㆏-㆑㆖-㆟ㆻ-㇯㈀-㈟㈪-㉇㉐㉠-㉿㊊-㊰㋀-㏿䶶-䷿鿖-鿿꒍-꓏꓾꓿꘍-꘏꘬-꘿꙯-꙳꙼-꙾꛰-꜖꜠꜡꞉꞊ꞮꞯꞸ-ꟶꠂ꠆ꠋ꠨-꠯꠶-꠿꡴-꡿꣄-꣏꣚-꣱꣸-꣺꣼ꣾꣿ꤫-꤯꥓-꥟꥽-꥿꦳꧀-꧎꧚-꧟ꧥ꧿꨷-꨿꩎꩏꩚-꩟꩷-꩹ꩻ-ꩽ꪿꫁꫃-꫚꫞꫟꫰꫱꫶-꬀꬇꬈꬏꬐꬗-꬟꬧꬯꭛ꭦ-꭯꯫-꯯꯺-꯿힤-힯퟇-퟊퟼-﩮﩯﫚-﫿﬇-﬒﬘-﬜﬩﬷﬽﬿﭂﭅﮲-﯒﴾-﵏﶐﶑﷈-﷯﷼-﹯﹵﻽-／：-＠［-｀｛-･﾿-￁￈￉￐￑￘￙￝-\uffff])?)(?=\s*\())/,
/^(?:([0-9]+[!])?([$])?[^\u0000-\u001f!-\/:-@\[-\^`{-©«-±´¶-¸»¿×÷˂-˅˒-˟˥-˫˭˯-̈́͆-ͯ͵͸͹;΀-΅·΋΍΢϶҂-҉԰՗՘՚-ՠֈ-֯־׀׃׆׈-׏׫-ׯ׳-؏؛-؟٘٪-٭۔۝-۠۩-۬۽۾܀-܏݀-݌޲-޿߫-߳߶-߹߻-߿࠘࠙࠭-࠿࡙-࢟ࢵ-࣢࣪-़्࣯॑-॔।॥॰঄঍঎঑঒঩঱঳-঵঺-়৅৆৉৊্৏-৖৘-৛৞৤৥৲৳৺-਀਄਋-਎਑਒਩਱਴਷਺-਽੃-੆੉੊੍-੐੒-੘੝੟-੥੶-઀઄઎઒઩઱઴઺-઼૆૊્-૏૑-૟૤૥૰-૸ૺ-଀଄଍଎଑଒଩଱଴଺-଼୅୆୉୊୍-୕୘-୛୞୤୥୰୸-஁஄஋-஍஑஖-஘஛஝஠-஢஥-஧஫-஭஺-஽௃-௅௉்-௏௑-௖௘-௥௳-௿ఄ఍఑఩఺-఼౅౉్-౔౗౛-౟౤౥౰-౷౿ಀ಄಍಑಩಴಺-಼೅೉್-೔೗-ೝ೟೤೥೰ೳ-ഀഄ഍഑഻഼൅൉്൏-ൖ൘-൞൤൥൶-൹඀ඁ඄඗-඙඲඼඾඿෇-෎෕෗෠-෥෰෱෴-฀฻-฿็-์๎๏๚-຀຃຅ຆຉ຋ຌຎ-ຓຘຠ຤຦ຨຩຬ຺຾຿໅໇-໌໎໏໚໛໠-໿༁-༟༴-༿཈཭-཰ྂ-྇྘྽-࿿့္်၊-၏ၣၤၩ-ၭႇ-ႍႏႚႛ႞႟჆჈-჌჎჏჻቉቎቏቗቙቞቟኉኎኏኱኶኷኿዁዆዇዗጑጖጗፛-፞፠-፨፽-፿᎐-᎟᏶᏷᏾-᐀᙭᙮ ᚛-᚟᛫-᛭᛹-᛿ᜍ᜔-ᜟ᜴-᜿᝔-᝟᝭᝱᝴-᝿឴឵៉-៖៘-៛៝-៟៪-៯៺-᠏᠚-᠟ᡸ-᡿᢫-᢯᣶-᣿᤟᤬-᤯᤹-᥅᥮᥯᥵-᥿᦬-᦯᧊-᧏᧛-᧿᨜-᨟᩟᩠᩵-᩿᪊-᪏᪚-᪦᪨-᫿᬴᭄ᭌ-᭏᭚-᭿᯦᮪᮫᯲-᯿ᰶ-᰿᱊-᱌᱾-᳨᳭᳴᳷-᳿᷀-ᷦ᷵-᷿἖἗἞἟὆὇὎὏὘὚὜὞὾὿᾵᾽᾿-῁῅῍-῏῔῕῜-῟῭-῱῵´-⁯⁲⁳⁺-⁾₊-₏₝-℁℃-℆℈℉℔№-℘℞-℣℥℧℩℮℺℻⅀-⅄⅊-⅍⅏↊-⑟⒜-⒵─-❵➔-⯿Ⱟⱟ⳥-⳪⳯-⳱⳴-⳼⳾⳿⴦⴨-⴬⴮⴯⵨-⵮⵰-⵿⶗-⶟⶧⶯⶷⶿⷇⷏⷗⷟⸀-⸮⸰-〄〈-〠〪-〰〶〷〽-぀゗-゜゠・㄀-㄄ㄮ-㄰㆏-㆑㆖-㆟ㆻ-㇯㈀-㈟㈪-㉇㉐㉠-㉿㊊-㊰㋀-㏿䶶-䷿鿖-鿿꒍-꓏꓾꓿꘍-꘏꘬-꘿꙯-꙳꙼-꙾꛰-꜖꜠꜡꞉꞊ꞮꞯꞸ-ꟶꠂ꠆ꠋ꠨-꠯꠶-꠿꡴-꡿꣄-꣏꣚-꣱꣸-꣺꣼ꣾꣿ꤫-꤯꥓-꥟꥽-꥿꦳꧀-꧎꧚-꧟ꧥ꧿꨷-꨿꩎꩏꩚-꩟꩷-꩹ꩻ-ꩽ꪿꫁꫃-꫚꫞꫟꫰꫱꫶-꬀꬇꬈꬏꬐꬗-꬟꬧꬯꭛ꭦ-꭯꯫-꯯꯺-꯿힤-힯퟇-퟊퟼-﩮﩯﫚-﫿﬇-﬒﬘-﬜﬩﬷﬽﬿﭂﭅﮲-﯒﴾-﵏﶐﶑﷈-﷯﷼-﹯﹵﻽-／：-＠［-｀｛-･﾿-￁￈￉￐￑￘￙￝-\uffff]+\[([$])?[^\u0000-\u001f!-\/:-@\[-\^`{-©«-±´¶-¸»¿×÷˂-˅˒-˟˥-˫˭˯-̈́͆-ͯ͵͸͹;΀-΅·΋΍΢϶҂-҉԰՗՘՚-ՠֈ-֯־׀׃׆׈-׏׫-ׯ׳-؏؛-؟٘٪-٭۔۝-۠۩-۬۽۾܀-܏݀-݌޲-޿߫-߳߶-߹߻-߿࠘࠙࠭-࠿࡙-࢟ࢵ-࣢࣪-़्࣯॑-॔।॥॰঄঍঎঑঒঩঱঳-঵঺-়৅৆৉৊্৏-৖৘-৛৞৤৥৲৳৺-਀਄਋-਎਑਒਩਱਴਷਺-਽੃-੆੉੊੍-੐੒-੘੝੟-੥੶-઀઄઎઒઩઱઴઺-઼૆૊્-૏૑-૟૤૥૰-૸ૺ-଀଄଍଎଑଒଩଱଴଺-଼୅୆୉୊୍-୕୘-୛୞୤୥୰୸-஁஄஋-஍஑஖-஘஛஝஠-஢஥-஧஫-஭஺-஽௃-௅௉்-௏௑-௖௘-௥௳-௿ఄ఍఑఩఺-఼౅౉్-౔౗౛-౟౤౥౰-౷౿ಀ಄಍಑಩಴಺-಼೅೉್-೔೗-ೝ೟೤೥೰ೳ-ഀഄ഍഑഻഼൅൉്൏-ൖ൘-൞൤൥൶-൹඀ඁ඄඗-඙඲඼඾඿෇-෎෕෗෠-෥෰෱෴-฀฻-฿็-์๎๏๚-຀຃຅ຆຉ຋ຌຎ-ຓຘຠ຤຦ຨຩຬ຺຾຿໅໇-໌໎໏໚໛໠-໿༁-༟༴-༿཈཭-཰ྂ-྇྘྽-࿿့္်၊-၏ၣၤၩ-ၭႇ-ႍႏႚႛ႞႟჆჈-჌჎჏჻቉቎቏቗቙቞቟኉኎኏኱኶኷኿዁዆዇዗጑጖጗፛-፞፠-፨፽-፿᎐-᎟᏶᏷᏾-᐀᙭᙮ ᚛-᚟᛫-᛭᛹-᛿ᜍ᜔-ᜟ᜴-᜿᝔-᝟᝭᝱᝴-᝿឴឵៉-៖៘-៛៝-៟៪-៯៺-᠏᠚-᠟ᡸ-᡿᢫-᢯᣶-᣿᤟᤬-᤯᤹-᥅᥮᥯᥵-᥿᦬-᦯᧊-᧏᧛-᧿᨜-᨟᩟᩠᩵-᩿᪊-᪏᪚-᪦᪨-᫿᬴᭄ᭌ-᭏᭚-᭿᯦᮪᮫᯲-᯿ᰶ-᰿᱊-᱌᱾-᳨᳭᳴᳷-᳿᷀-ᷦ᷵-᷿἖἗἞἟὆὇὎὏὘὚὜὞὾὿᾵᾽᾿-῁῅῍-῏῔῕῜-῟῭-῱῵´-⁯⁲⁳⁺-⁾₊-₏₝-℁℃-℆℈℉℔№-℘℞-℣℥℧℩℮℺℻⅀-⅄⅊-⅍⅏↊-⑟⒜-⒵─-❵➔-⯿Ⱟⱟ⳥-⳪⳯-⳱⳴-⳼⳾⳿⴦⴨-⴬⴮⴯⵨-⵮⵰-⵿⶗-⶟⶧⶯⶷⶿⷇⷏⷗⷟⸀-⸮⸰-〄〈-〠〪-〰〶〷〽-぀゗-゜゠・㄀-㄄ㄮ-㄰㆏-㆑㆖-㆟ㆻ-㇯㈀-㈟㈪-㉇㉐㉠-㉿㊊-㊰㋀-㏿䶶-䷿鿖-鿿꒍-꓏꓾꓿꘍-꘏꘬-꘿꙯-꙳꙼-꙾꛰-꜖꜠꜡꞉꞊ꞮꞯꞸ-ꟶꠂ꠆ꠋ꠨-꠯꠶-꠿꡴-꡿꣄-꣏꣚-꣱꣸-꣺꣼ꣾꣿ꤫-꤯꥓-꥟꥽-꥿꦳꧀-꧎꧚-꧟ꧥ꧿꨷-꨿꩎꩏꩚-꩟꩷-꩹ꩻ-ꩽ꪿꫁꫃-꫚꫞꫟꫰꫱꫶-꬀꬇꬈꬏꬐꬗-꬟꬧꬯꭛ꭦ-꭯꯫-꯯꯺-꯿힤-힯퟇-퟊퟼-﩮﩯﫚-﫿﬇-﬒﬘-﬜﬩﬷﬽﬿﭂﭅﮲-﯒﴾-﵏﶐﶑﷈-﷯﷼-﹯﹵﻽-／：-＠［-｀｛-･﾿-￁￈￉￐￑￘￙￝-\uffff]+\][:]([0-9]+[!])?([$])?[^\u0000-\u001f!-\/:-@\[-\^`{-©«-±´¶-¸»¿×÷˂-˅˒-˟˥-˫˭˯-̈́͆-ͯ͵͸͹;΀-΅·΋΍΢϶҂-҉԰՗՘՚-ՠֈ-֯־׀׃׆׈-׏׫-ׯ׳-؏؛-؟٘٪-٭۔۝-۠۩-۬۽۾܀-܏݀-݌޲-޿߫-߳߶-߹߻-߿࠘࠙࠭-࠿࡙-࢟ࢵ-࣢࣪-़्࣯॑-॔।॥॰঄঍঎঑঒঩঱঳-঵঺-়৅৆৉৊্৏-৖৘-৛৞৤৥৲৳৺-਀਄਋-਎਑਒਩਱਴਷਺-਽੃-੆੉੊੍-੐੒-੘੝੟-੥੶-઀઄઎઒઩઱઴઺-઼૆૊્-૏૑-૟૤૥૰-૸ૺ-଀଄଍଎଑଒଩଱଴଺-଼୅୆୉୊୍-୕୘-୛୞୤୥୰୸-஁஄஋-஍஑஖-஘஛஝஠-஢஥-஧஫-஭஺-஽௃-௅௉்-௏௑-௖௘-௥௳-௿ఄ఍఑఩఺-఼౅౉్-౔౗౛-౟౤౥౰-౷౿ಀ಄಍಑಩಴಺-಼೅೉್-೔೗-ೝ೟೤೥೰ೳ-ഀഄ഍഑഻഼൅൉്൏-ൖ൘-൞൤൥൶-൹඀ඁ඄඗-඙඲඼඾඿෇-෎෕෗෠-෥෰෱෴-฀฻-฿็-์๎๏๚-຀຃຅ຆຉ຋ຌຎ-ຓຘຠ຤຦ຨຩຬ຺຾຿໅໇-໌໎໏໚໛໠-໿༁-༟༴-༿཈཭-཰ྂ-྇྘྽-࿿့္်၊-၏ၣၤၩ-ၭႇ-ႍႏႚႛ႞႟჆჈-჌჎჏჻቉቎቏቗቙቞቟኉኎኏኱኶኷኿዁዆዇዗጑጖጗፛-፞፠-፨፽-፿᎐-᎟᏶᏷᏾-᐀᙭᙮ ᚛-᚟᛫-᛭᛹-᛿ᜍ᜔-ᜟ᜴-᜿᝔-᝟᝭᝱᝴-᝿឴឵៉-៖៘-៛៝-៟៪-៯៺-᠏᠚-᠟ᡸ-᡿᢫-᢯᣶-᣿᤟᤬-᤯᤹-᥅᥮᥯᥵-᥿᦬-᦯᧊-᧏᧛-᧿᨜-᨟᩟᩠᩵-᩿᪊-᪏᪚-᪦᪨-᫿᬴᭄ᭌ-᭏᭚-᭿᯦᮪᮫᯲-᯿ᰶ-᰿᱊-᱌᱾-᳨᳭᳴᳷-᳿᷀-ᷦ᷵-᷿἖἗἞἟὆὇὎὏὘὚὜὞὾὿᾵᾽᾿-῁῅῍-῏῔῕῜-῟῭-῱῵´-⁯⁲⁳⁺-⁾₊-₏₝-℁℃-℆℈℉℔№-℘℞-℣℥℧℩℮℺℻⅀-⅄⅊-⅍⅏↊-⑟⒜-⒵─-❵➔-⯿Ⱟⱟ⳥-⳪⳯-⳱⳴-⳼⳾⳿⴦⴨-⴬⴮⴯⵨-⵮⵰-⵿⶗-⶟⶧⶯⶷⶿⷇⷏⷗⷟⸀-⸮⸰-〄〈-〠〪-〰〶〷〽-぀゗-゜゠・㄀-㄄ㄮ-㄰㆏-㆑㆖-㆟ㆻ-㇯㈀-㈟㈪-㉇㉐㉠-㉿㊊-㊰㋀-㏿䶶-䷿鿖-鿿꒍-꓏꓾꓿꘍-꘏꘬-꘿꙯-꙳꙼-꙾꛰-꜖꜠꜡꞉꞊ꞮꞯꞸ-ꟶꠂ꠆ꠋ꠨-꠯꠶-꠿꡴-꡿꣄-꣏꣚-꣱꣸-꣺꣼ꣾꣿ꤫-꤯꥓-꥟꥽-꥿꦳꧀-꧎꧚-꧟ꧥ꧿꨷-꨿꩎꩏꩚-꩟꩷-꩹ꩻ-ꩽ꪿꫁꫃-꫚꫞꫟꫰꫱꫶-꬀꬇꬈꬏꬐꬗-꬟꬧꬯꭛ꭦ-꭯꯫-꯯꯺-꯿힤-힯퟇-퟊퟼-﩮﩯﫚-﫿﬇-﬒﬘-﬜﬩﬷﬽﬿﭂﭅﮲-﯒﴾-﵏﶐﶑﷈-﷯﷼-﹯﹵﻽-／：-＠［-｀｛-･﾿-￁￈￉￐￑￘￙￝-\uffff]+\[([$])?[^\u0000-\u001f!-\/:-@\[-\^`{-©«-±´¶-¸»¿×÷˂-˅˒-˟˥-˫˭˯-̈́͆-ͯ͵͸͹;΀-΅·΋΍΢϶҂-҉԰՗՘՚-ՠֈ-֯־׀׃׆׈-׏׫-ׯ׳-؏؛-؟٘٪-٭۔۝-۠۩-۬۽۾܀-܏݀-݌޲-޿߫-߳߶-߹߻-߿࠘࠙࠭-࠿࡙-࢟ࢵ-࣢࣪-़्࣯॑-॔।॥॰঄঍঎঑঒঩঱঳-঵঺-়৅৆৉৊্৏-৖৘-৛৞৤৥৲৳৺-਀਄਋-਎਑਒਩਱਴਷਺-਽੃-੆੉੊੍-੐੒-੘੝੟-੥੶-઀઄઎઒઩઱઴઺-઼૆૊્-૏૑-૟૤૥૰-૸ૺ-଀଄଍଎଑଒଩଱଴଺-଼୅୆୉୊୍-୕୘-୛୞୤୥୰୸-஁஄஋-஍஑஖-஘஛஝஠-஢஥-஧஫-஭஺-஽௃-௅௉்-௏௑-௖௘-௥௳-௿ఄ఍఑఩఺-఼౅౉్-౔౗౛-౟౤౥౰-౷౿ಀ಄಍಑಩಴಺-಼೅೉್-೔೗-ೝ೟೤೥೰ೳ-ഀഄ഍഑഻഼൅൉്൏-ൖ൘-൞൤൥൶-൹඀ඁ඄඗-඙඲඼඾඿෇-෎෕෗෠-෥෰෱෴-฀฻-฿็-์๎๏๚-຀຃຅ຆຉ຋ຌຎ-ຓຘຠ຤຦ຨຩຬ຺຾຿໅໇-໌໎໏໚໛໠-໿༁-༟༴-༿཈཭-཰ྂ-྇྘྽-࿿့္်၊-၏ၣၤၩ-ၭႇ-ႍႏႚႛ႞႟჆჈-჌჎჏჻቉቎቏቗቙቞቟኉኎኏኱኶኷኿዁዆዇዗጑጖጗፛-፞፠-፨፽-፿᎐-᎟᏶᏷᏾-᐀᙭᙮ ᚛-᚟᛫-᛭᛹-᛿ᜍ᜔-ᜟ᜴-᜿᝔-᝟᝭᝱᝴-᝿឴឵៉-៖៘-៛៝-៟៪-៯៺-᠏᠚-᠟ᡸ-᡿᢫-᢯᣶-᣿᤟᤬-᤯᤹-᥅᥮᥯᥵-᥿᦬-᦯᧊-᧏᧛-᧿᨜-᨟᩟᩠᩵-᩿᪊-᪏᪚-᪦᪨-᫿᬴᭄ᭌ-᭏᭚-᭿᯦᮪᮫᯲-᯿ᰶ-᰿᱊-᱌᱾-᳨᳭᳴᳷-᳿᷀-ᷦ᷵-᷿἖἗἞἟὆὇὎὏὘὚὜὞὾὿᾵᾽᾿-῁῅῍-῏῔῕῜-῟῭-῱῵´-⁯⁲⁳⁺-⁾₊-₏₝-℁℃-℆℈℉℔№-℘℞-℣℥℧℩℮℺℻⅀-⅄⅊-⅍⅏↊-⑟⒜-⒵─-❵➔-⯿Ⱟⱟ⳥-⳪⳯-⳱⳴-⳼⳾⳿⴦⴨-⴬⴮⴯⵨-⵮⵰-⵿⶗-⶟⶧⶯⶷⶿⷇⷏⷗⷟⸀-⸮⸰-〄〈-〠〪-〰〶〷〽-぀゗-゜゠・㄀-㄄ㄮ-㄰㆏-㆑㆖-㆟ㆻ-㇯㈀-㈟㈪-㉇㉐㉠-㉿㊊-㊰㋀-㏿䶶-䷿鿖-鿿꒍-꓏꓾꓿꘍-꘏꘬-꘿꙯-꙳꙼-꙾꛰-꜖꜠꜡꞉꞊ꞮꞯꞸ-ꟶꠂ꠆ꠋ꠨-꠯꠶-꠿꡴-꡿꣄-꣏꣚-꣱꣸-꣺꣼ꣾꣿ꤫-꤯꥓-꥟꥽-꥿꦳꧀-꧎꧚-꧟ꧥ꧿꨷-꨿꩎꩏꩚-꩟꩷-꩹ꩻ-ꩽ꪿꫁꫃-꫚꫞꫟꫰꫱꫶-꬀꬇꬈꬏꬐꬗-꬟꬧꬯꭛ꭦ-꭯꯫-꯯꯺-꯿힤-힯퟇-퟊퟼-﩮﩯﫚-﫿﬇-﬒﬘-﬜﬩﬷﬽﬿﭂﭅﮲-﯒﴾-﵏﶐﶑﷈-﷯﷼-﹯﹵﻽-／：-＠［-｀｛-･﾿-￁￈￉￐￑￘￙￝-\uffff]+\])/,
/^(?:([0-9]+[!])?([$])?[^\u0000-\u001f!-\/:-@\[-\^`{-©«-±´¶-¸»¿×÷˂-˅˒-˟˥-˫˭˯-̈́͆-ͯ͵͸͹;΀-΅·΋΍΢϶҂-҉԰՗՘՚-ՠֈ-֯־׀׃׆׈-׏׫-ׯ׳-؏؛-؟٘٪-٭۔۝-۠۩-۬۽۾܀-܏݀-݌޲-޿߫-߳߶-߹߻-߿࠘࠙࠭-࠿࡙-࢟ࢵ-࣢࣪-़्࣯॑-॔।॥॰঄঍঎঑঒঩঱঳-঵঺-়৅৆৉৊্৏-৖৘-৛৞৤৥৲৳৺-਀਄਋-਎਑਒਩਱਴਷਺-਽੃-੆੉੊੍-੐੒-੘੝੟-੥੶-઀઄઎઒઩઱઴઺-઼૆૊્-૏૑-૟૤૥૰-૸ૺ-଀଄଍଎଑଒଩଱଴଺-଼୅୆୉୊୍-୕୘-୛୞୤୥୰୸-஁஄஋-஍஑஖-஘஛஝஠-஢஥-஧஫-஭஺-஽௃-௅௉்-௏௑-௖௘-௥௳-௿ఄ఍఑఩఺-఼౅౉్-౔౗౛-౟౤౥౰-౷౿ಀ಄಍಑಩಴಺-಼೅೉್-೔೗-ೝ೟೤೥೰ೳ-ഀഄ഍഑഻഼൅൉്൏-ൖ൘-൞൤൥൶-൹඀ඁ඄඗-඙඲඼඾඿෇-෎෕෗෠-෥෰෱෴-฀฻-฿็-์๎๏๚-຀຃຅ຆຉ຋ຌຎ-ຓຘຠ຤຦ຨຩຬ຺຾຿໅໇-໌໎໏໚໛໠-໿༁-༟༴-༿཈཭-཰ྂ-྇྘྽-࿿့္်၊-၏ၣၤၩ-ၭႇ-ႍႏႚႛ႞႟჆჈-჌჎჏჻቉቎቏቗቙቞቟኉኎኏኱኶኷኿዁዆዇዗጑጖጗፛-፞፠-፨፽-፿᎐-᎟᏶᏷᏾-᐀᙭᙮ ᚛-᚟᛫-᛭᛹-᛿ᜍ᜔-ᜟ᜴-᜿᝔-᝟᝭᝱᝴-᝿឴឵៉-៖៘-៛៝-៟៪-៯៺-᠏᠚-᠟ᡸ-᡿᢫-᢯᣶-᣿᤟᤬-᤯᤹-᥅᥮᥯᥵-᥿᦬-᦯᧊-᧏᧛-᧿᨜-᨟᩟᩠᩵-᩿᪊-᪏᪚-᪦᪨-᫿᬴᭄ᭌ-᭏᭚-᭿᯦᮪᮫᯲-᯿ᰶ-᰿᱊-᱌᱾-᳨᳭᳴᳷-᳿᷀-ᷦ᷵-᷿἖἗἞἟὆὇὎὏὘὚὜὞὾὿᾵᾽᾿-῁῅῍-῏῔῕῜-῟῭-῱῵´-⁯⁲⁳⁺-⁾₊-₏₝-℁℃-℆℈℉℔№-℘℞-℣℥℧℩℮℺℻⅀-⅄⅊-⅍⅏↊-⑟⒜-⒵─-❵➔-⯿Ⱟⱟ⳥-⳪⳯-⳱⳴-⳼⳾⳿⴦⴨-⴬⴮⴯⵨-⵮⵰-⵿⶗-⶟⶧⶯⶷⶿⷇⷏⷗⷟⸀-⸮⸰-〄〈-〠〪-〰〶〷〽-぀゗-゜゠・㄀-㄄ㄮ-㄰㆏-㆑㆖-㆟ㆻ-㇯㈀-㈟㈪-㉇㉐㉠-㉿㊊-㊰㋀-㏿䶶-䷿鿖-鿿꒍-꓏꓾꓿꘍-꘏꘬-꘿꙯-꙳꙼-꙾꛰-꜖꜠꜡꞉꞊ꞮꞯꞸ-ꟶꠂ꠆ꠋ꠨-꠯꠶-꠿꡴-꡿꣄-꣏꣚-꣱꣸-꣺꣼ꣾꣿ꤫-꤯꥓-꥟꥽-꥿꦳꧀-꧎꧚-꧟ꧥ꧿꨷-꨿꩎꩏꩚-꩟꩷-꩹ꩻ-ꩽ꪿꫁꫃-꫚꫞꫟꫰꫱꫶-꬀꬇꬈꬏꬐꬗-꬟꬧꬯꭛ꭦ-꭯꯫-꯯꯺-꯿힤-힯퟇-퟊퟼-﩮﩯﫚-﫿﬇-﬒﬘-﬜﬩﬷﬽﬿﭂﭅﮲-﯒﴾-﵏﶐﶑﷈-﷯﷼-﹯﹵﻽-／：-＠［-｀｛-･﾿-￁￈￉￐￑￘￙￝-\uffff]+\[([$])?[^\u0000-\u001f!-\/:-@\[-\^`{-©«-±´¶-¸»¿×÷˂-˅˒-˟˥-˫˭˯-̈́͆-ͯ͵͸͹;΀-΅·΋΍΢϶҂-҉԰՗՘՚-ՠֈ-֯־׀׃׆׈-׏׫-ׯ׳-؏؛-؟٘٪-٭۔۝-۠۩-۬۽۾܀-܏݀-݌޲-޿߫-߳߶-߹߻-߿࠘࠙࠭-࠿࡙-࢟ࢵ-࣢࣪-़्࣯॑-॔।॥॰঄঍঎঑঒঩঱঳-঵঺-়৅৆৉৊্৏-৖৘-৛৞৤৥৲৳৺-਀਄਋-਎਑਒਩਱਴਷਺-਽੃-੆੉੊੍-੐੒-੘੝੟-੥੶-઀઄઎઒઩઱઴઺-઼૆૊્-૏૑-૟૤૥૰-૸ૺ-଀଄଍଎଑଒଩଱଴଺-଼୅୆୉୊୍-୕୘-୛୞୤୥୰୸-஁஄஋-஍஑஖-஘஛஝஠-஢஥-஧஫-஭஺-஽௃-௅௉்-௏௑-௖௘-௥௳-௿ఄ఍఑఩఺-఼౅౉్-౔౗౛-౟౤౥౰-౷౿ಀ಄಍಑಩಴಺-಼೅೉್-೔೗-ೝ೟೤೥೰ೳ-ഀഄ഍഑഻഼൅൉്൏-ൖ൘-൞൤൥൶-൹඀ඁ඄඗-඙඲඼඾඿෇-෎෕෗෠-෥෰෱෴-฀฻-฿็-์๎๏๚-຀຃຅ຆຉ຋ຌຎ-ຓຘຠ຤຦ຨຩຬ຺຾຿໅໇-໌໎໏໚໛໠-໿༁-༟༴-༿཈཭-཰ྂ-྇྘྽-࿿့္်၊-၏ၣၤၩ-ၭႇ-ႍႏႚႛ႞႟჆჈-჌჎჏჻቉቎቏቗቙቞቟኉኎኏኱኶኷኿዁዆዇዗጑጖጗፛-፞፠-፨፽-፿᎐-᎟᏶᏷᏾-᐀᙭᙮ ᚛-᚟᛫-᛭᛹-᛿ᜍ᜔-ᜟ᜴-᜿᝔-᝟᝭᝱᝴-᝿឴឵៉-៖៘-៛៝-៟៪-៯៺-᠏᠚-᠟ᡸ-᡿᢫-᢯᣶-᣿᤟᤬-᤯᤹-᥅᥮᥯᥵-᥿᦬-᦯᧊-᧏᧛-᧿᨜-᨟᩟᩠᩵-᩿᪊-᪏᪚-᪦᪨-᫿᬴᭄ᭌ-᭏᭚-᭿᯦᮪᮫᯲-᯿ᰶ-᰿᱊-᱌᱾-᳨᳭᳴᳷-᳿᷀-ᷦ᷵-᷿἖἗἞἟὆὇὎὏὘὚὜὞὾὿᾵᾽᾿-῁῅῍-῏῔῕῜-῟῭-῱῵´-⁯⁲⁳⁺-⁾₊-₏₝-℁℃-℆℈℉℔№-℘℞-℣℥℧℩℮℺℻⅀-⅄⅊-⅍⅏↊-⑟⒜-⒵─-❵➔-⯿Ⱟⱟ⳥-⳪⳯-⳱⳴-⳼⳾⳿⴦⴨-⴬⴮⴯⵨-⵮⵰-⵿⶗-⶟⶧⶯⶷⶿⷇⷏⷗⷟⸀-⸮⸰-〄〈-〠〪-〰〶〷〽-぀゗-゜゠・㄀-㄄ㄮ-㄰㆏-㆑㆖-㆟ㆻ-㇯㈀-㈟㈪-㉇㉐㉠-㉿㊊-㊰㋀-㏿䶶-䷿鿖-鿿꒍-꓏꓾꓿꘍-꘏꘬-꘿꙯-꙳꙼-꙾꛰-꜖꜠꜡꞉꞊ꞮꞯꞸ-ꟶꠂ꠆ꠋ꠨-꠯꠶-꠿꡴-꡿꣄-꣏꣚-꣱꣸-꣺꣼ꣾꣿ꤫-꤯꥓-꥟꥽-꥿꦳꧀-꧎꧚-꧟ꧥ꧿꨷-꨿꩎꩏꩚-꩟꩷-꩹ꩻ-ꩽ꪿꫁꫃-꫚꫞꫟꫰꫱꫶-꬀꬇꬈꬏꬐꬗-꬟꬧꬯꭛ꭦ-꭯꯫-꯯꯺-꯿힤-힯퟇-퟊퟼-﩮﩯﫚-﫿﬇-﬒﬘-﬜﬩﬷﬽﬿﭂﭅﮲-﯒﴾-﵏﶐﶑﷈-﷯﷼-﹯﹵﻽-／：-＠［-｀｛-･﾿-￁￈￉￐￑￘￙￝-\uffff]+\][:]([0-9]+[!])?([$])?[^\u0000-@\[-`{-©«-´¶-¹»-¿×÷˂-˅˒-˟˥-˫˭˯-̈́͆-ͯ͵͸͹;΀-΅·΋΍΢϶҂-҉԰՗՘՚-ՠֈ-֯־׀׃׆׈-׏׫-ׯ׳-؏؛-؟٘٠-٭۔۝-۠۩-۬۰-۹۽۾܀-܏݀-݌޲-߉߫-߳߶-߹߻-߿࠘࠙࠭-࠿࡙-࢟ࢵ-࣢࣪-़्࣯॑-॔।-॰঄঍঎঑঒঩঱঳-঵঺-়৅৆৉৊্৏-৖৘-৛৞৤-৯৲-਀਄਋-਎਑਒਩਱਴਷਺-਽੃-੆੉੊੍-੐੒-੘੝੟-੯੶-઀઄઎઒઩઱઴઺-઼૆૊્-૏૑-૟૤-૸ૺ-଀଄଍଎଑଒଩଱଴଺-଼୅୆୉୊୍-୕୘-୛୞୤-୰୲-஁஄஋-஍஑஖-஘஛஝஠-஢஥-஧஫-஭஺-஽௃-௅௉்-௏௑-௖௘-௿ఄ఍఑఩఺-఼౅౉్-౔౗౛-౟౤-ಀ಄಍಑಩಴಺-಼೅೉್-೔೗-ೝ೟೤-೰ೳ-ഀഄ഍഑഻഼൅൉്൏-ൖ൘-൞൤-൹඀ඁ඄඗-඙඲඼඾඿෇-෎෕෗෠-෱෴-฀฻-฿็-์๎-຀຃຅ຆຉ຋ຌຎ-ຓຘຠ຤຦ຨຩຬ຺຾຿໅໇-໌໎-໛໠-໿༁-༿཈཭-཰ྂ-྇྘྽-࿿့္်၀-၏ၣၤၩ-ၭႇ-ႍႏ-ႛ႞႟჆჈-჌჎჏჻቉቎቏቗቙቞቟኉኎኏኱኶኷኿዁዆዇዗጑጖጗፛-፞፠-፿᎐-᎟᏶᏷᏾-᐀᙭᙮ ᚛-᚟᛫-᛭᛹-᛿ᜍ᜔-ᜟ᜴-᜿᝔-᝟᝭᝱᝴-᝿឴឵៉-៖៘-៛៝-᠟ᡸ-᡿᢫-᢯᣶-᣿᤟᤬-᤯᤹-᥏᥮᥯᥵-᥿᦬-᦯᧊-᧿᨜-᨟᩟᩠᩵-᪦᪨-᫿᬴᭄ᭌ-᭿᮪᮫᮰-᮹᯦᯲-᯿ᰶ-᱌᱐-᱙᱾-᳨᳭᳴᳷-᳿᷀-ᷦ᷵-᷿἖἗἞἟὆὇὎὏὘὚὜὞὾὿᾵᾽᾿-῁῅῍-῏῔῕῜-῟῭-῱῵´-⁰⁲-⁾₀-₏₝-℁℃-℆℈℉℔№-℘℞-℣℥℧℩℮℺℻⅀-⅄⅊-⅍⅏-⅟↉-⒵⓪-⯿Ⱟⱟ⳥-⳪⳯-⳱⳴-⳿⴦⴨-⴬⴮⴯⵨-⵮⵰-⵿⶗-⶟⶧⶯⶷⶿⷇⷏⷗⷟⸀-⸮⸰-〄〈-〠〪-〰〶〷〽-぀゗-゜゠・㄀-㄄ㄮ-㄰㆏-㆟ㆻ-㇯㈀-㏿䶶-䷿鿖-鿿꒍-꓏꓾꓿꘍-꘏꘠-꘩꘬-꘿꙯-꙳꙼-꙾꛰-꜖꜠꜡꞉꞊ꞮꞯꞸ-ꟶꠂ꠆ꠋ꠨-꠿꡴-꡿꣄-꣱꣸-꣺꣼ꣾ-꤉꤫-꤯꥓-꥟꥽-꥿꦳꧀-꧎꧐-꧟ꧥ꧰-꧹꧿꨷-꨿꩎-꩟꩷-꩹ꩻ-ꩽ꪿꫁꫃-꫚꫞꫟꫰꫱꫶-꬀꬇꬈꬏꬐꬗-꬟꬧꬯꭛ꭦ-꭯꯫-꯿힤-힯퟇-퟊퟼-﩮﩯﫚-﫿﬇-﬒﬘-﬜﬩﬷﬽﬿﭂﭅﮲-﯒﴾-﵏﶐﶑﷈-﷯﷼-﹯﹵﻽-＠［-｀｛-･﾿-￁￈￉￐￑￘￙￝-\uffff]+([$])?[0-9]+)/,
/^(?:([0-9]+[!])?([$])?[^\u0000-\u001f!-\/:-@\[-\^`{-©«-±´¶-¸»¿×÷˂-˅˒-˟˥-˫˭˯-̈́͆-ͯ͵͸͹;΀-΅·΋΍΢϶҂-҉԰՗՘՚-ՠֈ-֯־׀׃׆׈-׏׫-ׯ׳-؏؛-؟٘٪-٭۔۝-۠۩-۬۽۾܀-܏݀-݌޲-޿߫-߳߶-߹߻-߿࠘࠙࠭-࠿࡙-࢟ࢵ-࣢࣪-़्࣯॑-॔।॥॰঄঍঎঑঒঩঱঳-঵঺-়৅৆৉৊্৏-৖৘-৛৞৤৥৲৳৺-਀਄਋-਎਑਒਩਱਴਷਺-਽੃-੆੉੊੍-੐੒-੘੝੟-੥੶-઀઄઎઒઩઱઴઺-઼૆૊્-૏૑-૟૤૥૰-૸ૺ-଀଄଍଎଑଒଩଱଴଺-଼୅୆୉୊୍-୕୘-୛୞୤୥୰୸-஁஄஋-஍஑஖-஘஛஝஠-஢஥-஧஫-஭஺-஽௃-௅௉்-௏௑-௖௘-௥௳-௿ఄ఍఑఩఺-఼౅౉్-౔౗౛-౟౤౥౰-౷౿ಀ಄಍಑಩಴಺-಼೅೉್-೔೗-ೝ೟೤೥೰ೳ-ഀഄ഍഑഻഼൅൉്൏-ൖ൘-൞൤൥൶-൹඀ඁ඄඗-඙඲඼඾඿෇-෎෕෗෠-෥෰෱෴-฀฻-฿็-์๎๏๚-຀຃຅ຆຉ຋ຌຎ-ຓຘຠ຤຦ຨຩຬ຺຾຿໅໇-໌໎໏໚໛໠-໿༁-༟༴-༿཈཭-཰ྂ-྇྘྽-࿿့္်၊-၏ၣၤၩ-ၭႇ-ႍႏႚႛ႞႟჆჈-჌჎჏჻቉቎቏቗቙቞቟኉኎኏኱኶኷኿዁዆዇዗጑጖጗፛-፞፠-፨፽-፿᎐-᎟᏶᏷᏾-᐀᙭᙮ ᚛-᚟᛫-᛭᛹-᛿ᜍ᜔-ᜟ᜴-᜿᝔-᝟᝭᝱᝴-᝿឴឵៉-៖៘-៛៝-៟៪-៯៺-᠏᠚-᠟ᡸ-᡿᢫-᢯᣶-᣿᤟᤬-᤯᤹-᥅᥮᥯᥵-᥿᦬-᦯᧊-᧏᧛-᧿᨜-᨟᩟᩠᩵-᩿᪊-᪏᪚-᪦᪨-᫿᬴᭄ᭌ-᭏᭚-᭿᯦᮪᮫᯲-᯿ᰶ-᰿᱊-᱌᱾-᳨᳭᳴᳷-᳿᷀-ᷦ᷵-᷿἖἗἞἟὆὇὎὏὘὚὜὞὾὿᾵᾽᾿-῁῅῍-῏῔῕῜-῟῭-῱῵´-⁯⁲⁳⁺-⁾₊-₏₝-℁℃-℆℈℉℔№-℘℞-℣℥℧℩℮℺℻⅀-⅄⅊-⅍⅏↊-⑟⒜-⒵─-❵➔-⯿Ⱟⱟ⳥-⳪⳯-⳱⳴-⳼⳾⳿⴦⴨-⴬⴮⴯⵨-⵮⵰-⵿⶗-⶟⶧⶯⶷⶿⷇⷏⷗⷟⸀-⸮⸰-〄〈-〠〪-〰〶〷〽-぀゗-゜゠・㄀-㄄ㄮ-㄰㆏-㆑㆖-㆟ㆻ-㇯㈀-㈟㈪-㉇㉐㉠-㉿㊊-㊰㋀-㏿䶶-䷿鿖-鿿꒍-꓏꓾꓿꘍-꘏꘬-꘿꙯-꙳꙼-꙾꛰-꜖꜠꜡꞉꞊ꞮꞯꞸ-ꟶꠂ꠆ꠋ꠨-꠯꠶-꠿꡴-꡿꣄-꣏꣚-꣱꣸-꣺꣼ꣾꣿ꤫-꤯꥓-꥟꥽-꥿꦳꧀-꧎꧚-꧟ꧥ꧿꨷-꨿꩎꩏꩚-꩟꩷-꩹ꩻ-ꩽ꪿꫁꫃-꫚꫞꫟꫰꫱꫶-꬀꬇꬈꬏꬐꬗-꬟꬧꬯꭛ꭦ-꭯꯫-꯯꯺-꯿힤-힯퟇-퟊퟼-﩮﩯﫚-﫿﬇-﬒﬘-﬜﬩﬷﬽﬿﭂﭅﮲-﯒﴾-﵏﶐﶑﷈-﷯﷼-﹯﹵﻽-／：-＠［-｀｛-･﾿-￁￈￉￐￑￘￙￝-\uffff]+\[([$])?[^\u0000-\u001f!-\/:-@\[-\^`{-©«-±´¶-¸»¿×÷˂-˅˒-˟˥-˫˭˯-̈́͆-ͯ͵͸͹;΀-΅·΋΍΢϶҂-҉԰՗՘՚-ՠֈ-֯־׀׃׆׈-׏׫-ׯ׳-؏؛-؟٘٪-٭۔۝-۠۩-۬۽۾܀-܏݀-݌޲-޿߫-߳߶-߹߻-߿࠘࠙࠭-࠿࡙-࢟ࢵ-࣢࣪-़्࣯॑-॔।॥॰঄঍঎঑঒঩঱঳-঵঺-়৅৆৉৊্৏-৖৘-৛৞৤৥৲৳৺-਀਄਋-਎਑਒਩਱਴਷਺-਽੃-੆੉੊੍-੐੒-੘੝੟-੥੶-઀઄઎઒઩઱઴઺-઼૆૊્-૏૑-૟૤૥૰-૸ૺ-଀଄଍଎଑଒଩଱଴଺-଼୅୆୉୊୍-୕୘-୛୞୤୥୰୸-஁஄஋-஍஑஖-஘஛஝஠-஢஥-஧஫-஭஺-஽௃-௅௉்-௏௑-௖௘-௥௳-௿ఄ఍఑఩఺-఼౅౉్-౔౗౛-౟౤౥౰-౷౿ಀ಄಍಑಩಴಺-಼೅೉್-೔೗-ೝ೟೤೥೰ೳ-ഀഄ഍഑഻഼൅൉്൏-ൖ൘-൞൤൥൶-൹඀ඁ඄඗-඙඲඼඾඿෇-෎෕෗෠-෥෰෱෴-฀฻-฿็-์๎๏๚-຀຃຅ຆຉ຋ຌຎ-ຓຘຠ຤຦ຨຩຬ຺຾຿໅໇-໌໎໏໚໛໠-໿༁-༟༴-༿཈཭-཰ྂ-྇྘྽-࿿့္်၊-၏ၣၤၩ-ၭႇ-ႍႏႚႛ႞႟჆჈-჌჎჏჻቉቎቏቗቙቞቟኉኎኏኱኶኷኿዁዆዇዗጑጖጗፛-፞፠-፨፽-፿᎐-᎟᏶᏷᏾-᐀᙭᙮ ᚛-᚟᛫-᛭᛹-᛿ᜍ᜔-ᜟ᜴-᜿᝔-᝟᝭᝱᝴-᝿឴឵៉-៖៘-៛៝-៟៪-៯៺-᠏᠚-᠟ᡸ-᡿᢫-᢯᣶-᣿᤟᤬-᤯᤹-᥅᥮᥯᥵-᥿᦬-᦯᧊-᧏᧛-᧿᨜-᨟᩟᩠᩵-᩿᪊-᪏᪚-᪦᪨-᫿᬴᭄ᭌ-᭏᭚-᭿᯦᮪᮫᯲-᯿ᰶ-᰿᱊-᱌᱾-᳨᳭᳴᳷-᳿᷀-ᷦ᷵-᷿἖἗἞἟὆὇὎὏὘὚὜὞὾὿᾵᾽᾿-῁῅῍-῏῔῕῜-῟῭-῱῵´-⁯⁲⁳⁺-⁾₊-₏₝-℁℃-℆℈℉℔№-℘℞-℣℥℧℩℮℺℻⅀-⅄⅊-⅍⅏↊-⑟⒜-⒵─-❵➔-⯿Ⱟⱟ⳥-⳪⳯-⳱⳴-⳼⳾⳿⴦⴨-⴬⴮⴯⵨-⵮⵰-⵿⶗-⶟⶧⶯⶷⶿⷇⷏⷗⷟⸀-⸮⸰-〄〈-〠〪-〰〶〷〽-぀゗-゜゠・㄀-㄄ㄮ-㄰㆏-㆑㆖-㆟ㆻ-㇯㈀-㈟㈪-㉇㉐㉠-㉿㊊-㊰㋀-㏿䶶-䷿鿖-鿿꒍-꓏꓾꓿꘍-꘏꘬-꘿꙯-꙳꙼-꙾꛰-꜖꜠꜡꞉꞊ꞮꞯꞸ-ꟶꠂ꠆ꠋ꠨-꠯꠶-꠿꡴-꡿꣄-꣏꣚-꣱꣸-꣺꣼ꣾꣿ꤫-꤯꥓-꥟꥽-꥿꦳꧀-꧎꧚-꧟ꧥ꧿꨷-꨿꩎꩏꩚-꩟꩷-꩹ꩻ-ꩽ꪿꫁꫃-꫚꫞꫟꫰꫱꫶-꬀꬇꬈꬏꬐꬗-꬟꬧꬯꭛ꭦ-꭯꯫-꯯꯺-꯿힤-힯퟇-퟊퟼-﩮﩯﫚-﫿﬇-﬒﬘-﬜﬩﬷﬽﬿﭂﭅﮲-﯒﴾-﵏﶐﶑﷈-﷯﷼-﹯﹵﻽-／：-＠［-｀｛-･﾿-￁￈￉￐￑￘￙￝-\uffff]+\])/,
/^(?:([0-9]+[!])?([$])?[^\u0000-@\[-`{-©«-´¶-¹»-¿×÷˂-˅˒-˟˥-˫˭˯-̈́͆-ͯ͵͸͹;΀-΅·΋΍΢϶҂-҉԰՗՘՚-ՠֈ-֯־׀׃׆׈-׏׫-ׯ׳-؏؛-؟٘٠-٭۔۝-۠۩-۬۰-۹۽۾܀-܏݀-݌޲-߉߫-߳߶-߹߻-߿࠘࠙࠭-࠿࡙-࢟ࢵ-࣢࣪-़्࣯॑-॔।-॰঄঍঎঑঒঩঱঳-঵঺-়৅৆৉৊্৏-৖৘-৛৞৤-৯৲-਀਄਋-਎਑਒਩਱਴਷਺-਽੃-੆੉੊੍-੐੒-੘੝੟-੯੶-઀઄઎઒઩઱઴઺-઼૆૊્-૏૑-૟૤-૸ૺ-଀଄଍଎଑଒଩଱଴଺-଼୅୆୉୊୍-୕୘-୛୞୤-୰୲-஁஄஋-஍஑஖-஘஛஝஠-஢஥-஧஫-஭஺-஽௃-௅௉்-௏௑-௖௘-௿ఄ఍఑఩఺-఼౅౉్-౔౗౛-౟౤-ಀ಄಍಑಩಴಺-಼೅೉್-೔೗-ೝ೟೤-೰ೳ-ഀഄ഍഑഻഼൅൉്൏-ൖ൘-൞൤-൹඀ඁ඄඗-඙඲඼඾඿෇-෎෕෗෠-෱෴-฀฻-฿็-์๎-຀຃຅ຆຉ຋ຌຎ-ຓຘຠ຤຦ຨຩຬ຺຾຿໅໇-໌໎-໛໠-໿༁-༿཈཭-཰ྂ-྇྘྽-࿿့္်၀-၏ၣၤၩ-ၭႇ-ႍႏ-ႛ႞႟჆჈-჌჎჏჻቉቎቏቗቙቞቟኉኎኏኱኶኷኿዁዆዇዗጑጖጗፛-፞፠-፿᎐-᎟᏶᏷᏾-᐀᙭᙮ ᚛-᚟᛫-᛭᛹-᛿ᜍ᜔-ᜟ᜴-᜿᝔-᝟᝭᝱᝴-᝿឴឵៉-៖៘-៛៝-᠟ᡸ-᡿᢫-᢯᣶-᣿᤟᤬-᤯᤹-᥏᥮᥯᥵-᥿᦬-᦯᧊-᧿᨜-᨟᩟᩠᩵-᪦᪨-᫿᬴᭄ᭌ-᭿᮪᮫᮰-᮹᯦᯲-᯿ᰶ-᱌᱐-᱙᱾-᳨᳭᳴᳷-᳿᷀-ᷦ᷵-᷿἖἗἞἟὆὇὎὏὘὚὜὞὾὿᾵᾽᾿-῁῅῍-῏῔῕῜-῟῭-῱῵´-⁰⁲-⁾₀-₏₝-℁℃-℆℈℉℔№-℘℞-℣℥℧℩℮℺℻⅀-⅄⅊-⅍⅏-⅟↉-⒵⓪-⯿Ⱟⱟ⳥-⳪⳯-⳱⳴-⳿⴦⴨-⴬⴮⴯⵨-⵮⵰-⵿⶗-⶟⶧⶯⶷⶿⷇⷏⷗⷟⸀-⸮⸰-〄〈-〠〪-〰〶〷〽-぀゗-゜゠・㄀-㄄ㄮ-㄰㆏-㆟ㆻ-㇯㈀-㏿䶶-䷿鿖-鿿꒍-꓏꓾꓿꘍-꘏꘠-꘩꘬-꘿꙯-꙳꙼-꙾꛰-꜖꜠꜡꞉꞊ꞮꞯꞸ-ꟶꠂ꠆ꠋ꠨-꠿꡴-꡿꣄-꣱꣸-꣺꣼ꣾ-꤉꤫-꤯꥓-꥟꥽-꥿꦳꧀-꧎꧐-꧟ꧥ꧰-꧹꧿꨷-꨿꩎-꩟꩷-꩹ꩻ-ꩽ꪿꫁꫃-꫚꫞꫟꫰꫱꫶-꬀꬇꬈꬏꬐꬗-꬟꬧꬯꭛ꭦ-꭯꯫-꯿힤-힯퟇-퟊퟼-﩮﩯﫚-﫿﬇-﬒﬘-﬜﬩﬷﬽﬿﭂﭅﮲-﯒﴾-﵏﶐﶑﷈-﷯﷼-﹯﹵﻽-＠［-｀｛-･﾿-￁￈￉￐￑￘￙￝-\uffff]+([$])?[0-9]+[:]([0-9]+[!])?([$])?[^\u0000-\u001f!-\/:-@\[-\^`{-©«-±´¶-¸»¿×÷˂-˅˒-˟˥-˫˭˯-̈́͆-ͯ͵͸͹;΀-΅·΋΍΢϶҂-҉԰՗՘՚-ՠֈ-֯־׀׃׆׈-׏׫-ׯ׳-؏؛-؟٘٪-٭۔۝-۠۩-۬۽۾܀-܏݀-݌޲-޿߫-߳߶-߹߻-߿࠘࠙࠭-࠿࡙-࢟ࢵ-࣢࣪-़्࣯॑-॔।॥॰঄঍঎঑঒঩঱঳-঵঺-়৅৆৉৊্৏-৖৘-৛৞৤৥৲৳৺-਀਄਋-਎਑਒਩਱਴਷਺-਽੃-੆੉੊੍-੐੒-੘੝੟-੥੶-઀઄઎઒઩઱઴઺-઼૆૊્-૏૑-૟૤૥૰-૸ૺ-଀଄଍଎଑଒଩଱଴଺-଼୅୆୉୊୍-୕୘-୛୞୤୥୰୸-஁஄஋-஍஑஖-஘஛஝஠-஢஥-஧஫-஭஺-஽௃-௅௉்-௏௑-௖௘-௥௳-௿ఄ఍఑఩఺-఼౅౉్-౔౗౛-౟౤౥౰-౷౿ಀ಄಍಑಩಴಺-಼೅೉್-೔೗-ೝ೟೤೥೰ೳ-ഀഄ഍഑഻഼൅൉്൏-ൖ൘-൞൤൥൶-൹඀ඁ඄඗-඙඲඼඾඿෇-෎෕෗෠-෥෰෱෴-฀฻-฿็-์๎๏๚-຀຃຅ຆຉ຋ຌຎ-ຓຘຠ຤຦ຨຩຬ຺຾຿໅໇-໌໎໏໚໛໠-໿༁-༟༴-༿཈཭-཰ྂ-྇྘྽-࿿့္်၊-၏ၣၤၩ-ၭႇ-ႍႏႚႛ႞႟჆჈-჌჎჏჻቉቎቏቗቙቞቟኉኎኏኱኶኷኿዁዆዇዗጑጖጗፛-፞፠-፨፽-፿᎐-᎟᏶᏷᏾-᐀᙭᙮ ᚛-᚟᛫-᛭᛹-᛿ᜍ᜔-ᜟ᜴-᜿᝔-᝟᝭᝱᝴-᝿឴឵៉-៖៘-៛៝-៟៪-៯៺-᠏᠚-᠟ᡸ-᡿᢫-᢯᣶-᣿᤟᤬-᤯᤹-᥅᥮᥯᥵-᥿᦬-᦯᧊-᧏᧛-᧿᨜-᨟᩟᩠᩵-᩿᪊-᪏᪚-᪦᪨-᫿᬴᭄ᭌ-᭏᭚-᭿᯦᮪᮫᯲-᯿ᰶ-᰿᱊-᱌᱾-᳨᳭᳴᳷-᳿᷀-ᷦ᷵-᷿἖἗἞἟὆὇὎὏὘὚὜὞὾὿᾵᾽᾿-῁῅῍-῏῔῕῜-῟῭-῱῵´-⁯⁲⁳⁺-⁾₊-₏₝-℁℃-℆℈℉℔№-℘℞-℣℥℧℩℮℺℻⅀-⅄⅊-⅍⅏↊-⑟⒜-⒵─-❵➔-⯿Ⱟⱟ⳥-⳪⳯-⳱⳴-⳼⳾⳿⴦⴨-⴬⴮⴯⵨-⵮⵰-⵿⶗-⶟⶧⶯⶷⶿⷇⷏⷗⷟⸀-⸮⸰-〄〈-〠〪-〰〶〷〽-぀゗-゜゠・㄀-㄄ㄮ-㄰㆏-㆑㆖-㆟ㆻ-㇯㈀-㈟㈪-㉇㉐㉠-㉿㊊-㊰㋀-㏿䶶-䷿鿖-鿿꒍-꓏꓾꓿꘍-꘏꘬-꘿꙯-꙳꙼-꙾꛰-꜖꜠꜡꞉꞊ꞮꞯꞸ-ꟶꠂ꠆ꠋ꠨-꠯꠶-꠿꡴-꡿꣄-꣏꣚-꣱꣸-꣺꣼ꣾꣿ꤫-꤯꥓-꥟꥽-꥿꦳꧀-꧎꧚-꧟ꧥ꧿꨷-꨿꩎꩏꩚-꩟꩷-꩹ꩻ-ꩽ꪿꫁꫃-꫚꫞꫟꫰꫱꫶-꬀꬇꬈꬏꬐꬗-꬟꬧꬯꭛ꭦ-꭯꯫-꯯꯺-꯿힤-힯퟇-퟊퟼-﩮﩯﫚-﫿﬇-﬒﬘-﬜﬩﬷﬽﬿﭂﭅﮲-﯒﴾-﵏﶐﶑﷈-﷯﷼-﹯﹵﻽-／：-＠［-｀｛-･﾿-￁￈￉￐￑￘￙￝-\uffff]+\[([$])?[^\u0000-\u001f!-\/:-@\[-\^`{-©«-±´¶-¸»¿×÷˂-˅˒-˟˥-˫˭˯-̈́͆-ͯ͵͸͹;΀-΅·΋΍΢϶҂-҉԰՗՘՚-ՠֈ-֯־׀׃׆׈-׏׫-ׯ׳-؏؛-؟٘٪-٭۔۝-۠۩-۬۽۾܀-܏݀-݌޲-޿߫-߳߶-߹߻-߿࠘࠙࠭-࠿࡙-࢟ࢵ-࣢࣪-़्࣯॑-॔।॥॰঄঍঎঑঒঩঱঳-঵঺-়৅৆৉৊্৏-৖৘-৛৞৤৥৲৳৺-਀਄਋-਎਑਒਩਱਴਷਺-਽੃-੆੉੊੍-੐੒-੘੝੟-੥੶-઀઄઎઒઩઱઴઺-઼૆૊્-૏૑-૟૤૥૰-૸ૺ-଀଄଍଎଑଒଩଱଴଺-଼୅୆୉୊୍-୕୘-୛୞୤୥୰୸-஁஄஋-஍஑஖-஘஛஝஠-஢஥-஧஫-஭஺-஽௃-௅௉்-௏௑-௖௘-௥௳-௿ఄ఍఑఩఺-఼౅౉్-౔౗౛-౟౤౥౰-౷౿ಀ಄಍಑಩಴಺-಼೅೉್-೔೗-ೝ೟೤೥೰ೳ-ഀഄ഍഑഻഼൅൉്൏-ൖ൘-൞൤൥൶-൹඀ඁ඄඗-඙඲඼඾඿෇-෎෕෗෠-෥෰෱෴-฀฻-฿็-์๎๏๚-຀຃຅ຆຉ຋ຌຎ-ຓຘຠ຤຦ຨຩຬ຺຾຿໅໇-໌໎໏໚໛໠-໿༁-༟༴-༿཈཭-཰ྂ-྇྘྽-࿿့္်၊-၏ၣၤၩ-ၭႇ-ႍႏႚႛ႞႟჆჈-჌჎჏჻቉቎቏቗቙቞቟኉኎኏኱኶኷኿዁዆዇዗጑጖጗፛-፞፠-፨፽-፿᎐-᎟᏶᏷᏾-᐀᙭᙮ ᚛-᚟᛫-᛭᛹-᛿ᜍ᜔-ᜟ᜴-᜿᝔-᝟᝭᝱᝴-᝿឴឵៉-៖៘-៛៝-៟៪-៯៺-᠏᠚-᠟ᡸ-᡿᢫-᢯᣶-᣿᤟᤬-᤯᤹-᥅᥮᥯᥵-᥿᦬-᦯᧊-᧏᧛-᧿᨜-᨟᩟᩠᩵-᩿᪊-᪏᪚-᪦᪨-᫿᬴᭄ᭌ-᭏᭚-᭿᯦᮪᮫᯲-᯿ᰶ-᰿᱊-᱌᱾-᳨᳭᳴᳷-᳿᷀-ᷦ᷵-᷿἖἗἞἟὆὇὎὏὘὚὜὞὾὿᾵᾽᾿-῁῅῍-῏῔῕῜-῟῭-῱῵´-⁯⁲⁳⁺-⁾₊-₏₝-℁℃-℆℈℉℔№-℘℞-℣℥℧℩℮℺℻⅀-⅄⅊-⅍⅏↊-⑟⒜-⒵─-❵➔-⯿Ⱟⱟ⳥-⳪⳯-⳱⳴-⳼⳾⳿⴦⴨-⴬⴮⴯⵨-⵮⵰-⵿⶗-⶟⶧⶯⶷⶿⷇⷏⷗⷟⸀-⸮⸰-〄〈-〠〪-〰〶〷〽-぀゗-゜゠・㄀-㄄ㄮ-㄰㆏-㆑㆖-㆟ㆻ-㇯㈀-㈟㈪-㉇㉐㉠-㉿㊊-㊰㋀-㏿䶶-䷿鿖-鿿꒍-꓏꓾꓿꘍-꘏꘬-꘿꙯-꙳꙼-꙾꛰-꜖꜠꜡꞉꞊ꞮꞯꞸ-ꟶꠂ꠆ꠋ꠨-꠯꠶-꠿꡴-꡿꣄-꣏꣚-꣱꣸-꣺꣼ꣾꣿ꤫-꤯꥓-꥟꥽-꥿꦳꧀-꧎꧚-꧟ꧥ꧿꨷-꨿꩎꩏꩚-꩟꩷-꩹ꩻ-ꩽ꪿꫁꫃-꫚꫞꫟꫰꫱꫶-꬀꬇꬈꬏꬐꬗-꬟꬧꬯꭛ꭦ-꭯꯫-꯯꯺-꯿힤-힯퟇-퟊퟼-﩮﩯﫚-﫿﬇-﬒﬘-﬜﬩﬷﬽﬿﭂﭅﮲-﯒﴾-﵏﶐﶑﷈-﷯﷼-﹯﹵﻽-／：-＠［-｀｛-･﾿-￁￈￉￐￑￘￙￝-\uffff]+\])/,
/^(?:([0-9]+[!])?([$])?[^\u0000-@\[-`{-©«-´¶-¹»-¿×÷˂-˅˒-˟˥-˫˭˯-̈́͆-ͯ͵͸͹;΀-΅·΋΍΢϶҂-҉԰՗՘՚-ՠֈ-֯־׀׃׆׈-׏׫-ׯ׳-؏؛-؟٘٠-٭۔۝-۠۩-۬۰-۹۽۾܀-܏݀-݌޲-߉߫-߳߶-߹߻-߿࠘࠙࠭-࠿࡙-࢟ࢵ-࣢࣪-़्࣯॑-॔।-॰঄঍঎঑঒঩঱঳-঵঺-়৅৆৉৊্৏-৖৘-৛৞৤-৯৲-਀਄਋-਎਑਒਩਱਴਷਺-਽੃-੆੉੊੍-੐੒-੘੝੟-੯੶-઀઄઎઒઩઱઴઺-઼૆૊્-૏૑-૟૤-૸ૺ-଀଄଍଎଑଒଩଱଴଺-଼୅୆୉୊୍-୕୘-୛୞୤-୰୲-஁஄஋-஍஑஖-஘஛஝஠-஢஥-஧஫-஭஺-஽௃-௅௉்-௏௑-௖௘-௿ఄ఍఑఩఺-఼౅౉్-౔౗౛-౟౤-ಀ಄಍಑಩಴಺-಼೅೉್-೔೗-ೝ೟೤-೰ೳ-ഀഄ഍഑഻഼൅൉്൏-ൖ൘-൞൤-൹඀ඁ඄඗-඙඲඼඾඿෇-෎෕෗෠-෱෴-฀฻-฿็-์๎-຀຃຅ຆຉ຋ຌຎ-ຓຘຠ຤຦ຨຩຬ຺຾຿໅໇-໌໎-໛໠-໿༁-༿཈཭-཰ྂ-྇྘྽-࿿့္်၀-၏ၣၤၩ-ၭႇ-ႍႏ-ႛ႞႟჆჈-჌჎჏჻቉቎቏቗቙቞቟኉኎኏኱኶኷኿዁዆዇዗጑጖጗፛-፞፠-፿᎐-᎟᏶᏷᏾-᐀᙭᙮ ᚛-᚟᛫-᛭᛹-᛿ᜍ᜔-ᜟ᜴-᜿᝔-᝟᝭᝱᝴-᝿឴឵៉-៖៘-៛៝-᠟ᡸ-᡿᢫-᢯᣶-᣿᤟᤬-᤯᤹-᥏᥮᥯᥵-᥿᦬-᦯᧊-᧿᨜-᨟᩟᩠᩵-᪦᪨-᫿᬴᭄ᭌ-᭿᮪᮫᮰-᮹᯦᯲-᯿ᰶ-᱌᱐-᱙᱾-᳨᳭᳴᳷-᳿᷀-ᷦ᷵-᷿἖἗἞἟὆὇὎὏὘὚὜὞὾὿᾵᾽᾿-῁῅῍-῏῔῕῜-῟῭-῱῵´-⁰⁲-⁾₀-₏₝-℁℃-℆℈℉℔№-℘℞-℣℥℧℩℮℺℻⅀-⅄⅊-⅍⅏-⅟↉-⒵⓪-⯿Ⱟⱟ⳥-⳪⳯-⳱⳴-⳿⴦⴨-⴬⴮⴯⵨-⵮⵰-⵿⶗-⶟⶧⶯⶷⶿⷇⷏⷗⷟⸀-⸮⸰-〄〈-〠〪-〰〶〷〽-぀゗-゜゠・㄀-㄄ㄮ-㄰㆏-㆟ㆻ-㇯㈀-㏿䶶-䷿鿖-鿿꒍-꓏꓾꓿꘍-꘏꘠-꘩꘬-꘿꙯-꙳꙼-꙾꛰-꜖꜠꜡꞉꞊ꞮꞯꞸ-ꟶꠂ꠆ꠋ꠨-꠿꡴-꡿꣄-꣱꣸-꣺꣼ꣾ-꤉꤫-꤯꥓-꥟꥽-꥿꦳꧀-꧎꧐-꧟ꧥ꧰-꧹꧿꨷-꨿꩎-꩟꩷-꩹ꩻ-ꩽ꪿꫁꫃-꫚꫞꫟꫰꫱꫶-꬀꬇꬈꬏꬐꬗-꬟꬧꬯꭛ꭦ-꭯꯫-꯿힤-힯퟇-퟊퟼-﩮﩯﫚-﫿﬇-﬒﬘-﬜﬩﬷﬽﬿﭂﭅﮲-﯒﴾-﵏﶐﶑﷈-﷯﷼-﹯﹵﻽-＠［-｀｛-･﾿-￁￈￉￐￑￘￙￝-\uffff]+([$])?[0-9]+[:]([0-9]+[!])?([$])?[^\u0000-@\[-`{-©«-´¶-¹»-¿×÷˂-˅˒-˟˥-˫˭˯-̈́͆-ͯ͵͸͹;΀-΅·΋΍΢϶҂-҉԰՗՘՚-ՠֈ-֯־׀׃׆׈-׏׫-ׯ׳-؏؛-؟٘٠-٭۔۝-۠۩-۬۰-۹۽۾܀-܏݀-݌޲-߉߫-߳߶-߹߻-߿࠘࠙࠭-࠿࡙-࢟ࢵ-࣢࣪-़्࣯॑-॔।-॰঄঍঎঑঒঩঱঳-঵঺-়৅৆৉৊্৏-৖৘-৛৞৤-৯৲-਀਄਋-਎਑਒਩਱਴਷਺-਽੃-੆੉੊੍-੐੒-੘੝੟-੯੶-઀઄઎઒઩઱઴઺-઼૆૊્-૏૑-૟૤-૸ૺ-଀଄଍଎଑଒଩଱଴଺-଼୅୆୉୊୍-୕୘-୛୞୤-୰୲-஁஄஋-஍஑஖-஘஛஝஠-஢஥-஧஫-஭஺-஽௃-௅௉்-௏௑-௖௘-௿ఄ఍఑఩఺-఼౅౉్-౔౗౛-౟౤-ಀ಄಍಑಩಴಺-಼೅೉್-೔೗-ೝ೟೤-೰ೳ-ഀഄ഍഑഻഼൅൉്൏-ൖ൘-൞൤-൹඀ඁ඄඗-඙඲඼඾඿෇-෎෕෗෠-෱෴-฀฻-฿็-์๎-຀຃຅ຆຉ຋ຌຎ-ຓຘຠ຤຦ຨຩຬ຺຾຿໅໇-໌໎-໛໠-໿༁-༿཈཭-཰ྂ-྇྘྽-࿿့္်၀-၏ၣၤၩ-ၭႇ-ႍႏ-ႛ႞႟჆჈-჌჎჏჻቉቎቏቗቙቞቟኉኎኏኱኶኷኿዁዆዇዗጑጖጗፛-፞፠-፿᎐-᎟᏶᏷᏾-᐀᙭᙮ ᚛-᚟᛫-᛭᛹-᛿ᜍ᜔-ᜟ᜴-᜿᝔-᝟᝭᝱᝴-᝿឴឵៉-៖៘-៛៝-᠟ᡸ-᡿᢫-᢯᣶-᣿᤟᤬-᤯᤹-᥏᥮᥯᥵-᥿᦬-᦯᧊-᧿᨜-᨟᩟᩠᩵-᪦᪨-᫿᬴᭄ᭌ-᭿᮪᮫᮰-᮹᯦᯲-᯿ᰶ-᱌᱐-᱙᱾-᳨᳭᳴᳷-᳿᷀-ᷦ᷵-᷿἖἗἞἟὆὇὎὏὘὚὜὞὾὿᾵᾽᾿-῁῅῍-῏῔῕῜-῟῭-῱῵´-⁰⁲-⁾₀-₏₝-℁℃-℆℈℉℔№-℘℞-℣℥℧℩℮℺℻⅀-⅄⅊-⅍⅏-⅟↉-⒵⓪-⯿Ⱟⱟ⳥-⳪⳯-⳱⳴-⳿⴦⴨-⴬⴮⴯⵨-⵮⵰-⵿⶗-⶟⶧⶯⶷⶿⷇⷏⷗⷟⸀-⸮⸰-〄〈-〠〪-〰〶〷〽-぀゗-゜゠・㄀-㄄ㄮ-㄰㆏-㆟ㆻ-㇯㈀-㏿䶶-䷿鿖-鿿꒍-꓏꓾꓿꘍-꘏꘠-꘩꘬-꘿꙯-꙳꙼-꙾꛰-꜖꜠꜡꞉꞊ꞮꞯꞸ-ꟶꠂ꠆ꠋ꠨-꠿꡴-꡿꣄-꣱꣸-꣺꣼ꣾ-꤉꤫-꤯꥓-꥟꥽-꥿꦳꧀-꧎꧐-꧟ꧥ꧰-꧹꧿꨷-꨿꩎-꩟꩷-꩹ꩻ-ꩽ꪿꫁꫃-꫚꫞꫟꫰꫱꫶-꬀꬇꬈꬏꬐꬗-꬟꬧꬯꭛ꭦ-꭯꯫-꯿힤-힯퟇-퟊퟼-﩮﩯﫚-﫿﬇-﬒﬘-﬜﬩﬷﬽﬿﭂﭅﮲-﯒﴾-﵏﶐﶑﷈-﷯﷼-﹯﹵﻽-＠［-｀｛-･﾿-￁￈￉￐￑￘￙￝-\uffff]+([$])?[0-9]+)/,
/^(?:([0-9]+[!])?([$])?[^\u0000-@\[-`{-©«-´¶-¹»-¿×÷˂-˅˒-˟˥-˫˭˯-̈́͆-ͯ͵͸͹;΀-΅·΋΍΢϶҂-҉԰՗՘՚-ՠֈ-֯־׀׃׆׈-׏׫-ׯ׳-؏؛-؟٘٠-٭۔۝-۠۩-۬۰-۹۽۾܀-܏݀-݌޲-߉߫-߳߶-߹߻-߿࠘࠙࠭-࠿࡙-࢟ࢵ-࣢࣪-़्࣯॑-॔।-॰঄঍঎঑঒঩঱঳-঵঺-়৅৆৉৊্৏-৖৘-৛৞৤-৯৲-਀਄਋-਎਑਒਩਱਴਷਺-਽੃-੆੉੊੍-੐੒-੘੝੟-੯੶-઀઄઎઒઩઱઴઺-઼૆૊્-૏૑-૟૤-૸ૺ-଀଄଍଎଑଒଩଱଴଺-଼୅୆୉୊୍-୕୘-୛୞୤-୰୲-஁஄஋-஍஑஖-஘஛஝஠-஢஥-஧஫-஭஺-஽௃-௅௉்-௏௑-௖௘-௿ఄ఍఑఩఺-఼౅౉్-౔౗౛-౟౤-ಀ಄಍಑಩಴಺-಼೅೉್-೔೗-ೝ೟೤-೰ೳ-ഀഄ഍഑഻഼൅൉്൏-ൖ൘-൞൤-൹඀ඁ඄඗-඙඲඼඾඿෇-෎෕෗෠-෱෴-฀฻-฿็-์๎-຀຃຅ຆຉ຋ຌຎ-ຓຘຠ຤຦ຨຩຬ຺຾຿໅໇-໌໎-໛໠-໿༁-༿཈཭-཰ྂ-྇྘྽-࿿့္်၀-၏ၣၤၩ-ၭႇ-ႍႏ-ႛ႞႟჆჈-჌჎჏჻቉቎቏቗቙቞቟኉኎኏኱኶኷኿዁዆዇዗጑጖጗፛-፞፠-፿᎐-᎟᏶᏷᏾-᐀᙭᙮ ᚛-᚟᛫-᛭᛹-᛿ᜍ᜔-ᜟ᜴-᜿᝔-᝟᝭᝱᝴-᝿឴឵៉-៖៘-៛៝-᠟ᡸ-᡿᢫-᢯᣶-᣿᤟᤬-᤯᤹-᥏᥮᥯᥵-᥿᦬-᦯᧊-᧿᨜-᨟᩟᩠᩵-᪦᪨-᫿᬴᭄ᭌ-᭿᮪᮫᮰-᮹᯦᯲-᯿ᰶ-᱌᱐-᱙᱾-᳨᳭᳴᳷-᳿᷀-ᷦ᷵-᷿἖἗἞἟὆὇὎὏὘὚὜὞὾὿᾵᾽᾿-῁῅῍-῏῔῕῜-῟῭-῱῵´-⁰⁲-⁾₀-₏₝-℁℃-℆℈℉℔№-℘℞-℣℥℧℩℮℺℻⅀-⅄⅊-⅍⅏-⅟↉-⒵⓪-⯿Ⱟⱟ⳥-⳪⳯-⳱⳴-⳿⴦⴨-⴬⴮⴯⵨-⵮⵰-⵿⶗-⶟⶧⶯⶷⶿⷇⷏⷗⷟⸀-⸮⸰-〄〈-〠〪-〰〶〷〽-぀゗-゜゠・㄀-㄄ㄮ-㄰㆏-㆟ㆻ-㇯㈀-㏿䶶-䷿鿖-鿿꒍-꓏꓾꓿꘍-꘏꘠-꘩꘬-꘿꙯-꙳꙼-꙾꛰-꜖꜠꜡꞉꞊ꞮꞯꞸ-ꟶꠂ꠆ꠋ꠨-꠿꡴-꡿꣄-꣱꣸-꣺꣼ꣾ-꤉꤫-꤯꥓-꥟꥽-꥿꦳꧀-꧎꧐-꧟ꧥ꧰-꧹꧿꨷-꨿꩎-꩟꩷-꩹ꩻ-ꩽ꪿꫁꫃-꫚꫞꫟꫰꫱꫶-꬀꬇꬈꬏꬐꬗-꬟꬧꬯꭛ꭦ-꭯꯫-꯿힤-힯퟇-퟊퟼-﩮﩯﫚-﫿﬇-﬒﬘-﬜﬩﬷﬽﬿﭂﭅﮲-﯒﴾-﵏﶐﶑﷈-﷯﷼-﹯﹵﻽-＠［-｀｛-･﾿-￁￈￉￐￑￘￙￝-\uffff]+([$])?[0-9]+)/,
/^(?:([^\u0000-@\[-\^`{-©«-´¶-¹»-¿×÷˂-˅˒-˟˥-˫˭˯-̈́͆-ͯ͵͸͹;΀-΅·΋΍΢϶҂-҉԰՗՘՚-ՠֈ-֯־׀׃׆׈-׏׫-ׯ׳-؏؛-؟٘٠-٭۔۝-۠۩-۬۰-۹۽۾܀-܏݀-݌޲-߉߫-߳߶-߹߻-߿࠘࠙࠭-࠿࡙-࢟ࢵ-࣢࣪-़्࣯॑-॔।-॰঄঍঎঑঒঩঱঳-঵঺-়৅৆৉৊্৏-৖৘-৛৞৤-৯৲-਀਄਋-਎਑਒਩਱਴਷਺-਽੃-੆੉੊੍-੐੒-੘੝੟-੯੶-઀઄઎઒઩઱઴઺-઼૆૊્-૏૑-૟૤-૸ૺ-଀଄଍଎଑଒଩଱଴଺-଼୅୆୉୊୍-୕୘-୛୞୤-୰୲-஁஄஋-஍஑஖-஘஛஝஠-஢஥-஧஫-஭஺-஽௃-௅௉்-௏௑-௖௘-௿ఄ఍఑఩఺-఼౅౉్-౔౗౛-౟౤-ಀ಄಍಑಩಴಺-಼೅೉್-೔೗-ೝ೟೤-೰ೳ-ഀഄ഍഑഻഼൅൉്൏-ൖ൘-൞൤-൹඀ඁ඄඗-඙඲඼඾඿෇-෎෕෗෠-෱෴-฀฻-฿็-์๎-຀຃຅ຆຉ຋ຌຎ-ຓຘຠ຤຦ຨຩຬ຺຾຿໅໇-໌໎-໛໠-໿༁-༿཈཭-཰ྂ-྇྘྽-࿿့္်၀-၏ၣၤၩ-ၭႇ-ႍႏ-ႛ႞႟჆჈-჌჎჏჻቉቎቏቗቙቞቟኉኎኏኱኶኷኿዁዆዇዗጑጖጗፛-፞፠-፿᎐-᎟᏶᏷᏾-᐀᙭᙮ ᚛-᚟᛫-᛭᛹-᛿ᜍ᜔-ᜟ᜴-᜿᝔-᝟᝭᝱᝴-᝿឴឵៉-៖៘-៛៝-᠟ᡸ-᡿᢫-᢯᣶-᣿᤟᤬-᤯᤹-᥏᥮᥯᥵-᥿᦬-᦯᧊-᧿᨜-᨟᩟᩠᩵-᪦᪨-᫿᬴᭄ᭌ-᭿᮪᮫᮰-᮹᯦᯲-᯿ᰶ-᱌᱐-᱙᱾-᳨᳭᳴᳷-᳿᷀-ᷦ᷵-᷿἖἗἞἟὆὇὎὏὘὚὜὞὾὿᾵᾽᾿-῁῅῍-῏῔῕῜-῟῭-῱῵´-⁰⁲-⁾₀-₏₝-℁℃-℆℈℉℔№-℘℞-℣℥℧℩℮℺℻⅀-⅄⅊-⅍⅏-⅟↉-⒵⓪-⯿Ⱟⱟ⳥-⳪⳯-⳱⳴-⳿⴦⴨-⴬⴮⴯⵨-⵮⵰-⵿⶗-⶟⶧⶯⶷⶿⷇⷏⷗⷟⸀-⸮⸰-〄〈-〠〪-〰〶〷〽-぀゗-゜゠・㄀-㄄ㄮ-㄰㆏-㆟ㆻ-㇯㈀-㏿䶶-䷿鿖-鿿꒍-꓏꓾꓿꘍-꘏꘠-꘩꘬-꘿꙯-꙳꙼-꙾꛰-꜖꜠꜡꞉꞊ꞮꞯꞸ-ꟶꠂ꠆ꠋ꠨-꠿꡴-꡿꣄-꣱꣸-꣺꣼ꣾ-꤉꤫-꤯꥓-꥟꥽-꥿꦳꧀-꧎꧐-꧟ꧥ꧰-꧹꧿꨷-꨿꩎-꩟꩷-꩹ꩻ-ꩽ꪿꫁꫃-꫚꫞꫟꫰꫱꫶-꬀꬇꬈꬏꬐꬗-꬟꬧꬯꭛ꭦ-꭯꯫-꯿힤-힯퟇-퟊퟼-﩮﩯﫚-﫿﬇-﬒﬘-﬜﬩﬷﬽﬿﭂﭅﮲-﯒﴾-﵏﶐﶑﷈-﷯﷼-﹯﹵﻽-＠［-｀｛-･﾿-￁￈￉￐￑￘￙￝-\uffff](?:[^\u0000-\-\/:-@\[-\^`{-©«-±´¶-¸»¿×÷˂-˅˒-˟˥-˫˭˯-̈́͆-ͯ͵͸͹;΀-΅·΋΍΢϶҂-҉԰՗՘՚-ՠֈ-֯־׀׃׆׈-׏׫-ׯ׳-؏؛-؟٘٪-٭۔۝-۠۩-۬۽۾܀-܏݀-݌޲-޿߫-߳߶-߹߻-߿࠘࠙࠭-࠿࡙-࢟ࢵ-࣢࣪-़्࣯॑-॔।॥॰঄঍঎঑঒঩঱঳-঵঺-়৅৆৉৊্৏-৖৘-৛৞৤৥৲৳৺-਀਄਋-਎਑਒਩਱਴਷਺-਽੃-੆੉੊੍-੐੒-੘੝੟-੥੶-઀઄઎઒઩઱઴઺-઼૆૊્-૏૑-૟૤૥૰-૸ૺ-଀଄଍଎଑଒଩଱଴଺-଼୅୆୉୊୍-୕୘-୛୞୤୥୰୸-஁஄஋-஍஑஖-஘஛஝஠-஢஥-஧஫-஭஺-஽௃-௅௉்-௏௑-௖௘-௥௳-௿ఄ఍఑఩఺-఼౅౉్-౔౗౛-౟౤౥౰-౷౿ಀ಄಍಑಩಴಺-಼೅೉್-೔೗-ೝ೟೤೥೰ೳ-ഀഄ഍഑഻഼൅൉്൏-ൖ൘-൞൤൥൶-൹඀ඁ඄඗-඙඲඼඾඿෇-෎෕෗෠-෥෰෱෴-฀฻-฿็-์๎๏๚-຀຃຅ຆຉ຋ຌຎ-ຓຘຠ຤຦ຨຩຬ຺຾຿໅໇-໌໎໏໚໛໠-໿༁-༟༴-༿཈཭-཰ྂ-྇྘྽-࿿့္်၊-၏ၣၤၩ-ၭႇ-ႍႏႚႛ႞႟჆჈-჌჎჏჻቉቎቏቗቙቞቟኉኎኏኱኶኷኿዁዆዇዗጑጖጗፛-፞፠-፨፽-፿᎐-᎟᏶᏷᏾-᐀᙭᙮ ᚛-᚟᛫-᛭᛹-᛿ᜍ᜔-ᜟ᜴-᜿᝔-᝟᝭᝱᝴-᝿឴឵៉-៖៘-៛៝-៟៪-៯៺-᠏᠚-᠟ᡸ-᡿᢫-᢯᣶-᣿᤟᤬-᤯᤹-᥅᥮᥯᥵-᥿᦬-᦯᧊-᧏᧛-᧿᨜-᨟᩟᩠᩵-᩿᪊-᪏᪚-᪦᪨-᫿᬴᭄ᭌ-᭏᭚-᭿᯦᮪᮫᯲-᯿ᰶ-᰿᱊-᱌᱾-᳨᳭᳴᳷-᳿᷀-ᷦ᷵-᷿἖἗἞἟὆὇὎὏὘὚὜὞὾὿᾵᾽᾿-῁῅῍-῏῔῕῜-῟῭-῱῵´-⁯⁲⁳⁺-⁾₊-₏₝-℁℃-℆℈℉℔№-℘℞-℣℥℧℩℮℺℻⅀-⅄⅊-⅍⅏↊-⑟⒜-⒵─-❵➔-⯿Ⱟⱟ⳥-⳪⳯-⳱⳴-⳼⳾⳿⴦⴨-⴬⴮⴯⵨-⵮⵰-⵿⶗-⶟⶧⶯⶷⶿⷇⷏⷗⷟⸀-⸮⸰-〄〈-〠〪-〰〶〷〽-぀゗-゜゠・㄀-㄄ㄮ-㄰㆏-㆑㆖-㆟ㆻ-㇯㈀-㈟㈪-㉇㉐㉠-㉿㊊-㊰㋀-㏿䶶-䷿鿖-鿿꒍-꓏꓾꓿꘍-꘏꘬-꘿꙯-꙳꙼-꙾꛰-꜖꜠꜡꞉꞊ꞮꞯꞸ-ꟶꠂ꠆ꠋ꠨-꠯꠶-꠿꡴-꡿꣄-꣏꣚-꣱꣸-꣺꣼ꣾꣿ꤫-꤯꥓-꥟꥽-꥿꦳꧀-꧎꧚-꧟ꧥ꧿꨷-꨿꩎꩏꩚-꩟꩷-꩹ꩻ-ꩽ꪿꫁꫃-꫚꫞꫟꫰꫱꫶-꬀꬇꬈꬏꬐꬗-꬟꬧꬯꭛ꭦ-꭯꯫-꯯꯺-꯿힤-힯퟇-퟊퟼-﩮﩯﫚-﫿﬇-﬒﬘-﬜﬩﬷﬽﬿﭂﭅﮲-﯒﴾-﵏﶐﶑﷈-﷯﷼-﹯﹵﻽-／：-＠［-｀｛-･﾿-￁￈￉￐￑￘￙￝-\uffff]*[^\u0000-\/:-@\[-\^`{-©«-±´¶-¸»¿×÷˂-˅˒-˟˥-˫˭˯-̈́͆-ͯ͵͸͹;΀-΅·΋΍΢϶҂-҉԰՗՘՚-ՠֈ-֯־׀׃׆׈-׏׫-ׯ׳-؏؛-؟٘٪-٭۔۝-۠۩-۬۽۾܀-܏݀-݌޲-޿߫-߳߶-߹߻-߿࠘࠙࠭-࠿࡙-࢟ࢵ-࣢࣪-़्࣯॑-॔।॥॰঄঍঎঑঒঩঱঳-঵঺-়৅৆৉৊্৏-৖৘-৛৞৤৥৲৳৺-਀਄਋-਎਑਒਩਱਴਷਺-਽੃-੆੉੊੍-੐੒-੘੝੟-੥੶-઀઄઎઒઩઱઴઺-઼૆૊્-૏૑-૟૤૥૰-૸ૺ-଀଄଍଎଑଒଩଱଴଺-଼୅୆୉୊୍-୕୘-୛୞୤୥୰୸-஁஄஋-஍஑஖-஘஛஝஠-஢஥-஧஫-஭஺-஽௃-௅௉்-௏௑-௖௘-௥௳-௿ఄ఍఑఩఺-఼౅౉్-౔౗౛-౟౤౥౰-౷౿ಀ಄಍಑಩಴಺-಼೅೉್-೔೗-ೝ೟೤೥೰ೳ-ഀഄ഍഑഻഼൅൉്൏-ൖ൘-൞൤൥൶-൹඀ඁ඄඗-඙඲඼඾඿෇-෎෕෗෠-෥෰෱෴-฀฻-฿็-์๎๏๚-຀຃຅ຆຉ຋ຌຎ-ຓຘຠ຤຦ຨຩຬ຺຾຿໅໇-໌໎໏໚໛໠-໿༁-༟༴-༿཈཭-཰ྂ-྇྘྽-࿿့္်၊-၏ၣၤၩ-ၭႇ-ႍႏႚႛ႞႟჆჈-჌჎჏჻቉቎቏቗቙቞቟኉኎኏኱኶኷኿዁዆዇዗጑጖጗፛-፞፠-፨፽-፿᎐-᎟᏶᏷᏾-᐀᙭᙮ ᚛-᚟᛫-᛭᛹-᛿ᜍ᜔-ᜟ᜴-᜿᝔-᝟᝭᝱᝴-᝿឴឵៉-៖៘-៛៝-៟៪-៯៺-᠏᠚-᠟ᡸ-᡿᢫-᢯᣶-᣿᤟᤬-᤯᤹-᥅᥮᥯᥵-᥿᦬-᦯᧊-᧏᧛-᧿᨜-᨟᩟᩠᩵-᩿᪊-᪏᪚-᪦᪨-᫿᬴᭄ᭌ-᭏᭚-᭿᯦᮪᮫᯲-᯿ᰶ-᰿᱊-᱌᱾-᳨᳭᳴᳷-᳿᷀-ᷦ᷵-᷿἖἗἞἟὆὇὎὏὘὚὜὞὾὿᾵᾽᾿-῁῅῍-῏῔῕῜-῟῭-῱῵´-⁯⁲⁳⁺-⁾₊-₏₝-℁℃-℆℈℉℔№-℘℞-℣℥℧℩℮℺℻⅀-⅄⅊-⅍⅏↊-⑟⒜-⒵─-❵➔-⯿Ⱟⱟ⳥-⳪⳯-⳱⳴-⳼⳾⳿⴦⴨-⴬⴮⴯⵨-⵮⵰-⵿⶗-⶟⶧⶯⶷⶿⷇⷏⷗⷟⸀-⸮⸰-〄〈-〠〪-〰〶〷〽-぀゗-゜゠・㄀-㄄ㄮ-㄰㆏-㆑㆖-㆟ㆻ-㇯㈀-㈟㈪-㉇㉐㉠-㉿㊊-㊰㋀-㏿䶶-䷿鿖-鿿꒍-꓏꓾꓿꘍-꘏꘬-꘿꙯-꙳꙼-꙾꛰-꜖꜠꜡꞉꞊ꞮꞯꞸ-ꟶꠂ꠆ꠋ꠨-꠯꠶-꠿꡴-꡿꣄-꣏꣚-꣱꣸-꣺꣼ꣾꣿ꤫-꤯꥓-꥟꥽-꥿꦳꧀-꧎꧚-꧟ꧥ꧿꨷-꨿꩎꩏꩚-꩟꩷-꩹ꩻ-ꩽ꪿꫁꫃-꫚꫞꫟꫰꫱꫶-꬀꬇꬈꬏꬐꬗-꬟꬧꬯꭛ꭦ-꭯꯫-꯯꯺-꯿힤-힯퟇-퟊퟼-﩮﩯﫚-﫿﬇-﬒﬘-﬜﬩﬷﬽﬿﭂﭅﮲-﯒﴾-﵏﶐﶑﷈-﷯﷼-﹯﹵﻽-／：-＠［-｀｛-･﾿-￁￈￉￐￑￘￙￝-\uffff])?)(?=(\s*(?:$|[\u0000-\b\u000e-\u001f#%&)-\-\/:-?\\-\^`|-¡-©«-±´¶-¸»¿×÷˂-˅˒-˟˥-˫˭˯-̈́͆-ͯ͵͸͹;΀-΅·΋΍΢϶҂-҉԰՗՘՚-ՠֈ-֯־׀׃׆׈-׏׫-ׯ׳-؏؛-؟٘٪-٭۔۝-۠۩-۬۽۾܀-܏݀-݌޲-޿߫-߳߶-߹߻-߿࠘࠙࠭-࠿࡙-࢟ࢵ-࣢࣪-़्࣯॑-॔।॥॰঄঍঎঑঒঩঱঳-঵঺-়৅৆৉৊্৏-৖৘-৛৞৤৥৲৳৺-਀਄਋-਎਑਒਩਱਴਷਺-਽੃-੆੉੊੍-੐੒-੘੝੟-੥੶-઀઄઎઒઩઱઴઺-઼૆૊્-૏૑-૟૤૥૰-૸ૺ-଀଄଍଎଑଒଩଱଴଺-଼୅୆୉୊୍-୕୘-୛୞୤୥୰୸-஁஄஋-஍஑஖-஘஛஝஠-஢஥-஧஫-஭஺-஽௃-௅௉்-௏௑-௖௘-௥௳-௿ఄ఍఑఩఺-఼౅౉్-౔౗౛-౟౤౥౰-౷౿ಀ಄಍಑಩಴಺-಼೅೉್-೔೗-ೝ೟೤೥೰ೳ-ഀഄ഍഑഻഼൅൉്൏-ൖ൘-൞൤൥൶-൹඀ඁ඄඗-඙඲඼඾඿෇-෎෕෗෠-෥෰෱෴-฀฻-฿็-์๎๏๚-຀຃຅ຆຉ຋ຌຎ-ຓຘຠ຤຦ຨຩຬ຺຾຿໅໇-໌໎໏໚໛໠-໿༁-༟༴-༿཈཭-཰ྂ-྇྘྽-࿿့္်၊-၏ၣၤၩ-ၭႇ-ႍႏႚႛ႞႟჆჈-჌჎჏჻቉቎቏቗቙቞቟኉኎኏኱኶኷኿዁዆዇዗጑጖጗፛-፞፠-፨፽-፿᎐-᎟᏶᏷᏾-᐀᙭᙮᚛-᚟᛫-᛭᛹-᛿ᜍ᜔-ᜟ᜴-᜿᝔-᝟᝭᝱᝴-᝿឴឵៉-៖៘-៛៝-៟៪-៯៺-᠍᠏᠚-᠟ᡸ-᡿᢫-᢯᣶-᣿᤟᤬-᤯᤹-᥅᥮᥯᥵-᥿᦬-᦯᧊-᧏᧛-᧿᨜-᨟᩟᩠᩵-᩿᪊-᪏᪚-᪦᪨-᫿᬴᭄ᭌ-᭏᭚-᭿᯦᮪᮫᯲-᯿ᰶ-᰿᱊-᱌᱾-᳨᳭᳴᳷-᳿᷀-ᷦ᷵-᷿἖἗἞἟὆὇὎὏὘὚὜὞὾὿᾵᾽᾿-῁῅῍-῏῔῕῜-῟῭-῱῵´-῿​-‧‪-‮‰-⁞⁠-⁯⁲⁳⁺-⁾₊-₏₝-℁℃-℆℈℉℔№-℘℞-℣℥℧℩℮℺℻⅀-⅄⅊-⅍⅏↊-⑟⒜-⒵─-❵➔-⯿Ⱟⱟ⳥-⳪⳯-⳱⳴-⳼⳾⳿⴦⴨-⴬⴮⴯⵨-⵮⵰-⵿⶗-⶟⶧⶯⶷⶿⷇⷏⷗⷟⸀-⸮⸰-⿿、-〄〈-〠〪-〰〶〷〽-぀゗-゜゠・㄀-㄄ㄮ-㄰㆏-㆑㆖-㆟ㆻ-㇯㈀-㈟㈪-㉇㉐㉠-㉿㊊-㊰㋀-㏿䶶-䷿鿖-鿿꒍-꓏꓾꓿꘍-꘏꘬-꘿꙯-꙳꙼-꙾꛰-꜖꜠꜡꞉꞊ꞮꞯꞸ-ꟶꠂ꠆ꠋ꠨-꠯꠶-꠿꡴-꡿꣄-꣏꣚-꣱꣸-꣺꣼ꣾꣿ꤫-꤯꥓-꥟꥽-꥿꦳꧀-꧎꧚-꧟ꧥ꧿꨷-꨿꩎꩏꩚-꩟꩷-꩹ꩻ-ꩽ꪿꫁꫃-꫚꫞꫟꫰꫱꫶-꬀꬇꬈꬏꬐꬗-꬟꬧꬯꭛ꭦ-꭯꯫-꯯꯺-꯿힤-힯퟇-퟊퟼-﩮﩯﫚-﫿﬇-﬒﬘-﬜﬩﬷﬽﬿﭂﭅﮲-﯒﴾-﵏﶐﶑﷈-﷯﷼-﹯﹵﻽﻾＀-／：-＠［-｀｛-･﾿-￁￈￉￐￑￘￙￝-\uffff]))))/,
/^(?:(?:[^\u0000-\/:-@\[-`{-©«-±´¶-¸»¿×÷˂-˅˒-˟˥-˫˭˯-̈́͆-ͯ͵͸͹;΀-΅·΋΍΢϶҂-҉԰՗՘՚-ՠֈ-֯־׀׃׆׈-׏׫-ׯ׳-؏؛-؟٘٪-٭۔۝-۠۩-۬۽۾܀-܏݀-݌޲-޿߫-߳߶-߹߻-߿࠘࠙࠭-࠿࡙-࢟ࢵ-࣢࣪-़्࣯॑-॔।॥॰঄঍঎঑঒঩঱঳-঵঺-়৅৆৉৊্৏-৖৘-৛৞৤৥৲৳৺-਀਄਋-਎਑਒਩਱਴਷਺-਽੃-੆੉੊੍-੐੒-੘੝੟-੥੶-઀઄઎઒઩઱઴઺-઼૆૊્-૏૑-૟૤૥૰-૸ૺ-଀଄଍଎଑଒଩଱଴଺-଼୅୆୉୊୍-୕୘-୛୞୤୥୰୸-஁஄஋-஍஑஖-஘஛஝஠-஢஥-஧஫-஭஺-஽௃-௅௉்-௏௑-௖௘-௥௳-௿ఄ఍఑఩఺-఼౅౉్-౔౗౛-౟౤౥౰-౷౿ಀ಄಍಑಩಴಺-಼೅೉್-೔೗-ೝ೟೤೥೰ೳ-ഀഄ഍഑഻഼൅൉്൏-ൖ൘-൞൤൥൶-൹඀ඁ඄඗-඙඲඼඾඿෇-෎෕෗෠-෥෰෱෴-฀฻-฿็-์๎๏๚-຀຃຅ຆຉ຋ຌຎ-ຓຘຠ຤຦ຨຩຬ຺຾຿໅໇-໌໎໏໚໛໠-໿༁-༟༴-༿཈཭-཰ྂ-྇྘྽-࿿့္်၊-၏ၣၤၩ-ၭႇ-ႍႏႚႛ႞႟჆჈-჌჎჏჻቉቎቏቗቙቞቟኉኎኏኱኶኷኿዁዆዇዗጑጖጗፛-፞፠-፨፽-፿᎐-᎟᏶᏷᏾-᐀᙭᙮ ᚛-᚟᛫-᛭᛹-᛿ᜍ᜔-ᜟ᜴-᜿᝔-᝟᝭᝱᝴-᝿឴឵៉-៖៘-៛៝-៟៪-៯៺-᠏᠚-᠟ᡸ-᡿᢫-᢯᣶-᣿᤟᤬-᤯᤹-᥅᥮᥯᥵-᥿᦬-᦯᧊-᧏᧛-᧿᨜-᨟᩟᩠᩵-᩿᪊-᪏᪚-᪦᪨-᫿᬴᭄ᭌ-᭏᭚-᭿᯦᮪᮫᯲-᯿ᰶ-᰿᱊-᱌᱾-᳨᳭᳴᳷-᳿᷀-ᷦ᷵-᷿἖἗἞἟὆὇὎὏὘὚὜὞὾὿᾵᾽᾿-῁῅῍-῏῔῕῜-῟῭-῱῵´-⁯⁲⁳⁺-⁾₊-₏₝-℁℃-℆℈℉℔№-℘℞-℣℥℧℩℮℺℻⅀-⅄⅊-⅍⅏↊-⑟⒜-⒵─-❵➔-⯿Ⱟⱟ⳥-⳪⳯-⳱⳴-⳼⳾⳿⴦⴨-⴬⴮⴯⵨-⵮⵰-⵿⶗-⶟⶧⶯⶷⶿⷇⷏⷗⷟⸀-⸮⸰-〄〈-〠〪-〰〶〷〽-぀゗-゜゠・㄀-㄄ㄮ-㄰㆏-㆑㆖-㆟ㆻ-㇯㈀-㈟㈪-㉇㉐㉠-㉿㊊-㊰㋀-㏿䶶-䷿鿖-鿿꒍-꓏꓾꓿꘍-꘏꘬-꘿꙯-꙳꙼-꙾꛰-꜖꜠꜡꞉꞊ꞮꞯꞸ-ꟶꠂ꠆ꠋ꠨-꠯꠶-꠿꡴-꡿꣄-꣏꣚-꣱꣸-꣺꣼ꣾꣿ꤫-꤯꥓-꥟꥽-꥿꦳꧀-꧎꧚-꧟ꧥ꧿꨷-꨿꩎꩏꩚-꩟꩷-꩹ꩻ-ꩽ꪿꫁꫃-꫚꫞꫟꫰꫱꫶-꬀꬇꬈꬏꬐꬗-꬟꬧꬯꭛ꭦ-꭯꯫-꯯꯺-꯿힤-힯퟇-퟊퟼-﩮﩯﫚-﫿﬇-﬒﬘-﬜﬩﬷﬽﬿﭂﭅﮲-﯒﴾-﵏﶐﶑﷈-﷯﷼-﹯﹵﻽-／：-＠［-｀｛-･﾿-￁￈￉￐￑￘￙￝-\uffff][^\u0000-\u001f!-+;-@\[\]-`{-©«-±´¶-¸»¿×÷˂-˅˒-˟˥-˫˭˯-̈́͆-ͯ͵͸͹;΀-΅·΋΍΢϶҂-҉԰՗՘՚-ՠֈ-֯־׀׃׆׈-׏׫-ׯ׳-؏؛-؟٘٪-٭۔۝-۠۩-۬۽۾܀-܏݀-݌޲-޿߫-߳߶-߹߻-߿࠘࠙࠭-࠿࡙-࢟ࢵ-࣢࣪-़्࣯॑-॔।॥॰঄঍঎঑঒঩঱঳-঵঺-়৅৆৉৊্৏-৖৘-৛৞৤৥৲৳৺-਀਄਋-਎਑਒਩਱਴਷਺-਽੃-੆੉੊੍-੐੒-੘੝੟-੥੶-઀઄઎઒઩઱઴઺-઼૆૊્-૏૑-૟૤૥૰-૸ૺ-଀଄଍଎଑଒଩଱଴଺-଼୅୆୉୊୍-୕୘-୛୞୤୥୰୸-஁஄஋-஍஑஖-஘஛஝஠-஢஥-஧஫-஭஺-஽௃-௅௉்-௏௑-௖௘-௥௳-௿ఄ఍఑఩఺-఼౅౉్-౔౗౛-౟౤౥౰-౷౿ಀ಄಍಑಩಴಺-಼೅೉್-೔೗-ೝ೟೤೥೰ೳ-ഀഄ഍഑഻഼൅൉്൏-ൖ൘-൞൤൥൶-൹඀ඁ඄඗-඙඲඼඾඿෇-෎෕෗෠-෥෰෱෴-฀฻-฿็-์๎๏๚-຀຃຅ຆຉ຋ຌຎ-ຓຘຠ຤຦ຨຩຬ຺຾຿໅໇-໌໎໏໚໛໠-໿༁-༟༴-༿཈཭-཰ྂ-྇྘྽-࿿့္်၊-၏ၣၤၩ-ၭႇ-ႍႏႚႛ႞႟჆჈-჌჎჏჻቉቎቏቗቙቞቟኉኎኏኱኶኷኿዁዆዇዗጑጖጗፛-፞፠-፨፽-፿᎐-᎟᏶᏷᏾-᐀᙭᙮ ᚛-᚟᛫-᛭᛹-᛿ᜍ᜔-ᜟ᜴-᜿᝔-᝟᝭᝱᝴-᝿឴឵៉-៖៘-៛៝-៟៪-៯៺-᠏᠚-᠟ᡸ-᡿᢫-᢯᣶-᣿᤟᤬-᤯᤹-᥅᥮᥯᥵-᥿᦬-᦯᧊-᧏᧛-᧿᨜-᨟᩟᩠᩵-᩿᪊-᪏᪚-᪦᪨-᫿᬴᭄ᭌ-᭏᭚-᭿᯦᮪᮫᯲-᯿ᰶ-᰿᱊-᱌᱾-᳨᳭᳴᳷-᳿᷀-ᷦ᷵-᷿἖἗἞἟὆὇὎὏὘὚὜὞὾὿᾵᾽᾿-῁῅῍-῏῔῕῜-῟῭-῱῵´-⁯⁲⁳⁺-⁾₊-₏₝-℁℃-℆℈℉℔№-℘℞-℣℥℧℩℮℺℻⅀-⅄⅊-⅍⅏↊-⑟⒜-⒵─-❵➔-⯿Ⱟⱟ⳥-⳪⳯-⳱⳴-⳼⳾⳿⴦⴨-⴬⴮⴯⵨-⵮⵰-⵿⶗-⶟⶧⶯⶷⶿⷇⷏⷗⷟⸀-⸮⸰-〄〈-〠〪-〰〶〷〽-぀゗-゜゠・㄀-㄄ㄮ-㄰㆏-㆑㆖-㆟ㆻ-㇯㈀-㈟㈪-㉇㉐㉠-㉿㊊-㊰㋀-㏿䶶-䷿鿖-鿿꒍-꓏꓾꓿꘍-꘏꘬-꘿꙯-꙳꙼-꙾꛰-꜖꜠꜡꞉꞊ꞮꞯꞸ-ꟶꠂ꠆ꠋ꠨-꠯꠶-꠿꡴-꡿꣄-꣏꣚-꣱꣸-꣺꣼ꣾꣿ꤫-꤯꥓-꥟꥽-꥿꦳꧀-꧎꧚-꧟ꧥ꧿꨷-꨿꩎꩏꩚-꩟꩷-꩹ꩻ-ꩽ꪿꫁꫃-꫚꫞꫟꫰꫱꫶-꬀꬇꬈꬏꬐꬗-꬟꬧꬯꭛ꭦ-꭯꯫-꯯꯺-꯿힤-힯퟇-퟊퟼-﩮﩯﫚-﫿﬇-﬒﬘-﬜﬩﬷﬽﬿﭂﭅﮲-﯒﴾-﵏﶐﶑﷈-﷯﷼-﹯﹵﻽-／：-＠［-｀｛-･﾿-￁￈￉￐￑￘￙￝-\uffff]+)(?=\s*$))/,
/^(?:((?:[0-9]+(?:\.[0-9]*)?|\.[0-9]+))[GKMgkm]|[0-9]+[GKMgkm][0-9]+)/,
/^(?:((?:[0-9]+(?:\.[0-9]*)?|\.[0-9]+))(?:[Ee][+-]?[0-9]+)?)/,
/^(?:[%](?=\s*([\u0000-\b\u000e-\u001f!-')-\/:-@\[-\^`{-¡-©«-±´¶-¸»¿×÷˂-˅˒-˟˥-˫˭˯-̈́͆-ͯ͵͸͹;΀-΅·΋΍΢϶҂-҉԰՗՘՚-ՠֈ-֯־׀׃׆׈-׏׫-ׯ׳-؏؛-؟٘٪-٭۔۝-۠۩-۬۽۾܀-܏݀-݌޲-޿߫-߳߶-߹߻-߿࠘࠙࠭-࠿࡙-࢟ࢵ-࣢࣪-़्࣯॑-॔।॥॰঄঍঎঑঒঩঱঳-঵঺-়৅৆৉৊্৏-৖৘-৛৞৤৥৲৳৺-਀਄਋-਎਑਒਩਱਴਷਺-਽੃-੆੉੊੍-੐੒-੘੝੟-੥੶-઀઄઎઒઩઱઴઺-઼૆૊્-૏૑-૟૤૥૰-૸ૺ-଀଄଍଎଑଒଩଱଴଺-଼୅୆୉୊୍-୕୘-୛୞୤୥୰୸-஁஄஋-஍஑஖-஘஛஝஠-஢஥-஧஫-஭஺-஽௃-௅௉்-௏௑-௖௘-௥௳-௿ఄ఍఑఩఺-఼౅౉్-౔౗౛-౟౤౥౰-౷౿ಀ಄಍಑಩಴಺-಼೅೉್-೔೗-ೝ೟೤೥೰ೳ-ഀഄ഍഑഻഼൅൉്൏-ൖ൘-൞൤൥൶-൹඀ඁ඄඗-඙඲඼඾඿෇-෎෕෗෠-෥෰෱෴-฀฻-฿็-์๎๏๚-຀຃຅ຆຉ຋ຌຎ-ຓຘຠ຤຦ຨຩຬ຺຾຿໅໇-໌໎໏໚໛໠-໿༁-༟༴-༿཈཭-཰ྂ-྇྘྽-࿿့္်၊-၏ၣၤၩ-ၭႇ-ႍႏႚႛ႞႟჆჈-჌჎჏჻቉቎቏቗቙቞቟኉኎኏኱኶኷኿዁዆዇዗጑጖጗፛-፞፠-፨፽-፿᎐-᎟᏶᏷᏾-᐀᙭᙮᚛-᚟᛫-᛭᛹-᛿ᜍ᜔-ᜟ᜴-᜿᝔-᝟᝭᝱᝴-᝿឴឵៉-៖៘-៛៝-៟៪-៯៺-᠍᠏᠚-᠟ᡸ-᡿᢫-᢯᣶-᣿᤟᤬-᤯᤹-᥅᥮᥯᥵-᥿᦬-᦯᧊-᧏᧛-᧿᨜-᨟᩟᩠᩵-᩿᪊-᪏᪚-᪦᪨-᫿᬴᭄ᭌ-᭏᭚-᭿᯦᮪᮫᯲-᯿ᰶ-᰿᱊-᱌᱾-᳨᳭᳴᳷-᳿᷀-ᷦ᷵-᷿἖἗἞἟὆὇὎὏὘὚὜὞὾὿᾵᾽᾿-῁῅῍-῏῔῕῜-῟῭-῱῵´-῿​-‧‪-‮‰-⁞⁠-⁯⁲⁳⁺-⁾₊-₏₝-℁℃-℆℈℉℔№-℘℞-℣℥℧℩℮℺℻⅀-⅄⅊-⅍⅏↊-⑟⒜-⒵─-❵➔-⯿Ⱟⱟ⳥-⳪⳯-⳱⳴-⳼⳾⳿⴦⴨-⴬⴮⴯⵨-⵮⵰-⵿⶗-⶟⶧⶯⶷⶿⷇⷏⷗⷟⸀-⸮⸰-⿿、-〄〈-〠〪-〰〶〷〽-぀゗-゜゠・㄀-㄄ㄮ-㄰㆏-㆑㆖-㆟ㆻ-㇯㈀-㈟㈪-㉇㉐㉠-㉿㊊-㊰㋀-㏿䶶-䷿鿖-鿿꒍-꓏꓾꓿꘍-꘏꘬-꘿꙯-꙳꙼-꙾꛰-꜖꜠꜡꞉꞊ꞮꞯꞸ-ꟶꠂ꠆ꠋ꠨-꠯꠶-꠿꡴-꡿꣄-꣏꣚-꣱꣸-꣺꣼ꣾꣿ꤫-꤯꥓-꥟꥽-꥿꦳꧀-꧎꧚-꧟ꧥ꧿꨷-꨿꩎꩏꩚-꩟꩷-꩹ꩻ-ꩽ꪿꫁꫃-꫚꫞꫟꫰꫱꫶-꬀꬇꬈꬏꬐꬗-꬟꬧꬯꭛ꭦ-꭯꯫-꯯꯺-꯿힤-힯퟇-퟊퟼-﩮﩯﫚-﫿﬇-﬒﬘-﬜﬩﬷﬽﬿﭂﭅﮲-﯒﴾-﵏﶐﶑﷈-﷯﷼-﹯﹵﻽﻾＀-／：-＠［-｀｛-･﾿-￁￈￉￐￑￘￙￝-\uffff]|$)))/,
/^(?:([\u0000-\b\u000e-\u001f!-\/:-@\[-\^`{-¡-©«-±´¶-¸»¿×÷˂-˅˒-˟˥-˫˭˯-̈́͆-ͯ͵͸͹;΀-΅·΋΍΢϶҂-҉԰՗՘՚-ՠֈ-֯־׀׃׆׈-׏׫-ׯ׳-؏؛-؟٘٪-٭۔۝-۠۩-۬۽۾܀-܏݀-݌޲-޿߫-߳߶-߹߻-߿࠘࠙࠭-࠿࡙-࢟ࢵ-࣢࣪-़्࣯॑-॔।॥॰঄঍঎঑঒঩঱঳-঵঺-়৅৆৉৊্৏-৖৘-৛৞৤৥৲৳৺-਀਄਋-਎਑਒਩਱਴਷਺-਽੃-੆੉੊੍-੐੒-੘੝੟-੥੶-઀઄઎઒઩઱઴઺-઼૆૊્-૏૑-૟૤૥૰-૸ૺ-଀଄଍଎଑଒଩଱଴଺-଼୅୆୉୊୍-୕୘-୛୞୤୥୰୸-஁஄஋-஍஑஖-஘஛஝஠-஢஥-஧஫-஭஺-஽௃-௅௉்-௏௑-௖௘-௥௳-௿ఄ఍఑఩఺-఼౅౉్-౔౗౛-౟౤౥౰-౷౿ಀ಄಍಑಩಴಺-಼೅೉್-೔೗-ೝ೟೤೥೰ೳ-ഀഄ഍഑഻഼൅൉്൏-ൖ൘-൞൤൥൶-൹඀ඁ඄඗-඙඲඼඾඿෇-෎෕෗෠-෥෰෱෴-฀฻-฿็-์๎๏๚-຀຃຅ຆຉ຋ຌຎ-ຓຘຠ຤຦ຨຩຬ຺຾຿໅໇-໌໎໏໚໛໠-໿༁-༟༴-༿཈཭-཰ྂ-྇྘྽-࿿့္်၊-၏ၣၤၩ-ၭႇ-ႍႏႚႛ႞႟჆჈-჌჎჏჻቉቎቏቗቙቞቟኉኎኏኱኶኷኿዁዆዇዗጑጖጗፛-፞፠-፨፽-፿᎐-᎟᏶᏷᏾-᐀᙭᙮᚛-᚟᛫-᛭᛹-᛿ᜍ᜔-ᜟ᜴-᜿᝔-᝟᝭᝱᝴-᝿឴឵៉-៖៘-៛៝-៟៪-៯៺-᠍᠏᠚-᠟ᡸ-᡿᢫-᢯᣶-᣿᤟᤬-᤯᤹-᥅᥮᥯᥵-᥿᦬-᦯᧊-᧏᧛-᧿᨜-᨟᩟᩠᩵-᩿᪊-᪏᪚-᪦᪨-᫿᬴᭄ᭌ-᭏᭚-᭿᯦᮪᮫᯲-᯿ᰶ-᰿᱊-᱌᱾-᳨᳭᳴᳷-᳿᷀-ᷦ᷵-᷿἖἗἞἟὆὇὎὏὘὚὜὞὾὿᾵᾽᾿-῁῅῍-῏῔῕῜-῟῭-῱῵´-῿​-‧‪-‮‰-⁞⁠-⁯⁲⁳⁺-⁾₊-₏₝-℁℃-℆℈℉℔№-℘℞-℣℥℧℩℮℺℻⅀-⅄⅊-⅍⅏↊-⑟⒜-⒵─-❵➔-⯿Ⱟⱟ⳥-⳪⳯-⳱⳴-⳼⳾⳿⴦⴨-⴬⴮⴯⵨-⵮⵰-⵿⶗-⶟⶧⶯⶷⶿⷇⷏⷗⷟⸀-⸮⸰-⿿、-〄〈-〠〪-〰〶〷〽-぀゗-゜゠・㄀-㄄ㄮ-㄰㆏-㆑㆖-㆟ㆻ-㇯㈀-㈟㈪-㉇㉐㉠-㉿㊊-㊰㋀-㏿䶶-䷿鿖-鿿꒍-꓏꓾꓿꘍-꘏꘬-꘿꙯-꙳꙼-꙾꛰-꜖꜠꜡꞉꞊ꞮꞯꞸ-ꟶꠂ꠆ꠋ꠨-꠯꠶-꠿꡴-꡿꣄-꣏꣚-꣱꣸-꣺꣼ꣾꣿ꤫-꤯꥓-꥟꥽-꥿꦳꧀-꧎꧚-꧟ꧥ꧿꨷-꨿꩎꩏꩚-꩟꩷-꩹ꩻ-ꩽ꪿꫁꫃-꫚꫞꫟꫰꫱꫶-꬀꬇꬈꬏꬐꬗-꬟꬧꬯꭛ꭦ-꭯꯫-꯯꯺-꯿힤-힯퟇-퟊퟼-﩮﩯﫚-﫿﬇-﬒﬘-﬜﬩﬷﬽﬿﭂﭅﮲-﯒﴾-﵏﶐﶑﷈-﷯﷼-﹯﹵﻽﻾＀-／：-＠［-｀｛-･﾿-￁￈￉￐￑￘￙￝-\uffff]{1,3}))/,
/^(?:\()/,
/^(?:\))/,
/^(?:\{)/,
/^(?:\})/,
/^(?:\[)/,
/^(?:\])/,
/^(?:\u2039([^›]*)\u203a)/,
/^(?:\u201c([^”]*)\u201d)/,
/^(?:\u00ab([^»]*)\u00bb)/,
/^(?:'(.*)$)/,
/^(?:"(.*)$)/,
/^(?:'([^']*(?:''[^']*)*)'(\s*(?:$|[\u0000-\b\u000e-\u001f#%&)-\-\/:-?\\-\^`|-¡-©«-±´¶-¸»¿×÷˂-˅˒-˟˥-˫˭˯-̈́͆-ͯ͵͸͹;΀-΅·΋΍΢϶҂-҉԰՗՘՚-ՠֈ-֯־׀׃׆׈-׏׫-ׯ׳-؏؛-؟٘٪-٭۔۝-۠۩-۬۽۾܀-܏݀-݌޲-޿߫-߳߶-߹߻-߿࠘࠙࠭-࠿࡙-࢟ࢵ-࣢࣪-़्࣯॑-॔।॥॰঄঍঎঑঒঩঱঳-঵঺-়৅৆৉৊্৏-৖৘-৛৞৤৥৲৳৺-਀਄਋-਎਑਒਩਱਴਷਺-਽੃-੆੉੊੍-੐੒-੘੝੟-੥੶-઀઄઎઒઩઱઴઺-઼૆૊્-૏૑-૟૤૥૰-૸ૺ-଀଄଍଎଑଒଩଱଴଺-଼୅୆୉୊୍-୕୘-୛୞୤୥୰୸-஁஄஋-஍஑஖-஘஛஝஠-஢஥-஧஫-஭஺-஽௃-௅௉்-௏௑-௖௘-௥௳-௿ఄ఍఑఩఺-఼౅౉్-౔౗౛-౟౤౥౰-౷౿ಀ಄಍಑಩಴಺-಼೅೉್-೔೗-ೝ೟೤೥೰ೳ-ഀഄ഍഑഻഼൅൉്൏-ൖ൘-൞൤൥൶-൹඀ඁ඄඗-඙඲඼඾඿෇-෎෕෗෠-෥෰෱෴-฀฻-฿็-์๎๏๚-຀຃຅ຆຉ຋ຌຎ-ຓຘຠ຤຦ຨຩຬ຺຾຿໅໇-໌໎໏໚໛໠-໿༁-༟༴-༿཈཭-཰ྂ-྇྘྽-࿿့္်၊-၏ၣၤၩ-ၭႇ-ႍႏႚႛ႞႟჆჈-჌჎჏჻቉቎቏቗቙቞቟኉኎኏኱኶኷኿዁዆዇዗጑጖጗፛-፞፠-፨፽-፿᎐-᎟᏶᏷᏾-᐀᙭᙮᚛-᚟᛫-᛭᛹-᛿ᜍ᜔-ᜟ᜴-᜿᝔-᝟᝭᝱᝴-᝿឴឵៉-៖៘-៛៝-៟៪-៯៺-᠍᠏᠚-᠟ᡸ-᡿᢫-᢯᣶-᣿᤟᤬-᤯᤹-᥅᥮᥯᥵-᥿᦬-᦯᧊-᧏᧛-᧿᨜-᨟᩟᩠᩵-᩿᪊-᪏᪚-᪦᪨-᫿᬴᭄ᭌ-᭏᭚-᭿᯦᮪᮫᯲-᯿ᰶ-᰿᱊-᱌᱾-᳨᳭᳴᳷-᳿᷀-ᷦ᷵-᷿἖἗἞἟὆὇὎὏὘὚὜὞὾὿᾵᾽᾿-῁῅῍-῏῔῕῜-῟῭-῱῵´-῿​-‧‪-‮‰-⁞⁠-⁯⁲⁳⁺-⁾₊-₏₝-℁℃-℆℈℉℔№-℘℞-℣℥℧℩℮℺℻⅀-⅄⅊-⅍⅏↊-⑟⒜-⒵─-❵➔-⯿Ⱟⱟ⳥-⳪⳯-⳱⳴-⳼⳾⳿⴦⴨-⴬⴮⴯⵨-⵮⵰-⵿⶗-⶟⶧⶯⶷⶿⷇⷏⷗⷟⸀-⸮⸰-⿿、-〄〈-〠〪-〰〶〷〽-぀゗-゜゠・㄀-㄄ㄮ-㄰㆏-㆑㆖-㆟ㆻ-㇯㈀-㈟㈪-㉇㉐㉠-㉿㊊-㊰㋀-㏿䶶-䷿鿖-鿿꒍-꓏꓾꓿꘍-꘏꘬-꘿꙯-꙳꙼-꙾꛰-꜖꜠꜡꞉꞊ꞮꞯꞸ-ꟶꠂ꠆ꠋ꠨-꠯꠶-꠿꡴-꡿꣄-꣏꣚-꣱꣸-꣺꣼ꣾꣿ꤫-꤯꥓-꥟꥽-꥿꦳꧀-꧎꧚-꧟ꧥ꧿꨷-꨿꩎꩏꩚-꩟꩷-꩹ꩻ-ꩽ꪿꫁꫃-꫚꫞꫟꫰꫱꫶-꬀꬇꬈꬏꬐꬗-꬟꬧꬯꭛ꭦ-꭯꯫-꯯꯺-꯿힤-힯퟇-퟊퟼-﩮﩯﫚-﫿﬇-﬒﬘-﬜﬩﬷﬽﬿﭂﭅﮲-﯒﴾-﵏﶐﶑﷈-﷯﷼-﹯﹵﻽﻾＀-／：-＠［-｀｛-･﾿-￁￈￉￐￑￘￙￝-\uffff])))/,
/^(?:"([^"]*(?:""[^"]*)*)"(\s*(?:$|[\u0000-\b\u000e-\u001f#%&)-\-\/:-?\\-\^`|-¡-©«-±´¶-¸»¿×÷˂-˅˒-˟˥-˫˭˯-̈́͆-ͯ͵͸͹;΀-΅·΋΍΢϶҂-҉԰՗՘՚-ՠֈ-֯־׀׃׆׈-׏׫-ׯ׳-؏؛-؟٘٪-٭۔۝-۠۩-۬۽۾܀-܏݀-݌޲-޿߫-߳߶-߹߻-߿࠘࠙࠭-࠿࡙-࢟ࢵ-࣢࣪-़्࣯॑-॔।॥॰঄঍঎঑঒঩঱঳-঵঺-়৅৆৉৊্৏-৖৘-৛৞৤৥৲৳৺-਀਄਋-਎਑਒਩਱਴਷਺-਽੃-੆੉੊੍-੐੒-੘੝੟-੥੶-઀઄઎઒઩઱઴઺-઼૆૊્-૏૑-૟૤૥૰-૸ૺ-଀଄଍଎଑଒଩଱଴଺-଼୅୆୉୊୍-୕୘-୛୞୤୥୰୸-஁஄஋-஍஑஖-஘஛஝஠-஢஥-஧஫-஭஺-஽௃-௅௉்-௏௑-௖௘-௥௳-௿ఄ఍఑఩఺-఼౅౉్-౔౗౛-౟౤౥౰-౷౿ಀ಄಍಑಩಴಺-಼೅೉್-೔೗-ೝ೟೤೥೰ೳ-ഀഄ഍഑഻഼൅൉്൏-ൖ൘-൞൤൥൶-൹඀ඁ඄඗-඙඲඼඾඿෇-෎෕෗෠-෥෰෱෴-฀฻-฿็-์๎๏๚-຀຃຅ຆຉ຋ຌຎ-ຓຘຠ຤຦ຨຩຬ຺຾຿໅໇-໌໎໏໚໛໠-໿༁-༟༴-༿཈཭-཰ྂ-྇྘྽-࿿့္်၊-၏ၣၤၩ-ၭႇ-ႍႏႚႛ႞႟჆჈-჌჎჏჻቉቎቏቗቙቞቟኉኎኏኱኶኷኿዁዆዇዗጑጖጗፛-፞፠-፨፽-፿᎐-᎟᏶᏷᏾-᐀᙭᙮᚛-᚟᛫-᛭᛹-᛿ᜍ᜔-ᜟ᜴-᜿᝔-᝟᝭᝱᝴-᝿឴឵៉-៖៘-៛៝-៟៪-៯៺-᠍᠏᠚-᠟ᡸ-᡿᢫-᢯᣶-᣿᤟᤬-᤯᤹-᥅᥮᥯᥵-᥿᦬-᦯᧊-᧏᧛-᧿᨜-᨟᩟᩠᩵-᩿᪊-᪏᪚-᪦᪨-᫿᬴᭄ᭌ-᭏᭚-᭿᯦᮪᮫᯲-᯿ᰶ-᰿᱊-᱌᱾-᳨᳭᳴᳷-᳿᷀-ᷦ᷵-᷿἖἗἞἟὆὇὎὏὘὚὜὞὾὿᾵᾽᾿-῁῅῍-῏῔῕῜-῟῭-῱῵´-῿​-‧‪-‮‰-⁞⁠-⁯⁲⁳⁺-⁾₊-₏₝-℁℃-℆℈℉℔№-℘℞-℣℥℧℩℮℺℻⅀-⅄⅊-⅍⅏↊-⑟⒜-⒵─-❵➔-⯿Ⱟⱟ⳥-⳪⳯-⳱⳴-⳼⳾⳿⴦⴨-⴬⴮⴯⵨-⵮⵰-⵿⶗-⶟⶧⶯⶷⶿⷇⷏⷗⷟⸀-⸮⸰-⿿、-〄〈-〠〪-〰〶〷〽-぀゗-゜゠・㄀-㄄ㄮ-㄰㆏-㆑㆖-㆟ㆻ-㇯㈀-㈟㈪-㉇㉐㉠-㉿㊊-㊰㋀-㏿䶶-䷿鿖-鿿꒍-꓏꓾꓿꘍-꘏꘬-꘿꙯-꙳꙼-꙾꛰-꜖꜠꜡꞉꞊ꞮꞯꞸ-ꟶꠂ꠆ꠋ꠨-꠯꠶-꠿꡴-꡿꣄-꣏꣚-꣱꣸-꣺꣼ꣾꣿ꤫-꤯꥓-꥟꥽-꥿꦳꧀-꧎꧚-꧟ꧥ꧿꨷-꨿꩎꩏꩚-꩟꩷-꩹ꩻ-ꩽ꪿꫁꫃-꫚꫞꫟꫰꫱꫶-꬀꬇꬈꬏꬐꬗-꬟꬧꬯꭛ꭦ-꭯꯫-꯯꯺-꯿힤-힯퟇-퟊퟼-﩮﩯﫚-﫿﬇-﬒﬘-﬜﬩﬷﬽﬿﭂﭅﮲-﯒﴾-﵏﶐﶑﷈-﷯﷼-﹯﹵﻽﻾＀-／：-＠［-｀｛-･﾿-￁￈￉￐￑￘￙￝-\uffff])))/,
/^(?:\s+)/,
/^(?:$)/,
/^(?:([^\u0000-\/:-@\[-\^`{-©«-±´¶-¸»¿×÷˂-˅˒-˟˥-˫˭˯-̈́͆-ͯ͵͸͹;΀-΅·΋΍΢϶҂-҉԰՗՘՚-ՠֈ-֯־׀׃׆׈-׏׫-ׯ׳-؏؛-؟٘٪-٭۔۝-۠۩-۬۽۾܀-܏݀-݌޲-޿߫-߳߶-߹߻-߿࠘࠙࠭-࠿࡙-࢟ࢵ-࣢࣪-़्࣯॑-॔।॥॰঄঍঎঑঒঩঱঳-঵঺-়৅৆৉৊্৏-৖৘-৛৞৤৥৲৳৺-਀਄਋-਎਑਒਩਱਴਷਺-਽੃-੆੉੊੍-੐੒-੘੝੟-੥੶-઀઄઎઒઩઱઴઺-઼૆૊્-૏૑-૟૤૥૰-૸ૺ-଀଄଍଎଑଒଩଱଴଺-଼୅୆୉୊୍-୕୘-୛୞୤୥୰୸-஁஄஋-஍஑஖-஘஛஝஠-஢஥-஧஫-஭஺-஽௃-௅௉்-௏௑-௖௘-௥௳-௿ఄ఍఑఩఺-఼౅౉్-౔౗౛-౟౤౥౰-౷౿ಀ಄಍಑಩಴಺-಼೅೉್-೔೗-ೝ೟೤೥೰ೳ-ഀഄ഍഑഻഼൅൉്൏-ൖ൘-൞൤൥൶-൹඀ඁ඄඗-඙඲඼඾඿෇-෎෕෗෠-෥෰෱෴-฀฻-฿็-์๎๏๚-຀຃຅ຆຉ຋ຌຎ-ຓຘຠ຤຦ຨຩຬ຺຾຿໅໇-໌໎໏໚໛໠-໿༁-༟༴-༿཈཭-཰ྂ-྇྘྽-࿿့္်၊-၏ၣၤၩ-ၭႇ-ႍႏႚႛ႞႟჆჈-჌჎჏჻቉቎቏቗቙቞቟኉኎኏኱኶኷኿዁዆዇዗጑጖጗፛-፞፠-፨፽-፿᎐-᎟᏶᏷᏾-᐀᙭᙮ ᚛-᚟᛫-᛭᛹-᛿ᜍ᜔-ᜟ᜴-᜿᝔-᝟᝭᝱᝴-᝿឴឵៉-៖៘-៛៝-៟៪-៯៺-᠏᠚-᠟ᡸ-᡿᢫-᢯᣶-᣿᤟᤬-᤯᤹-᥅᥮᥯᥵-᥿᦬-᦯᧊-᧏᧛-᧿᨜-᨟᩟᩠᩵-᩿᪊-᪏᪚-᪦᪨-᫿᬴᭄ᭌ-᭏᭚-᭿᯦᮪᮫᯲-᯿ᰶ-᰿᱊-᱌᱾-᳨᳭᳴᳷-᳿᷀-ᷦ᷵-᷿἖἗἞἟὆὇὎὏὘὚὜὞὾὿᾵᾽᾿-῁῅῍-῏῔῕῜-῟῭-῱῵´-⁯⁲⁳⁺-⁾₊-₏₝-℁℃-℆℈℉℔№-℘℞-℣℥℧℩℮℺℻⅀-⅄⅊-⅍⅏↊-⑟⒜-⒵─-❵➔-⯿Ⱟⱟ⳥-⳪⳯-⳱⳴-⳼⳾⳿⴦⴨-⴬⴮⴯⵨-⵮⵰-⵿⶗-⶟⶧⶯⶷⶿⷇⷏⷗⷟⸀-⸮⸰-〄〈-〠〪-〰〶〷〽-぀゗-゜゠・㄀-㄄ㄮ-㄰㆏-㆑㆖-㆟ㆻ-㇯㈀-㈟㈪-㉇㉐㉠-㉿㊊-㊰㋀-㏿䶶-䷿鿖-鿿꒍-꓏꓾꓿꘍-꘏꘬-꘿꙯-꙳꙼-꙾꛰-꜖꜠꜡꞉꞊ꞮꞯꞸ-ꟶꠂ꠆ꠋ꠨-꠯꠶-꠿꡴-꡿꣄-꣏꣚-꣱꣸-꣺꣼ꣾꣿ꤫-꤯꥓-꥟꥽-꥿꦳꧀-꧎꧚-꧟ꧥ꧿꨷-꨿꩎꩏꩚-꩟꩷-꩹ꩻ-ꩽ꪿꫁꫃-꫚꫞꫟꫰꫱꫶-꬀꬇꬈꬏꬐꬗-꬟꬧꬯꭛ꭦ-꭯꯫-꯯꯺-꯿힤-힯퟇-퟊퟼-﩮﩯﫚-﫿﬇-﬒﬘-﬜﬩﬷﬽﬿﭂﭅﮲-﯒﴾-﵏﶐﶑﷈-﷯﷼-﹯﹵﻽-／：-＠［-｀｛-･﾿-￁￈￉￐￑￘￙￝-\uffff](?:[^\u0000-\b\u000e-\u001f!-\-\/:-@\[-\^`{-¡-©«-±´¶-¸»¿×÷˂-˅˒-˟˥-˫˭˯-̈́͆-ͯ͵͸͹;΀-΅·΋΍΢϶҂-҉԰՗՘՚-ՠֈ-֯־׀׃׆׈-׏׫-ׯ׳-؏؛-؟٘٪-٭۔۝-۠۩-۬۽۾܀-܏݀-݌޲-޿߫-߳߶-߹߻-߿࠘࠙࠭-࠿࡙-࢟ࢵ-࣢࣪-़्࣯॑-॔।॥॰঄঍঎঑঒঩঱঳-঵঺-়৅৆৉৊্৏-৖৘-৛৞৤৥৲৳৺-਀਄਋-਎਑਒਩਱਴਷਺-਽੃-੆੉੊੍-੐੒-੘੝੟-੥੶-઀઄઎઒઩઱઴઺-઼૆૊્-૏૑-૟૤૥૰-૸ૺ-଀଄଍଎଑଒଩଱଴଺-଼୅୆୉୊୍-୕୘-୛୞୤୥୰୸-஁஄஋-஍஑஖-஘஛஝஠-஢஥-஧஫-஭஺-஽௃-௅௉்-௏௑-௖௘-௥௳-௿ఄ఍఑఩఺-఼౅౉్-౔౗౛-౟౤౥౰-౷౿ಀ಄಍಑಩಴಺-಼೅೉್-೔೗-ೝ೟೤೥೰ೳ-ഀഄ഍഑഻഼൅൉്൏-ൖ൘-൞൤൥൶-൹඀ඁ඄඗-඙඲඼඾඿෇-෎෕෗෠-෥෰෱෴-฀฻-฿็-์๎๏๚-຀຃຅ຆຉ຋ຌຎ-ຓຘຠ຤຦ຨຩຬ຺຾຿໅໇-໌໎໏໚໛໠-໿༁-༟༴-༿཈཭-཰ྂ-྇྘྽-࿿့္်၊-၏ၣၤၩ-ၭႇ-ႍႏႚႛ႞႟჆჈-჌჎჏჻቉቎቏቗቙቞቟኉኎኏኱኶኷኿዁዆዇዗጑጖጗፛-፞፠-፨፽-፿᎐-᎟᏶᏷᏾-᐀᙭᙮᚛-᚟᛫-᛭᛹-᛿ᜍ᜔-ᜟ᜴-᜿᝔-᝟᝭᝱᝴-᝿឴឵៉-៖៘-៛៝-៟៪-៯៺-᠍᠏᠚-᠟ᡸ-᡿᢫-᢯᣶-᣿᤟᤬-᤯᤹-᥅᥮᥯᥵-᥿᦬-᦯᧊-᧏᧛-᧿᨜-᨟᩟᩠᩵-᩿᪊-᪏᪚-᪦᪨-᫿᬴᭄ᭌ-᭏᭚-᭿᯦᮪᮫᯲-᯿ᰶ-᰿᱊-᱌᱾-᳨᳭᳴᳷-᳿᷀-ᷦ᷵-᷿἖἗἞἟὆὇὎὏὘὚὜὞὾὿᾵᾽᾿-῁῅῍-῏῔῕῜-῟῭-῱῵´-῿​-‧‪-‮‰-⁞⁠-⁯⁲⁳⁺-⁾₊-₏₝-℁℃-℆℈℉℔№-℘℞-℣℥℧℩℮℺℻⅀-⅄⅊-⅍⅏↊-⑟⒜-⒵─-❵➔-⯿Ⱟⱟ⳥-⳪⳯-⳱⳴-⳼⳾⳿⴦⴨-⴬⴮⴯⵨-⵮⵰-⵿⶗-⶟⶧⶯⶷⶿⷇⷏⷗⷟⸀-⸮⸰-⿿、-〄〈-〠〪-〰〶〷〽-぀゗-゜゠・㄀-㄄ㄮ-㄰㆏-㆑㆖-㆟ㆻ-㇯㈀-㈟㈪-㉇㉐㉠-㉿㊊-㊰㋀-㏿䶶-䷿鿖-鿿꒍-꓏꓾꓿꘍-꘏꘬-꘿꙯-꙳꙼-꙾꛰-꜖꜠꜡꞉꞊ꞮꞯꞸ-ꟶꠂ꠆ꠋ꠨-꠯꠶-꠿꡴-꡿꣄-꣏꣚-꣱꣸-꣺꣼ꣾꣿ꤫-꤯꥓-꥟꥽-꥿꦳꧀-꧎꧚-꧟ꧥ꧿꨷-꨿꩎꩏꩚-꩟꩷-꩹ꩻ-ꩽ꪿꫁꫃-꫚꫞꫟꫰꫱꫶-꬀꬇꬈꬏꬐꬗-꬟꬧꬯꭛ꭦ-꭯꯫-꯯꯺-꯿힤-힯퟇-퟊퟼-﩮﩯﫚-﫿﬇-﬒﬘-﬜﬩﬷﬽﬿﭂﭅﮲-﯒﴾-﵏﶐﶑﷈-﷯﷼-﹯﹵﻽﻾＀-／：-＠［-｀｛-･﾿-￁￈￉￐￑￘￙￝-\uffff]*[^\u0000-\/:-@\[-\^`{-©«-±´¶-¸»¿×÷˂-˅˒-˟˥-˫˭˯-̈́͆-ͯ͵͸͹;΀-΅·΋΍΢϶҂-҉԰՗՘՚-ՠֈ-֯־׀׃׆׈-׏׫-ׯ׳-؏؛-؟٘٪-٭۔۝-۠۩-۬۽۾܀-܏݀-݌޲-޿߫-߳߶-߹߻-߿࠘࠙࠭-࠿࡙-࢟ࢵ-࣢࣪-़्࣯॑-॔।॥॰঄঍঎঑঒঩঱঳-঵঺-়৅৆৉৊্৏-৖৘-৛৞৤৥৲৳৺-਀਄਋-਎਑਒਩਱਴਷਺-਽੃-੆੉੊੍-੐੒-੘੝੟-੥੶-઀઄઎઒઩઱઴઺-઼૆૊્-૏૑-૟૤૥૰-૸ૺ-଀଄଍଎଑଒଩଱଴଺-଼୅୆୉୊୍-୕୘-୛୞୤୥୰୸-஁஄஋-஍஑஖-஘஛஝஠-஢஥-஧஫-஭஺-஽௃-௅௉்-௏௑-௖௘-௥௳-௿ఄ఍఑఩఺-఼౅౉్-౔౗౛-౟౤౥౰-౷౿ಀ಄಍಑಩಴಺-಼೅೉್-೔೗-ೝ೟೤೥೰ೳ-ഀഄ഍഑഻഼൅൉്൏-ൖ൘-൞൤൥൶-൹඀ඁ඄඗-඙඲඼඾඿෇-෎෕෗෠-෥෰෱෴-฀฻-฿็-์๎๏๚-຀຃຅ຆຉ຋ຌຎ-ຓຘຠ຤຦ຨຩຬ຺຾຿໅໇-໌໎໏໚໛໠-໿༁-༟༴-༿཈཭-཰ྂ-྇྘྽-࿿့္်၊-၏ၣၤၩ-ၭႇ-ႍႏႚႛ႞႟჆჈-჌჎჏჻቉቎቏቗቙቞቟኉኎኏኱኶኷኿዁዆዇዗጑጖጗፛-፞፠-፨፽-፿᎐-᎟᏶᏷᏾-᐀᙭᙮ ᚛-᚟᛫-᛭᛹-᛿ᜍ᜔-ᜟ᜴-᜿᝔-᝟᝭᝱᝴-᝿឴឵៉-៖៘-៛៝-៟៪-៯៺-᠏᠚-᠟ᡸ-᡿᢫-᢯᣶-᣿᤟᤬-᤯᤹-᥅᥮᥯᥵-᥿᦬-᦯᧊-᧏᧛-᧿᨜-᨟᩟᩠᩵-᩿᪊-᪏᪚-᪦᪨-᫿᬴᭄ᭌ-᭏᭚-᭿᯦᮪᮫᯲-᯿ᰶ-᰿᱊-᱌᱾-᳨᳭᳴᳷-᳿᷀-ᷦ᷵-᷿἖἗἞἟὆὇὎὏὘὚὜὞὾὿᾵᾽᾿-῁῅῍-῏῔῕῜-῟῭-῱῵´-⁯⁲⁳⁺-⁾₊-₏₝-℁℃-℆℈℉℔№-℘℞-℣℥℧℩℮℺℻⅀-⅄⅊-⅍⅏↊-⑟⒜-⒵─-❵➔-⯿Ⱟⱟ⳥-⳪⳯-⳱⳴-⳼⳾⳿⴦⴨-⴬⴮⴯⵨-⵮⵰-⵿⶗-⶟⶧⶯⶷⶿⷇⷏⷗⷟⸀-⸮⸰-〄〈-〠〪-〰〶〷〽-぀゗-゜゠・㄀-㄄ㄮ-㄰㆏-㆑㆖-㆟ㆻ-㇯㈀-㈟㈪-㉇㉐㉠-㉿㊊-㊰㋀-㏿䶶-䷿鿖-鿿꒍-꓏꓾꓿꘍-꘏꘬-꘿꙯-꙳꙼-꙾꛰-꜖꜠꜡꞉꞊ꞮꞯꞸ-ꟶꠂ꠆ꠋ꠨-꠯꠶-꠿꡴-꡿꣄-꣏꣚-꣱꣸-꣺꣼ꣾꣿ꤫-꤯꥓-꥟꥽-꥿꦳꧀-꧎꧚-꧟ꧥ꧿꨷-꨿꩎꩏꩚-꩟꩷-꩹ꩻ-ꩽ꪿꫁꫃-꫚꫞꫟꫰꫱꫶-꬀꬇꬈꬏꬐꬗-꬟꬧꬯꭛ꭦ-꭯꯫-꯯꯺-꯿힤-힯퟇-퟊퟼-﩮﩯﫚-﫿﬇-﬒﬘-﬜﬩﬷﬽﬿﭂﭅﮲-﯒﴾-﵏﶐﶑﷈-﷯﷼-﹯﹵﻽-／：-＠［-｀｛-･﾿-￁￈￉￐￑￘￙￝-\uffff])?))/,
/^(?:.)/,
/^(?:[^!#)*\/}‼▌▐]+)/,
/^(?:.)/,
/^(?:..)/,
/^(?:$)/
],
conditions: {
  "PARSE_MODE_DETECTION": {
    rules: [
      0,
      1,
      2,
      3,
      4
    ],
    inclusive: false
  },
  "INLINE_COMMENT": {
    rules: [
      36,
      37,
      38,
      39
    ],
    inclusive: false
  },
  "INITIAL": {
    rules: [
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      12,
      13,
      14,
      15,
      16,
      17,
      18,
      19,
      20,
      21,
      22,
      23,
      24,
      25,
      26,
      27,
      28,
      29,
      30,
      31,
      32,
      33,
      34,
      35
    ],
    inclusive: true
  }
}
};

return lexer;
})();
parser.lexer = lexer;

function Parser() {
  this.yy = {};
}
Parser.prototype = parser;
parser.Parser = Parser;

return new Parser();
})();




if (typeof require !== 'undefined' && typeof exports !== 'undefined') {
  exports.parser = formulaV3;
  exports.Parser = formulaV3.Parser;
  exports.parse = function () {
    return formulaV3.parse.apply(formulaV3, arguments);
  };

}
